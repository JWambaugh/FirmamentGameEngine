<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/flash/_std/EReg.hx">
		<customReplace public="1" set="method" line="74">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</customReplace>
		<replace public="1" set="method" line="70">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.</haxe_doc>
		</replace>
		<split public="1" set="method" line="63">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split a string by using the regular expression to match
		the separators.</haxe_doc>
		</split>
		<matchedPos public="1" set="method" line="58">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position of the matched substring within the
		original matched string.</haxe_doc>
		</matchedPos>
		<matchedRight public="1" set="method" line="51">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was at the right of
		of the matched substring.</haxe_doc>
		</matchedRight>
		<matchedLeft public="1" set="method" line="45">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was as the left of
		of the matched substring.</haxe_doc>
		</matchedLeft>
		<matched public="1" set="method" line="41">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.</haxe_doc>
		</matched>
		<match public="1" set="method" line="35">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the regular expression matches the String.
		Updates the internal state accordingly.</haxe_doc>
		</match>
		<result><c path="+Array"/></result>
		<r><c path="flash.utils.RegExp"/></r>
		<new public="1" set="method" line="31">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern [r] and
		options [opt].</haxe_doc>
		</new>
		<haxe_doc>Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/flash/_std/Hash.hx">
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntHash" params="T" file="/usr/lib/haxe/std/flash/_std/IntHash.hx">
		<toString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an [Array] from an [Iterable]</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a [List] from an [Iterable]</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to [map], but also pass an index for each item iterated.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if at least one element of the iterable is found by using the specific function.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if all elements of the iterable have the specified property defined by [f].</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>Call the function 'f' on all elements of the [Iterable] 'it'.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Return the list of elements matching the function 'f'</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional 'fold' using an [Iterable]</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>Count the number of elements in an [Iterable] having [pred] returning true.</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an iterable does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a list containing all items of 'a' followed by all items of 'b'</haxe_doc>
		</concat>
		<haxe_doc>The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<map public="1" params="X" set="method" line="246">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted
		by the function [f].</haxe_doc>
		</map>
		<filter public="1" set="method" line="230">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].</haxe_doc>
		</filter>
		<join public="1" set="method" line="211">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Join the element of the list by using the separator [sep].</haxe_doc>
		</join>
		<toString public="1" set="method" line="191">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Makes the list empty.</haxe_doc>
		</clear>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" set="method" line="98">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<last public="1" set="method" line="88">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of the list, or null
		if the list is empty.</haxe_doc>
		</last>
		<first public="1" set="method" line="80">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Push an element at the beginning of the list.</haxe_doc>
		</push>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the end of the list.</haxe_doc>
		</add>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of elements in this list.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.</haxe_doc>
	</class>
	<class path="Main" params="" file="Main.hx"><main public="1" set="method" line="19" static="1"><f a=""><e path="Void"/></f></main></class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="51" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="59" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="63" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="86" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="90" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="96" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="100" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="115" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="121" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="48" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="52" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addSub public="1" get="inline" set="null" line="56">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="49">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<add public="1" get="inline" set="null" line="42">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="String"/></b>
		<new public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="89" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="93" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="117" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="134" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="155" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="168" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="180" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="186" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="203" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="207" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="214" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="219" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="251" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="268" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="272" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="276" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="280" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="box2D.collision.B2AABB" params="" file="../../lib/box2D/collision/B2AABB.hx">
		<upperBound public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>The upper vertex</haxe_doc>
		</upperBound>
		<lowerBound public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>The lower vertex</haxe_doc>
		</lowerBound>
		<combine public="1" set="method" line="207">
			<f a="aabb1:aabb2">
				<c path="box2D.collision.B2AABB"/>
				<c path="box2D.collision.B2AABB"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Combine two AABBs into one.</haxe_doc>
		</combine>
		<testOverlap public="1" set="method" line="182">
			<f a="other">
				<c path="box2D.collision.B2AABB"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Tests if another AABB overlaps this one.</haxe_doc>
		</testOverlap>
		<rayCast public="1" set="method" line="74">
			<f a="output:input">
				<c path="box2D.collision.B2RayCastOutput"/>
				<c path="box2D.collision.B2RayCastInput"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Perform a precise raycast against the AABB.</haxe_doc>
		</rayCast>
		<contains public="1" set="method" line="60">
			<f a="aabb">
				<c path="box2D.collision.B2AABB"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Is an AABB contained within this one.</haxe_doc>
		</contains>
		<getExtents public="1" set="method" line="51">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>Get the extents of the AABB (half-widths).</haxe_doc>
		</getExtents>
		<getCenter public="1" set="method" line="44">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>Get the center of the AABB.</haxe_doc>
		</getCenter>
		<isValid public="1" set="method" line="34">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Verify that the bounds are sorted.</haxe_doc>
		</isValid>
		<new public="1" set="method" line="215"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* An axis aligned bounding box.</haxe_doc>
	</class>
	<class path="box2D.common.math.B2Vec2" params="" file="../../lib/box2D/common/math/B2Vec2.hx">
		<make public="1" set="method" line="37" static="1"><f a="x_:y_">
	<c path="Float"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></make>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<isValid public="1" set="method" line="131"><f a=""><e path="Bool"/></f></isValid>
		<normalize public="1" set="method" line="117"><f a=""><c path="Float"/></f></normalize>
		<lengthSquared public="1" set="method" line="112"><f a=""><c path="Float"/></f></lengthSquared>
		<length public="1" set="method" line="107"><f a=""><c path="Float"/></f></length>
		<abs public="1" set="method" line="101"><f a=""><e path="Void"/></f></abs>
		<maxV public="1" set="method" line="95"><f a="b">
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></maxV>
		<minV public="1" set="method" line="89"><f a="b">
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></minV>
		<crossFV public="1" set="method" line="82"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></crossFV>
		<crossVF public="1" set="method" line="75"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></crossVF>
		<mulTM public="1" set="method" line="68"><f a="A">
	<c path="box2D.common.math.B2Mat22"/>
	<e path="Void"/>
</f></mulTM>
		<mulM public="1" set="method" line="61"><f a="A">
	<c path="box2D.common.math.B2Mat22"/>
	<e path="Void"/>
</f></mulM>
		<multiply public="1" set="method" line="56"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></multiply>
		<subtract public="1" set="method" line="51"><f a="v">
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></subtract>
		<add public="1" set="method" line="46"><f a="v">
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></add>
		<copy public="1" set="method" line="42"><f a=""><c path="box2D.common.math.B2Vec2"/></f></copy>
		<negativeSelf public="1" set="method" line="35"><f a=""><e path="Void"/></f></negativeSelf>
		<getNegative public="1" set="method" line="34"><f a=""><c path="box2D.common.math.B2Vec2"/></f></getNegative>
		<setV public="1" set="method" line="32"><f a="v">
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></setV>
		<set public="1" set="method" line="31"><f a="?x_:?y_">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<setZero public="1" set="method" line="30"><f a=""><e path="Void"/></f></setZero>
		<new public="1" set="method" line="28"><f a="?x_:?y_">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* A 2D column vector.</haxe_doc>
	</class>
	<class path="box2D.collision.ClipVertex" params="" file="../../lib/box2D/collision/ClipVertex.hx">
		<id public="1"><c path="box2D.collision.B2ContactID"/></id>
		<v public="1"><c path="box2D.common.math.B2Vec2"/></v>
		<set public="1" set="method" line="39"><f a="other">
	<c path="box2D.collision.ClipVertex"/>
	<e path="Void"/>
</f></set>
		<new public="1" set="method" line="32"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.collision.B2ContactID" params="" file="../../lib/box2D/collision/B2ContactID.hx">
		<_key public="1">
			<c path="Int"/>
			<haxe_doc>Used to quickly compare contact ids.</haxe_doc>
		</_key>
		<features public="1"><c path="box2D.collision.Features"/></features>
		<setKey set="method" line="46"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setKey>
		<getKey set="method" line="43"><f a=""><c path="Int"/></f></getKey>
		<key public="1" get="getKey" set="setKey"><c path="Int"/></key>
		<copy public="1" set="method" line="35"><f a=""><c path="box2D.collision.B2ContactID"/></f></copy>
		<set public="1" set="method" line="32"><f a="id">
	<c path="box2D.collision.B2ContactID"/>
	<e path="Void"/>
</f></set>
		<new public="1" set="method" line="28"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* We use contact ids to facilitate warm starting.</haxe_doc>
	</class>
	<class path="box2D.collision.Features" params="" file="../../lib/box2D/collision/Features.hx">
		<_m_id public="1"><c path="box2D.collision.B2ContactID"/></_m_id>
		<_flip public="1"><c path="Int"/></_flip>
		<setFlip set="method" line="87"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setFlip>
		<getFlip set="method" line="84"><f a=""><c path="Int"/></f></getFlip>
		<flip public="1" get="getFlip" set="setFlip">
			<c path="Int"/>
			<haxe_doc>* A value of 1 indicates that the reference edge is on shape2.</haxe_doc>
		</flip>
		<_incidentVertex public="1"><c path="Int"/></_incidentVertex>
		<setIncidentVertex set="method" line="72"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setIncidentVertex>
		<getIncidentVertex set="method" line="69"><f a=""><c path="Int"/></f></getIncidentVertex>
		<incidentVertex public="1" get="getIncidentVertex" set="setIncidentVertex">
			<c path="Int"/>
			<haxe_doc>* The vertex (0 or 1) on the incident edge that was clipped.</haxe_doc>
		</incidentVertex>
		<_incidentEdge public="1"><c path="Int"/></_incidentEdge>
		<setIncidentEdge set="method" line="57"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setIncidentEdge>
		<getIncidentEdge set="method" line="54"><f a=""><c path="Int"/></f></getIncidentEdge>
		<incidentEdge public="1" get="getIncidentEdge" set="setIncidentEdge">
			<c path="Int"/>
			<haxe_doc>* The edge most anti-parallel to the reference edge.</haxe_doc>
		</incidentEdge>
		<_referenceEdge public="1"><c path="Int"/></_referenceEdge>
		<setReferenceEdge set="method" line="42"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setReferenceEdge>
		<getReferenceEdge set="method" line="39"><f a=""><c path="Int"/></f></getReferenceEdge>
		<referenceEdge public="1" get="getReferenceEdge" set="setReferenceEdge">
			<c path="Int"/>
			<haxe_doc>* The edge that defines the outward contact normal.</haxe_doc>
		</referenceEdge>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* We use contact ids to facilitate warm starting.</haxe_doc>
	</class>
	<class path="box2D.collision.B2Collision" params="" file="../../lib/box2D/collision/B2Collision.hx">
		<b2_nullFeature public="1" line="37" static="1"><c path="Int"/></b2_nullFeature>
		<clipSegmentToLine public="1" set="method" line="40" static="1"><f a="vOut:vIn:normal:offset">
	<c path="Array"><c path="box2D.collision.ClipVertex"/></c>
	<c path="Array"><c path="box2D.collision.ClipVertex"/></c>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<c path="Int"/>
</f></clipSegmentToLine>
		<edgeSeparation public="1" set="method" line="91" static="1"><f a="poly1:xf1:edge1:poly2:xf2">
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="Int"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="Float"/>
</f></edgeSeparation>
		<findMaxSeparation public="1" set="method" line="156" static="1"><f a="edgeIndex:poly1:xf1:poly2:xf2">
	<c path="Array"><c path="Int"/></c>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="Float"/>
</f></findMaxSeparation>
		<findIncidentEdge public="1" set="method" line="259" static="1"><f a="c:poly1:xf1:edge1:poly2:xf2">
	<c path="Array"><c path="box2D.collision.ClipVertex"/></c>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="Int"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></findIncidentEdge>
		<makeClipPointVector set="method" line="330" static="1"><f a=""><c path="Array"><c path="box2D.collision.ClipVertex"/></c></f></makeClipPointVector>
		<s_incidentEdge line="337" static="1"><c path="Array"><c path="box2D.collision.ClipVertex"/></c></s_incidentEdge>
		<s_clipPoints1 line="338" static="1"><c path="Array"><c path="box2D.collision.ClipVertex"/></c></s_clipPoints1>
		<s_clipPoints2 line="339" static="1"><c path="Array"><c path="box2D.collision.ClipVertex"/></c></s_clipPoints2>
		<s_edgeAO line="340" static="1"><c path="Array"><c path="Int"/></c></s_edgeAO>
		<s_edgeBO line="341" static="1"><c path="Array"><c path="Int"/></c></s_edgeBO>
		<s_localTangent line="342" static="1"><c path="box2D.common.math.B2Vec2"/></s_localTangent>
		<s_localNormal line="343" static="1"><c path="box2D.common.math.B2Vec2"/></s_localNormal>
		<s_planePoint line="344" static="1"><c path="box2D.common.math.B2Vec2"/></s_planePoint>
		<s_normal line="345" static="1"><c path="box2D.common.math.B2Vec2"/></s_normal>
		<s_tangent line="346" static="1"><c path="box2D.common.math.B2Vec2"/></s_tangent>
		<s_tangent2 line="347" static="1"><c path="box2D.common.math.B2Vec2"/></s_tangent2>
		<s_v11 line="348" static="1"><c path="box2D.common.math.B2Vec2"/></s_v11>
		<s_v12 line="349" static="1"><c path="box2D.common.math.B2Vec2"/></s_v12>
		<b2CollidePolyTempVec line="355" static="1"><c path="box2D.common.math.B2Vec2"/></b2CollidePolyTempVec>
		<collidePolygons public="1" set="method" line="357" static="1"><f a="manifold:polyA:xfA:polyB:xfB">
	<c path="box2D.collision.B2Manifold"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></collidePolygons>
		<collideCircles public="1" set="method" line="510" static="1"><f a="manifold:circle1:xf1:circle2:xf2">
	<c path="box2D.collision.B2Manifold"/>
	<c path="box2D.collision.shapes.B2CircleShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.shapes.B2CircleShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></collideCircles>
		<collidePolygonAndCircle public="1" set="method" line="548" static="1"><f a="manifold:polygon:xf1:circle:xf2">
	<c path="box2D.collision.B2Manifold"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.shapes.B2CircleShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></collidePolygonAndCircle>
		<testOverlap public="1" set="method" line="678" static="1"><f a="a:b">
	<c path="box2D.collision.B2AABB"/>
	<c path="box2D.collision.B2AABB"/>
	<e path="Bool"/>
</f></testOverlap>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.collision.B2ContactPoint" params="" file="../../lib/box2D/collision/B2ContactPoint.hx">
		<id public="1">
			<c path="box2D.collision.B2ContactID"/>
			<haxe_doc>The contact id identifies the features in contact</haxe_doc>
		</id>
		<restitution public="1">
			<c path="Float"/>
			<haxe_doc>The combined restitution coefficient</haxe_doc>
		</restitution>
		<friction public="1">
			<c path="Float"/>
			<haxe_doc>The combined friction coefficient</haxe_doc>
		</friction>
		<separation public="1">
			<c path="Float"/>
			<haxe_doc>The separation is negative when shapes are touching</haxe_doc>
		</separation>
		<normal public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Points from shape1 to shape2</haxe_doc>
		</normal>
		<velocity public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Velocity of point on body2 relative to point on body1 (pre-solver)</haxe_doc>
		</velocity>
		<position public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Position in world coordinates</haxe_doc>
		</position>
		<shape2 public="1">
			<c path="box2D.collision.shapes.B2Shape"/>
			<haxe_doc>The second shape</haxe_doc>
		</shape2>
		<shape1 public="1">
			<c path="box2D.collision.shapes.B2Shape"/>
			<haxe_doc>The first shape</haxe_doc>
		</shape1>
		<new public="1" set="method" line="32"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* This structure is used to report contact points.</haxe_doc>
	</class>
	<class path="box2D.collision.B2Simplex" params="" file="../../lib/box2D/collision/B2Simplex.hx">
		<m_count public="1"><c path="Int"/></m_count>
		<m_vertices public="1"><c path="Array"><c path="box2D.collision.B2SimplexVertex"/></c></m_vertices>
		<m_v3 public="1"><c path="box2D.collision.B2SimplexVertex"/></m_v3>
		<m_v2 public="1"><c path="box2D.collision.B2SimplexVertex"/></m_v2>
		<m_v1 public="1"><c path="box2D.collision.B2SimplexVertex"/></m_v1>
		<solve3 public="1" set="method" line="261"><f a=""><e path="Void"/></f></solve3>
		<solve2 public="1" set="method" line="227"><f a=""><e path="Void"/></f></solve2>
		<getMetric public="1" set="method" line="181"><f a=""><c path="Float"/></f></getMetric>
		<getWitnessPoints public="1" set="method" line="154"><f a="pA:pB">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></getWitnessPoints>
		<getClosestPoint public="1" set="method" line="135"><f a=""><c path="box2D.common.math.B2Vec2"/></f></getClosestPoint>
		<getSearchDirection public="1" set="method" line="109"><f a=""><c path="box2D.common.math.B2Vec2"/></f></getSearchDirection>
		<writeCache public="1" set="method" line="97"><f a="cache">
	<c path="box2D.collision.B2SimplexCache"/>
	<e path="Void"/>
</f></writeCache>
		<readCache public="1" set="method" line="43"><f a="cache:proxyA:transformA:proxyB:transformB">
	<c path="box2D.collision.B2SimplexCache"/>
	<c path="box2D.collision.B2DistanceProxy"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.B2DistanceProxy"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></readCache>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="box2D.collision.B2SimplexVertex" params="" file="../../lib/box2D/collision/B2SimplexVertex.hx">
		<indexB public="1"><c path="Int"/></indexB>
		<indexA public="1"><c path="Int"/></indexA>
		<a public="1"><c path="Float"/></a>
		<w public="1"><c path="box2D.common.math.B2Vec2"/></w>
		<wB public="1"><c path="box2D.common.math.B2Vec2"/></wB>
		<wA public="1"><c path="box2D.common.math.B2Vec2"/></wA>
		<set public="1" set="method" line="28"><f a="other">
	<c path="box2D.collision.B2SimplexVertex"/>
	<e path="Void"/>
</f></set>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="box2D.collision.B2Distance" params="" file="../../lib/box2D/collision/B2Distance.hx">
		<b2_gjkCalls static="1"><c path="Int"/></b2_gjkCalls>
		<b2_gjkIters static="1"><c path="Int"/></b2_gjkIters>
		<b2_gjkMaxIters static="1"><c path="Int"/></b2_gjkMaxIters>
		<s_simplex line="41" static="1"><c path="box2D.collision.B2Simplex"/></s_simplex>
		<s_saveA line="42" static="1"><c path="Array"><c path="Int"/></c></s_saveA>
		<s_saveB line="43" static="1"><c path="Array"><c path="Int"/></c></s_saveB>
		<distance public="1" set="method" line="44" static="1"><f a="output:cache:input">
	<c path="box2D.collision.B2DistanceOutput"/>
	<c path="box2D.collision.B2SimplexCache"/>
	<c path="box2D.collision.B2DistanceInput"/>
	<e path="Void"/>
</f></distance>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.collision.B2DistanceInput" params="" file="../../lib/box2D/collision/B2DistanceInput.hx">
		<useRadii public="1"><e path="Bool"/></useRadii>
		<transformB public="1"><c path="box2D.common.math.B2Transform"/></transformB>
		<transformA public="1"><c path="box2D.common.math.B2Transform"/></transformA>
		<proxyB public="1"><c path="box2D.collision.B2DistanceProxy"/></proxyB>
		<proxyA public="1"><c path="box2D.collision.B2DistanceProxy"/></proxyA>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Input for b2Distance.
 * You have to option to use the shape radii
 * in the computation. Even</haxe_doc>
	</class>
	<class path="box2D.collision.B2DistanceOutput" params="" file="../../lib/box2D/collision/B2DistanceOutput.hx">
		<iterations public="1">
			<c path="Int"/>
			<haxe_doc>Number of gjk iterations used</haxe_doc>
		</iterations>
		<distance public="1"><c path="Float"/></distance>
		<pointB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Closest point on shapeb</haxe_doc>
		</pointB>
		<pointA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Closest point on shapea</haxe_doc>
		</pointA>
		<new public="1" set="method" line="28"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Output for b2Distance.</haxe_doc>
	</class>
	<class path="box2D.collision.B2DistanceProxy" params="" file="../../lib/box2D/collision/B2DistanceProxy.hx">
		<m_radius public="1"><c path="Float"/></m_radius>
		<m_count public="1"><c path="Int"/></m_count>
		<m_vertices public="1"><c path="Array"><c path="box2D.common.math.B2Vec2"/></c></m_vertices>
		<getVertex public="1" set="method" line="113">
			<f a="index">
				<c path="Int"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get a vertex by index. Used by b2Distance.</haxe_doc>
		</getVertex>
		<getVertexCount public="1" set="method" line="105">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the vertex count.</haxe_doc>
		</getVertexCount>
		<getSupportVertex public="1" set="method" line="87">
			<f a="d">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get the supporting vertex in the given direction.</haxe_doc>
		</getSupportVertex>
		<getSupport public="1" set="method" line="68">
			<f a="d">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Get the supporting vertex index in the given direction.</haxe_doc>
		</getSupport>
		<set public="1" set="method" line="39">
			<f a="shape">
				<c path="box2D.collision.shapes.B2Shape"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Initialize the proxy using the given shape. The shape
	 * must remain in scope while the proxy is in use.</haxe_doc>
		</set>
		<new public="1" set="method" line="120"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* A distance proxy is used by the GJK algorithm.
 * It encapsulates any shape.</haxe_doc>
	</class>
	<class path="box2D.collision.B2DynamicTree" params="" file="../../lib/box2D/collision/B2DynamicTree.hx">
		<m_insertionCount><c path="Int"/></m_insertionCount>
		<m_path>
			<c path="Int"/>
			<haxe_doc>This is used for incrementally traverse the tree for rebalancing</haxe_doc>
		</m_path>
		<m_freeList><c path="box2D.collision.B2DynamicTreeNode"/></m_freeList>
		<m_root><c path="box2D.collision.B2DynamicTreeNode"/></m_root>
		<removeLeaf set="method" line="414"><f a="leaf">
	<c path="box2D.collision.B2DynamicTreeNode"/>
	<e path="Void"/>
</f></removeLeaf>
		<insertLeaf set="method" line="331"><f a="leaf">
	<c path="box2D.collision.B2DynamicTreeNode"/>
	<e path="Void"/>
</f></insertLeaf>
		<freeNode set="method" line="325"><f a="node">
	<c path="box2D.collision.B2DynamicTreeNode"/>
	<e path="Void"/>
</f></freeNode>
		<allocateNode set="method" line="307"><f a=""><c path="box2D.collision.B2DynamicTreeNode"/></f></allocateNode>
		<rayCast public="1" set="method" line="221">
			<f a="callbackMethod:input">
				<f a=":">
					<c path="box2D.collision.B2RayCastInput"/>
					<d/>
					<d/>
				</f>
				<c path="box2D.collision.B2RayCastInput"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Ray-cast against the proxies in the tree. This relies on the callback
	 * to perform a exact ray-cast in the case were the proxy contains a shape.
	 * The callback also performs the any collision filtering. This has performance
	 * roughly equal to k * log(n), where k is the number of collisions and n is the
	 * number of proxies in the tree.
	 * @param input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
	 * @param callback a callback class that is called for each proxy that is hit by the ray.
	 * It should be of signature:
	 * <code>function callback(input:B2RayCastInput, proxy:*):Void</code>]]></haxe_doc>
		</rayCast>
		<query public="1" set="method" line="178">
			<f a="callbackMethod:aabb">
				<f a="">
					<c path="box2D.collision.B2DynamicTreeNode"/>
					<e path="Bool"/>
				</f>
				<c path="box2D.collision.B2AABB"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Query an AABB for overlapping proxies. The callback
	 * is called for each proxy that overlaps the supplied AABB.
	 * The callback should match function signature
	 * <code>fuction callback(proxy:B2DynamicTreeNode):Bool</code>
	 * and should return false to trigger premature termination.]]></haxe_doc>
		</query>
		<getUserData public="1" set="method" line="166">
			<f a="proxy">
				<c path="box2D.collision.B2DynamicTreeNode"/>
				<d/>
			</f>
			<haxe_doc>* Get user data from a proxy. Returns null if the proxy is invalid.</haxe_doc>
		</getUserData>
		<getFatAABB public="1" set="method" line="158"><f a="proxy">
	<c path="box2D.collision.B2DynamicTreeNode"/>
	<c path="box2D.collision.B2AABB"/>
</f></getFatAABB>
		<rebalance public="1" set="method" line="137">
			<f a="iterations">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Perform some iterations to re-balance the tree.</haxe_doc>
		</rebalance>
		<moveProxy public="1" set="method" line="111">
			<f a="proxy:aabb:displacement">
				<c path="box2D.collision.B2DynamicTreeNode"/>
				<c path="box2D.collision.B2AABB"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Move a proxy with a swept AABB. If the proxy has moved outside of its fattened AABB,
	 * then the proxy is removed from the tree and re-inserted. Otherwise
	 * the function returns immediately.</haxe_doc>
		</moveProxy>
		<destroyProxy public="1" set="method" line="99">
			<f a="proxy">
				<c path="box2D.collision.B2DynamicTreeNode"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Destroy a proxy. This asserts if the id is invalid.</haxe_doc>
		</destroyProxy>
		<createProxy public="1" set="method" line="78">
			<f a="aabb:userData">
				<c path="box2D.collision.B2AABB"/>
				<d/>
				<c path="box2D.collision.B2DynamicTreeNode"/>
			</f>
			<haxe_doc>* Create a proxy. Provide a tight fitting AABB and a userData.</haxe_doc>
		</createProxy>
		<new public="1" set="method" line="42">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Constructing the tree initializes the node pool.</haxe_doc>
		</new>
		<haxe_doc>* A dynamic tree arranges data in a binary tree to accelerate
 * queries such as volume queries and ray casts. Leafs are proxies
 * with an AABB. In the tree we expand the proxy AABB by b2_fatAABBFactor
 * so that the proxy AABB is bigger than the client object. This allows the client
 * object to move by small amounts without triggering a tree update.
 * 
 * Nodes are pooled.</haxe_doc>
	</class>
	<class path="box2D.collision.IBroadPhase" params="" file="../../lib/box2D/collision/IBroadPhase.hx" interface="1">
		<rebalance public="1" set="method">
			<f a="iterations">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Give the broadphase a chance for structural optimizations</haxe_doc>
		</rebalance>
		<validate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* For debugging, throws in invariants have been broken</haxe_doc>
		</validate>
		<rayCast public="1" set="method">
			<f a="callbackMethod:input">
				<f a=":">
					<c path="box2D.collision.B2RayCastInput"/>
					<d/>
					<c path="Float"/>
				</f>
				<c path="box2D.collision.B2RayCastInput"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Ray-cast  agains the proxies in the tree. This relies on the callback
	 * to perform exact ray-cast in the case where the proxy contains a shape
	 * The callback also performs any collision filtering
	 * @param callback This function should be a function matching signature
	 * <code>function Callback(subInput:B2RayCastInput, proxy:*):Float</code>
	 * Where the returned number is the new value for maxFraction]]></haxe_doc>
		</rayCast>
		<query public="1" set="method">
			<f a="callbackMethod:aabb">
				<f a="">
					<d/>
					<e path="Bool"/>
				</f>
				<c path="box2D.collision.B2AABB"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Query an AABB for overlapping proxies. The callback class
	 * is called with each proxy that overlaps 
	 * the supplied AABB, and return a Boolean indicating if 
	 * the broaphase should proceed to the next match.
	 * @param callback This function should be a function matching signature
	 * <code>function Callback(proxy:*):Bool</code>]]></haxe_doc>
		</query>
		<updatePairs public="1" set="method">
			<f a="callbackMethod">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Update the pairs. This results in pair callbacks. This can only add pairs.</haxe_doc>
		</updatePairs>
		<getProxyCount public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the number of proxies.</haxe_doc>
		</getProxyCount>
		<getFatAABB public="1" set="method">
			<f a="proxy">
				<d/>
				<c path="box2D.collision.B2AABB"/>
			</f>
			<haxe_doc>* Get the fat AABB for a proxy.</haxe_doc>
		</getFatAABB>
		<getUserData public="1" set="method">
			<f a="proxy">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Get user data from a proxy. Returns null if the proxy is invalid.</haxe_doc>
		</getUserData>
		<testOverlap public="1" set="method"><f a="proxyA:proxyB">
	<d/>
	<d/>
	<e path="Bool"/>
</f></testOverlap>
		<moveProxy public="1" set="method">
			<f a="proxy:aabb:displacement">
				<d/>
				<c path="box2D.collision.B2AABB"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Call MoveProxy as many times as you like, then when you are done
	 * call UpdatePairs to finalized the proxy pairs (for your time step).</haxe_doc>
		</moveProxy>
		<destroyProxy public="1" set="method">
			<f a="proxy">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Destroy a proxy. It is up to the client to remove any pairs.</haxe_doc>
		</destroyProxy>
		<createProxy public="1" set="method">
			<f a="aabb:userData">
				<c path="box2D.collision.B2AABB"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Create a proxy with an initial AABB. Pairs are not reported until
	 * UpdatePairs is called.</haxe_doc>
		</createProxy>
		<haxe_doc>* Interface for objects tracking overlap of many AABBs.</haxe_doc>
	</class>
	<class path="box2D.collision.B2DynamicTreeBroadPhase" params="" file="../../lib/box2D/collision/B2DynamicTreeBroadPhase.hx">
		<implements path="box2D.collision.IBroadPhase"/>
		<m_pairCount><c path="Int"/></m_pairCount>
		<m_pairBuffer><c path="Array"><c path="box2D.collision.B2DynamicTreePair"/></c></m_pairBuffer>
		<m_moveBuffer><c path="Array"><c path="box2D.collision.B2DynamicTreeNode"/></c></m_moveBuffer>
		<m_proxyCount><c path="Int"/></m_proxyCount>
		<m_tree><c path="box2D.collision.B2DynamicTree"/></m_tree>
		<comparePairs set="method" line="207"><f a="pair1:pair2">
	<c path="box2D.collision.B2DynamicTreePair"/>
	<c path="box2D.collision.B2DynamicTreePair"/>
	<c path="Int"/>
</f></comparePairs>
		<unBufferMove set="method" line="202"><f a="proxy">
	<c path="box2D.collision.B2DynamicTreeNode"/>
	<e path="Void"/>
</f></unBufferMove>
		<bufferMove set="method" line="197"><f a="proxy">
	<c path="box2D.collision.B2DynamicTreeNode"/>
	<e path="Void"/>
</f></bufferMove>
		<rebalance public="1" set="method" line="189"><f a="iterations">
	<c path="Int"/>
	<e path="Void"/>
</f></rebalance>
		<validate public="1" set="method" line="184"><f a=""><e path="Void"/></f></validate>
		<rayCast public="1" set="method" line="178">
			<f a="callbackMethod:input">
				<f a=":">
					<c path="box2D.collision.B2RayCastInput"/>
					<d/>
					<c path="Float"/>
				</f>
				<c path="box2D.collision.B2RayCastInput"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</rayCast>
		<query public="1" set="method" line="170">
			<f a="callbackMethod:aabb">
				<f a="">
					<d/>
					<e path="Bool"/>
				</f>
				<c path="box2D.collision.B2AABB"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</query>
		<updatePairs public="1" set="method" line="83">
			<f a="callbackMethod">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Update the pairs. This results in pair callbacks. This can only add pairs.</haxe_doc>
		</updatePairs>
		<getProxyCount public="1" set="method" line="75">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the number of proxies.</haxe_doc>
		</getProxyCount>
		<getFatAABB public="1" set="method" line="67">
			<f a="proxy">
				<d/>
				<c path="box2D.collision.B2AABB"/>
			</f>
			<haxe_doc>* Get the AABB for a proxy.</haxe_doc>
		</getFatAABB>
		<getUserData public="1" set="method" line="59">
			<f a="proxy">
				<d/>
				<d/>
			</f>
			<haxe_doc>* Get user data from a proxy. Returns null if the proxy is invalid.</haxe_doc>
		</getUserData>
		<testOverlap public="1" set="method" line="49"><f a="proxyA:proxyB">
	<d/>
	<d/>
	<e path="Bool"/>
</f></testOverlap>
		<moveProxy public="1" set="method" line="40">
			<f a="proxy:aabb:displacement">
				<d/>
				<c path="box2D.collision.B2AABB"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Call MoveProxy as many times as you like, then when you are done
	 * call UpdatePairs to finalized the proxy pairs (for your time step).</haxe_doc>
		</moveProxy>
		<destroyProxy public="1" set="method" line="29">
			<f a="proxy">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Destroy a proxy. It is up to the client to remove any pairs.</haxe_doc>
		</destroyProxy>
		<createProxy public="1" set="method" line="18">
			<f a="aabb:userData">
				<c path="box2D.collision.B2AABB"/>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Create a proxy with an initial AABB. Pairs are not reported until
	 * UpdatePairs is called.</haxe_doc>
		</createProxy>
		<new public="1" set="method" line="215"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* The broad-phase is used for computing pairs and performing volume queries and ray casts.
 * This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
 * It is up to the client to consume the new pairs and to track subsequent overlap.</haxe_doc>
	</class>
	<class path="box2D.collision.B2DynamicTreeNode" params="" file="../../lib/box2D/collision/B2DynamicTreeNode.hx">
		<currentID line="30" static="1"><c path="Int"/></currentID>
		<child2 public="1"><c path="box2D.collision.B2DynamicTreeNode"/></child2>
		<child1 public="1"><c path="box2D.collision.B2DynamicTreeNode"/></child1>
		<parent public="1"><c path="box2D.collision.B2DynamicTreeNode"/></parent>
		<aabb public="1"><c path="box2D.collision.B2AABB"/></aabb>
		<userData public="1"><d/></userData>
		<isLeaf public="1" set="method" line="37"><f a=""><e path="Bool"/></f></isLeaf>
		<id public="1"><c path="Int"/></id>
		<new public="1" set="method" line="32"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* A node in the dynamic tree. The client does not interact with this directly.
 * @private</haxe_doc>
	</class>
	<class path="box2D.collision.B2DynamicTreePair" params="" file="../../lib/box2D/collision/B2DynamicTreePair.hx">
		<proxyB public="1"><c path="box2D.collision.B2DynamicTreeNode"/></proxyB>
		<proxyA public="1"><c path="box2D.collision.B2DynamicTreeNode"/></proxyA>
		<new public="1" set="method" line="8"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.collision.B2Manifold" params="" file="../../lib/box2D/collision/B2Manifold.hx">
		<e_circles public="1" line="90" static="1"><c path="Int"/></e_circles>
		<e_faceA public="1" line="91" static="1"><c path="Int"/></e_faceA>
		<e_faceB public="1" line="92" static="1"><c path="Int"/></e_faceB>
		<m_pointCount public="1">
			<c path="Int"/>
			<haxe_doc>The number of manifold points</haxe_doc>
		</m_pointCount>
		<m_type public="1"><c path="Int"/></m_type>
		<m_localPoint public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Usage depends on manifold type</haxe_doc>
		</m_localPoint>
		<m_localPlaneNormal public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Not used for Type e_points</haxe_doc>
		</m_localPlaneNormal>
		<m_points public="1">
			<c path="Array"><c path="box2D.collision.B2ManifoldPoint"/></c>
			<haxe_doc>The points of contact</haxe_doc>
		</m_points>
		<copy public="1" set="method" line="73"><f a=""><c path="box2D.collision.B2Manifold"/></f></copy>
		<set public="1" set="method" line="64"><f a="m">
	<c path="box2D.collision.B2Manifold"/>
	<e path="Void"/>
</f></set>
		<reset public="1" set="method" line="55"><f a=""><e path="Void"/></f></reset>
		<new public="1" set="method" line="46"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* A manifold for two touching convex shapes.
 * Box2D supports multiple types of contact:
 * - clip point versus plane with radius
 * - point versus point with radius (circles)
 * The local point usage depends on the manifold type:
 * -e_circles: the local center of circleA
 * -e_faceA: the center of faceA
 * -e_faceB: the center of faceB
 * Similarly the local normal usage:
 * -e_circles: not used
 * -e_faceA: the normal on polygonA
 * -e_faceB: the normal on polygonB
 * We store contacts in this way so that position correction can
 * account for movement, which is critical for continuous physics.
 * All contact scenarios must be expressed in one of these types.
 * This structure is stored across time steps, so we keep it small.</haxe_doc>
	</class>
	<class path="box2D.collision.B2ManifoldPoint" params="" file="../../lib/box2D/collision/B2ManifoldPoint.hx">
		<m_id public="1"><c path="box2D.collision.B2ContactID"/></m_id>
		<m_tangentImpulse public="1"><c path="Float"/></m_tangentImpulse>
		<m_normalImpulse public="1"><c path="Float"/></m_normalImpulse>
		<m_localPoint public="1"><c path="box2D.common.math.B2Vec2"/></m_localPoint>
		<set public="1" set="method" line="51"><f a="m">
	<c path="box2D.collision.B2ManifoldPoint"/>
	<e path="Void"/>
</f></set>
		<reset public="1" set="method" line="45"><f a=""><e path="Void"/></f></reset>
		<new public="1" set="method" line="39"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* A manifold point is a contact point belonging to a contact
 * manifold. It holds details related to the geometry and dynamics
 * of the contact points.
 * The local point usage depends on the manifold type:
 * -e_circles: the local center of circleB
 * -e_faceA: the local center of cirlceB or the clip point of polygonB
 * -e_faceB: the clip point of polygonA
 * This structure is stored across time steps, so we keep it small.
 * Note: the impulses are used for internal caching and may not
 * provide reliable contact forces, especially for high speed collisions.</haxe_doc>
	</class>
	<class path="box2D.collision.B2OBB" params="" file="../../lib/box2D/collision/B2OBB.hx">
		<extents public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>The half-widths</haxe_doc>
		</extents>
		<center public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>The local centroid</haxe_doc>
		</center>
		<R public="1">
			<c path="box2D.common.math.B2Mat22"/>
			<haxe_doc>The rotation matrix</haxe_doc>
		</R>
		<new public="1" set="method" line="32"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* An oriented bounding box.</haxe_doc>
	</class>
	<class path="box2D.collision.B2RayCastInput" params="" file="../../lib/box2D/collision/B2RayCastInput.hx">
		<maxFraction public="1">
			<c path="Float"/>
			<haxe_doc>* Truncate the ray to reach up to this fraction from p1 to p2</haxe_doc>
		</maxFraction>
		<p2 public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The end point of the ray</haxe_doc>
		</p2>
		<p1 public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The start point of the ray</haxe_doc>
		</p1>
		<new public="1" set="method" line="28"><f a="?p1:?p2:?maxFraction">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Specifies a segment for use with RayCast functions.</haxe_doc>
	</class>
	<class path="box2D.collision.B2RayCastOutput" params="" file="../../lib/box2D/collision/B2RayCastOutput.hx">
		<fraction public="1">
			<c path="Float"/>
			<haxe_doc>* The fraction between p1 and p2 that the collision occurs at</haxe_doc>
		</fraction>
		<normal public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The normal at the point of collision</haxe_doc>
		</normal>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Returns data on the collision between a ray and a shape.</haxe_doc>
	</class>
	<class path="box2D.collision.B2SeparationFunction" params="" file="../../lib/box2D/collision/B2SeparationFunction.hx">
		<e_points public="1" line="32" static="1"><c path="Int"/></e_points>
		<e_faceA public="1" line="33" static="1"><c path="Int"/></e_faceA>
		<e_faceB public="1" line="34" static="1"><c path="Int"/></e_faceB>
		<m_axis public="1"><c path="box2D.common.math.B2Vec2"/></m_axis>
		<m_localPoint public="1"><c path="box2D.common.math.B2Vec2"/></m_localPoint>
		<m_type public="1"><c path="Int"/></m_type>
		<m_proxyB public="1"><c path="box2D.collision.B2DistanceProxy"/></m_proxyB>
		<m_proxyA public="1"><c path="box2D.collision.B2DistanceProxy"/></m_proxyA>
		<evaluate public="1" set="method" line="261"><f a="transformA:transformB">
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="Float"/>
</f></evaluate>
		<initialize public="1" set="method" line="36"><f a="cache:proxyA:transformA:proxyB:transformB">
	<c path="box2D.collision.B2SimplexCache"/>
	<c path="box2D.collision.B2DistanceProxy"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.B2DistanceProxy"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></initialize>
		<new public="1" set="method" line="320"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="box2D.collision.B2SimplexCache" params="" file="../../lib/box2D/collision/B2SimplexCache.hx">
		<indexB public="1">
			<c path="Array"><c path="Int"/></c>
			<haxe_doc>Vertices on shape b</haxe_doc>
		</indexB>
		<indexA public="1">
			<c path="Array"><c path="Int"/></c>
			<haxe_doc>Vertices on shape a</haxe_doc>
		</indexA>
		<count public="1"><c path="Int"/></count>
		<metric public="1">
			<c path="Float"/>
			<haxe_doc>Length or area</haxe_doc>
		</metric>
		<new public="1" set="method" line="28"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Used to warm start b2Distance.
	 * Set count to zero on first call.</haxe_doc>
	</class>
	<class path="box2D.collision.B2TOIInput" params="" file="../../lib/box2D/collision/B2TOIInput.hx">
		<tolerance public="1"><c path="Float"/></tolerance>
		<sweepB public="1"><c path="box2D.common.math.B2Sweep"/></sweepB>
		<sweepA public="1"><c path="box2D.common.math.B2Sweep"/></sweepA>
		<proxyB public="1"><c path="box2D.collision.B2DistanceProxy"/></proxyB>
		<proxyA public="1"><c path="box2D.collision.B2DistanceProxy"/></proxyA>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Inpute parameters for b2TimeOfImpact</haxe_doc>
	</class>
	<class path="box2D.common.math.B2Transform" params="" file="../../lib/box2D/common/math/B2Transform.hx">
		<R public="1"><c path="box2D.common.math.B2Mat22"/></R>
		<position public="1"><c path="box2D.common.math.B2Vec2"/></position>
		<getAngle public="1" set="method" line="75">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Calculate the angle that the rotation matrix represents.</haxe_doc>
		</getAngle>
		<set public="1" set="method" line="64"><f a="x">
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></set>
		<setIdentity public="1" set="method" line="58">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Set this to the identity transform.</haxe_doc>
		</setIdentity>
		<initialize public="1" set="method" line="49">
			<f a="pos:r">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Mat22"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Initialize using a position vector and a rotation matrix.</haxe_doc>
		</initialize>
		<new public="1" set="method" line="31">
			<f a="?pos:?r">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Mat22"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* The default constructor does nothing (for performance).</haxe_doc>
		</new>
		<haxe_doc>* A transform contains translation and rotation. It is used to represent
* the position and orientation of rigid frames.</haxe_doc>
	</class>
	<class path="box2D.common.math.B2Mat22" params="" file="../../lib/box2D/common/math/B2Mat22.hx">
		<fromAngle public="1" set="method" line="33" static="1"><f a="angle">
	<c path="Float"/>
	<c path="box2D.common.math.B2Mat22"/>
</f></fromAngle>
		<fromVV public="1" set="method" line="40" static="1"><f a="c1:c2">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Mat22"/>
</f></fromVV>
		<col2 public="1"><c path="box2D.common.math.B2Vec2"/></col2>
		<col1 public="1"><c path="box2D.common.math.B2Vec2"/></col1>
		<abs public="1" set="method" line="138"><f a=""><e path="Void"/></f></abs>
		<solve public="1" set="method" line="119"><f a="out:bX:bY">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></solve>
		<getInverse public="1" set="method" line="101">
			<f a="out">
				<c path="box2D.common.math.B2Mat22"/>
				<c path="box2D.common.math.B2Mat22"/>
			</f>
			<haxe_doc>* Compute the inverse of this matrix, such that inv(A) * A = identity.</haxe_doc>
		</getInverse>
		<getAngle public="1" set="method" line="93"><f a=""><c path="Float"/></f></getAngle>
		<setZero public="1" set="method" line="87"><f a=""><e path="Void"/></f></setZero>
		<setIdentity public="1" set="method" line="81"><f a=""><e path="Void"/></f></setIdentity>
		<addM public="1" set="method" line="73"><f a="m">
	<c path="box2D.common.math.B2Mat22"/>
	<e path="Void"/>
</f></addM>
		<setM public="1" set="method" line="67"><f a="m">
	<c path="box2D.common.math.B2Mat22"/>
	<e path="Void"/>
</f></setM>
		<copy public="1" set="method" line="61"><f a=""><c path="box2D.common.math.B2Mat22"/></f></copy>
		<setVV public="1" set="method" line="55"><f a="c1:c2">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></setVV>
		<set public="1" set="method" line="47"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* A 2-by-2 matrix. Stored in column-major order.</haxe_doc>
	</class>
	<class path="box2D.collision.B2TimeOfImpact" params="" file="../../lib/box2D/collision/B2TimeOfImpact.hx">
		<b2_toiCalls line="34" static="1"><c path="Int"/></b2_toiCalls>
		<b2_toiIters line="35" static="1"><c path="Int"/></b2_toiIters>
		<b2_toiMaxIters line="36" static="1"><c path="Int"/></b2_toiMaxIters>
		<b2_toiRootIters line="37" static="1"><c path="Int"/></b2_toiRootIters>
		<b2_toiMaxRootIters line="38" static="1"><c path="Int"/></b2_toiMaxRootIters>
		<s_cache line="40" static="1"><c path="box2D.collision.B2SimplexCache"/></s_cache>
		<s_distanceInput line="41" static="1"><c path="box2D.collision.B2DistanceInput"/></s_distanceInput>
		<s_xfA line="42" static="1"><c path="box2D.common.math.B2Transform"/></s_xfA>
		<s_xfB line="43" static="1"><c path="box2D.common.math.B2Transform"/></s_xfB>
		<s_fcn line="44" static="1"><c path="box2D.collision.B2SeparationFunction"/></s_fcn>
		<s_distanceOutput line="45" static="1"><c path="box2D.collision.B2DistanceOutput"/></s_distanceOutput>
		<timeOfImpact public="1" set="method" line="46" static="1"><f a="input">
	<c path="box2D.collision.B2TOIInput"/>
	<c path="Float"/>
</f></timeOfImpact>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.collision.B2WorldManifold" params="" file="../../lib/box2D/collision/B2WorldManifold.hx">
		<m_points public="1">
			<c path="Array"><c path="box2D.common.math.B2Vec2"/></c>
			<haxe_doc>* world contact point (point of intersection)</haxe_doc>
		</m_points>
		<m_normal public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* world vector pointing from A to B</haxe_doc>
		</m_normal>
		<initialize public="1" set="method" line="50">
			<f a="manifold:xfA:radiusA:xfB:radiusB">
				<c path="box2D.collision.B2Manifold"/>
				<c path="box2D.common.math.B2Transform"/>
				<c path="Float"/>
				<c path="box2D.common.math.B2Transform"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Evaluate the manifold with supplied transforms. This assumes
	 * modest motion from the original state. This does not change the
	 * point count, impulses, etc. The radii must come from the shapes
	 * that generated the manifold.</haxe_doc>
		</initialize>
		<new public="1" set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* This is used to compute the current state of a contact manifold.</haxe_doc>
	</class>
	<class path="box2D.collision.shapes.B2Shape" params="" file="../../lib/box2D/collision/shapes/B2Shape.hx">
		<testOverlap public="1" set="method" line="121" static="1"><f a="shape1:transform1:shape2:transform2">
	<c path="box2D.collision.shapes.B2Shape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.shapes.B2Shape"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Bool"/>
</f></testOverlap>
		<e_unknownShape public="1" line="161" static="1">
			<c path="Int"/>
			<haxe_doc>* The various collision shape types supported by Box2D.</haxe_doc>
		</e_unknownShape>
		<e_circleShape public="1" line="162" static="1"><c path="Int"/></e_circleShape>
		<e_polygonShape public="1" line="163" static="1"><c path="Int"/></e_polygonShape>
		<e_edgeShape public="1" line="164" static="1"><c path="Int"/></e_edgeShape>
		<e_shapeTypeCount public="1" line="165" static="1"><c path="Int"/></e_shapeTypeCount>
		<e_hitCollide public="1" line="172" static="1">
			<c path="Int"/>
			<haxe_doc>Return value for TestSegment indicating a hit.</haxe_doc>
		</e_hitCollide>
		<e_missCollide public="1" line="174" static="1">
			<c path="Int"/>
			<haxe_doc>Return value for TestSegment indicating a miss.</haxe_doc>
		</e_missCollide>
		<e_startsInsideCollide public="1" line="176" static="1">
			<c path="Int"/>
			<haxe_doc>Return value for TestSegment indicating that the segment starting point, p1, is already inside the shape.</haxe_doc>
		</e_startsInsideCollide>
		<m_radius public="1"><c path="Float"/></m_radius>
		<m_type public="1"><c path="Int"/></m_type>
		<computeSubmergedArea public="1" set="method" line="115">
			<f a="normal:offset:xf:c">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Compute the volume and centroid of this shape intersected with a half plane
	 * @param normal the surface normal
	 * @param offset the surface offset along normal
	 * @param xf the shape transform
	 * @param c returns the centroid
	 * @return the total volume less than offset along normal</haxe_doc>
		</computeSubmergedArea>
		<computeMass public="1" set="method" line="105">
			<f a="massData:density">
				<c path="box2D.collision.shapes.B2MassData"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Compute the mass properties of this shape using its dimensions and density.
	* The inertia tensor is computed about the local origin, not the centroid.
	* @param massData returns the mass data for this shape.</haxe_doc>
		</computeMass>
		<computeAABB public="1" set="method" line="98">
			<f a="aabb:xf">
				<c path="box2D.collision.B2AABB"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Given a transform, compute the associated axis aligned bounding box for this shape.
	* @param aabb returns the axis aligned box.
	* @param xf the world transform of the shape.</haxe_doc>
		</computeAABB>
		<rayCast public="1" set="method" line="88">
			<f a="output:input:transform">
				<c path="box2D.collision.B2RayCastOutput"/>
				<c path="box2D.collision.B2RayCastInput"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Cast a ray against this shape.
	 * @param output the ray-cast results.
	 * @param input the ray-cast input parameters.
	 * @param transform the transform to be applied to the shape.</haxe_doc>
		</rayCast>
		<testPoint public="1" set="method" line="80">
			<f a="xf:p">
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Test a point for containment in this shape. This only works for convex shapes.
	* @param xf the shape world transform.
	* @param p a point in world coordinates.</haxe_doc>
		</testPoint>
		<getType public="1" set="method" line="70">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the type of this shape. You can use this to down cast to the concrete shape.
	* @return the shape type.</haxe_doc>
		</getType>
		<set public="1" set="method" line="59">
			<f a="other">
				<c path="box2D.collision.shapes.B2Shape"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assign the properties of anther shape to this</haxe_doc>
		</set>
		<copy public="1" set="method" line="48">
			<f a=""><c path="box2D.collision.shapes.B2Shape"/></f>
			<haxe_doc>* Clone the shape</haxe_doc>
		</copy>
		<new public="1" set="method" line="145">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* A shape is used for collision detection. Shapes are created in b2Body.
* You can use shape for collision detection before they are attached to the world.
* @warning you cannot reuse shapes.</haxe_doc>
	</class>
	<class path="box2D.collision.shapes.B2CircleShape" params="" file="../../lib/box2D/collision/shapes/B2CircleShape.hx">
		<extends path="box2D.collision.shapes.B2Shape"/>
		<m_p public="1"><c path="box2D.common.math.B2Vec2"/></m_p>
		<setRadius public="1" set="method" line="213">
			<f a="radius">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the radius of the circle</haxe_doc>
		</setRadius>
		<getRadius public="1" set="method" line="205">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the radius of the circle</haxe_doc>
		</getRadius>
		<setLocalPosition public="1" set="method" line="198">
			<f a="position">
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the local position of this circle in its parent body.</haxe_doc>
		</setLocalPosition>
		<getLocalPosition public="1" set="method" line="191">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the local position of this circle in its parent body.</haxe_doc>
		</getLocalPosition>
		<computeSubmergedArea public="1" set="method" line="155" override="1">
			<f a="normal:offset:xf:c">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeSubmergedArea>
		<computeMass public="1" set="method" line="143" override="1">
			<f a="massData:density">
				<c path="box2D.collision.shapes.B2MassData"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeMass>
		<computeAABB public="1" set="method" line="131" override="1">
			<f a="aabb:transform">
				<c path="box2D.collision.B2AABB"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeAABB>
		<rayCast public="1" set="method" line="73" override="1">
			<f a="output:input:transform">
				<c path="box2D.collision.B2RayCastOutput"/>
				<c path="box2D.collision.B2RayCastInput"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</rayCast>
		<testPoint public="1" set="method" line="58" override="1">
			<f a="transform:p">
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</testPoint>
		<set public="1" set="method" line="45" override="1"><f a="other">
	<c path="box2D.collision.shapes.B2Shape"/>
	<e path="Void"/>
</f></set>
		<copy public="1" set="method" line="38" override="1"><f a=""><c path="box2D.collision.shapes.B2Shape"/></f></copy>
		<new public="1" set="method" line="218"><f a="?radius">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* A circle shape.
* @see b2CircleDef</haxe_doc>
	</class>
	<class path="box2D.collision.shapes.B2EdgeShape" params="" file="../../lib/box2D/collision/shapes/B2EdgeShape.hx">
		<extends path="box2D.collision.shapes.B2Shape"/>
		<m_prevEdge public="1"><c path="box2D.collision.shapes.B2EdgeShape"/></m_prevEdge>
		<m_nextEdge public="1"><c path="box2D.collision.shapes.B2EdgeShape"/></m_nextEdge>
		<m_cornerConvex2 public="1"><e path="Bool"/></m_cornerConvex2>
		<m_cornerConvex1 public="1"><e path="Bool"/></m_cornerConvex1>
		<m_cornerDir2 public="1"><c path="box2D.common.math.B2Vec2"/></m_cornerDir2>
		<m_cornerDir1 public="1"><c path="box2D.common.math.B2Vec2"/></m_cornerDir1>
		<m_direction public="1"><c path="box2D.common.math.B2Vec2"/></m_direction>
		<m_normal public="1"><c path="box2D.common.math.B2Vec2"/></m_normal>
		<m_length public="1"><c path="Float"/></m_length>
		<m_coreV2 public="1"><c path="box2D.common.math.B2Vec2"/></m_coreV2>
		<m_coreV1 public="1"><c path="box2D.common.math.B2Vec2"/></m_coreV1>
		<m_v2 public="1"><c path="box2D.common.math.B2Vec2"/></m_v2>
		<m_v1 public="1"><c path="box2D.common.math.B2Vec2"/></m_v1>
		<setNextEdge public="1" set="method" line="396">
			<f a="edge:core:cornerDir:convex">
				<c path="box2D.collision.shapes.B2EdgeShape"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setNextEdge>
		<setPrevEdge public="1" set="method" line="385">
			<f a="edge:core:cornerDir:convex">
				<c path="box2D.collision.shapes.B2EdgeShape"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</setPrevEdge>
		<support public="1" set="method" line="318">
			<f a="xf:dX:dY">
				<c path="box2D.common.math.B2Transform"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get the support point in the given world direction.
	* Use the supplied transform.</haxe_doc>
		</support>
		<s_supportVec><c path="box2D.common.math.B2Vec2"/></s_supportVec>
		<getPrevEdge public="1" set="method" line="308">
			<f a=""><c path="box2D.collision.shapes.B2EdgeShape"/></f>
			<haxe_doc>* Get the previous edge in the chain.</haxe_doc>
		</getPrevEdge>
		<getNextEdge public="1" set="method" line="300">
			<f a=""><c path="box2D.collision.shapes.B2EdgeShape"/></f>
			<haxe_doc>* Get the next edge in the chain.</haxe_doc>
		</getNextEdge>
		<getFirstVertex public="1" set="method" line="289">
			<f a="xf">
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get the first vertex and apply the supplied transform.</haxe_doc>
		</getFirstVertex>
		<corner2IsConvex public="1" set="method" line="281">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Returns true if the second corner of this edge
	* bends towards the solid side.</haxe_doc>
		</corner2IsConvex>
		<corner1IsConvex public="1" set="method" line="272">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Returns true if the first corner of this edge
	* bends towards the solid side.</haxe_doc>
		</corner1IsConvex>
		<getCorner2Vector public="1" set="method" line="263">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Returns a unit vector halfway between 
	* m_direction and m_nextEdge.m_direction.</haxe_doc>
		</getCorner2Vector>
		<getCorner1Vector public="1" set="method" line="254">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Returns a unit vector halfway between 
	* m_direction and m_prevEdge.m_direction.</haxe_doc>
		</getCorner1Vector>
		<getDirectionVector public="1" set="method" line="245">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get a parallel unit vector, pointing
	* from vertex1 to vertex2.</haxe_doc>
		</getDirectionVector>
		<getNormalVector public="1" set="method" line="235">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get a perpendicular unit vector, pointing
	* from the solid side to the empty side.</haxe_doc>
		</getNormalVector>
		<getCoreVertex2 public="1" set="method" line="226">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get a core vertex in local coordinates. These vertices
	* represent a smaller edge that is used for time of impact
	* computations.</haxe_doc>
		</getCoreVertex2>
		<getCoreVertex1 public="1" set="method" line="216">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get a core vertex in local coordinates. These vertices
	* represent a smaller edge that is used for time of impact
	* computations.</haxe_doc>
		</getCoreVertex1>
		<getVertex2 public="1" set="method" line="206">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the local position of vertex2 in parent body.</haxe_doc>
		</getVertex2>
		<getVertex1 public="1" set="method" line="198">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the local position of vertex1 in parent body.</haxe_doc>
		</getVertex1>
		<getLength public="1" set="method" line="190">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the distance from vertex1 to vertex2.</haxe_doc>
		</getLength>
		<computeSubmergedArea public="1" set="method" line="134" override="1">
			<f a="normal:offset:xf:c">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeSubmergedArea>
		<computeMass public="1" set="method" line="125" override="1">
			<f a="massData:density">
				<c path="box2D.collision.shapes.B2MassData"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeMass>
		<computeAABB public="1" set="method" line="98" override="1">
			<f a="aabb:transform">
				<c path="box2D.collision.B2AABB"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeAABB>
		<rayCast public="1" set="method" line="49" override="1">
			<f a="output:input:transform">
				<c path="box2D.collision.B2RayCastOutput"/>
				<c path="box2D.collision.B2RayCastInput"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</rayCast>
		<testPoint public="1" set="method" line="42" override="1">
			<f a="transform:p">
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Returns false. Edges cannot contain points.</haxe_doc>
		</testPoint>
		<new public="1" set="method" line="343">
			<f a="v1:v2">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* An edge shape.
 * @private
 * @see b2EdgeChainDef</haxe_doc>
	</class>
	<class path="box2D.collision.shapes.B2MassData" params="" file="../../lib/box2D/collision/shapes/B2MassData.hx">
		<I public="1">
			<c path="Float"/>
			<haxe_doc>* The rotational inertia of the shape.
	* This may be about the center or local origin, depending on usage.</haxe_doc>
		</I>
		<center public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The position of the shape's centroid relative to the shape's origin.</haxe_doc>
		</center>
		<mass public="1">
			<c path="Float"/>
			<haxe_doc>* The mass of the shape, usually in kilograms.</haxe_doc>
		</mass>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* This holds the mass data computed for a shape.</haxe_doc>
	</class>
	<class path="box2D.collision.shapes.B2PolygonShape" params="" file="../../lib/box2D/collision/shapes/B2PolygonShape.hx">
		<extends path="box2D.collision.shapes.B2Shape"/>
		<asArray public="1" set="method" line="79" static="1"><f a="vertices:vertexCount">
	<c path="Array"><d/></c>
	<c path="Float"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
</f></asArray>
		<asVector public="1" set="method" line="123" static="1"><f a="vertices:vertexCount">
	<c path="Array"><c path="box2D.common.math.B2Vec2"/></c>
	<c path="Float"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
</f></asVector>
		<asBox public="1" set="method" line="150" static="1"><f a="hx:hy">
	<c path="Float"/>
	<c path="Float"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
</f></asBox>
		<s_mat line="164" static="1">
			<c path="box2D.common.math.B2Mat22"/>
			<haxe_doc>* Build vertices to represent an oriented box.
	* @param hx the half-width.
	* @param hy the half-height.
	* @param center the center of the box in local coordinates.
	* @param angle the rotation of the box in local coordinates.</haxe_doc>
		</s_mat>
		<asOrientedBox public="1" set="method" line="191" static="1"><f a="hx:hy:?center:?angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
</f></asOrientedBox>
		<asEdge public="1" set="method" line="218" static="1">
			<f a="v1:v2">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.collision.shapes.B2PolygonShape"/>
			</f>
			<haxe_doc>* Set this as a single edge.</haxe_doc>
		</asEdge>
		<computeCentroid public="1" set="method" line="760" static="1">
			<f a="vs:count">
				<c path="Array"><c path="box2D.common.math.B2Vec2"/></c>
				<c path="Int"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Computes the centroid of the given polygon
	 * @param	vs		vector of b2Vec specifying a polygon
	 * @param	count	length of vs
	 * @return the polygon centroid</haxe_doc>
		</computeCentroid>
		<computeOBB public="1" set="method" line="818" static="1">
			<f a="obb:vs:count">
				<c path="box2D.collision.B2OBB"/>
				<c path="Array"><c path="box2D.common.math.B2Vec2"/></c>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Computes a polygon's OBB
	 * @see http://www.geometrictools.com/Documentation/MinimumAreaRectangle.pdf</haxe_doc>
		</computeOBB>
		<m_vertexCount public="1"><c path="Int"/></m_vertexCount>
		<m_normals public="1"><c path="Array"><c path="box2D.common.math.B2Vec2"/></c></m_normals>
		<m_vertices public="1"><c path="Array"><c path="box2D.common.math.B2Vec2"/></c></m_vertices>
		<m_centroid public="1"><c path="box2D.common.math.B2Vec2"/></m_centroid>
		<reserve set="method" line="735"><f a="count">
	<c path="Int"/>
	<e path="Void"/>
</f></reserve>
		<validate set="method" line="681"><f a=""><e path="Bool"/></f></validate>
		<getSupportVertex public="1" set="method" line="664"><f a="d">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></getSupportVertex>
		<getSupport public="1" set="method" line="648">
			<f a="d">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Get the supporting vertex index in the given direction.</haxe_doc>
		</getSupport>
		<getNormals public="1" set="method" line="640">
			<f a=""><c path="Array"><c path="box2D.common.math.B2Vec2"/></c></f>
			<haxe_doc>* Get the edge normal vectors. There is one for each vertex.</haxe_doc>
		</getNormals>
		<getVertices public="1" set="method" line="633">
			<f a=""><c path="Array"><c path="box2D.common.math.B2Vec2"/></c></f>
			<haxe_doc>* Get the vertices in local coordinates.</haxe_doc>
		</getVertices>
		<getVertexCount public="1" set="method" line="626">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the vertex count.</haxe_doc>
		</getVertexCount>
		<computeSubmergedArea public="1" set="method" line="511" override="1">
			<f a="normal:offset:xf:c">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeSubmergedArea>
		<computeMass public="1" set="method" line="387" override="1">
			<f a="massData:density">
				<c path="box2D.collision.shapes.B2MassData"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeMass>
		<computeAABB public="1" set="method" line="356" override="1">
			<f a="aabb:xf">
				<c path="box2D.collision.B2AABB"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</computeAABB>
		<rayCast public="1" set="method" line="259" override="1">
			<f a="output:input:transform">
				<c path="box2D.collision.B2RayCastOutput"/>
				<c path="box2D.collision.B2RayCastInput"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</rayCast>
		<testPoint public="1" set="method" line="229" override="1">
			<f a="xf:p">
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</testPoint>
		<setAsEdge public="1" set="method" line="201">
			<f a="v1:v2">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set this as a single edge.</haxe_doc>
		</setAsEdge>
		<setAsOrientedBox public="1" set="method" line="165"><f a="hx:hy:?center:?angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setAsOrientedBox>
		<setAsBox public="1" set="method" line="135">
			<f a="hx:hy">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Build vertices to represent an axis-aligned box.
	* @param hx the half-width.
	* @param hy the half-height.</haxe_doc>
		</setAsBox>
		<setAsVector public="1" set="method" line="90">
			<f a="vertices:?vertexCount">
				<c path="Array"><c path="box2D.common.math.B2Vec2"/></c>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Copy vertices. This assumes the vertices define a convex polygon.
	 * It is assumed that the exterior is the the right of each edge.</haxe_doc>
		</setAsVector>
		<setAsArray public="1" set="method" line="69">
			<f a="vertices:?vertexCount">
				<c path="Array"><d/></c>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Copy vertices. This assumes the vertices define a convex polygon.
	 * It is assumed that the exterior is the the right of each edge.</haxe_doc>
		</setAsArray>
		<set public="1" set="method" line="48" override="1"><f a="other">
	<c path="box2D.collision.shapes.B2Shape"/>
	<e path="Void"/>
</f></set>
		<copy public="1" set="method" line="41" override="1"><f a=""><c path="box2D.collision.shapes.B2Shape"/></f></copy>
		<new public="1" set="method" line="723">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* Convex polygon. The vertices must be in CCW order for a right-handed
* coordinate system with the z-axis coming out of the screen.
* @see b2PolygonDef</haxe_doc>
	</class>
	<class path="box2D.common.B2Color" params="" file="../../lib/box2D/common/B2Color.hx">
		<_b><c path="Int"/></_b>
		<_g><c path="Int"/></_g>
		<_r><c path="Int"/></_r>
		<getColor set="method" line="63"><f a=""><c path="Int"/></f></getColor>
		<setB set="method" line="58"><f a="bb">
	<c path="Float"/>
	<c path="Float"/>
</f></setB>
		<setG set="method" line="54"><f a="gg">
	<c path="Float"/>
	<c path="Float"/>
</f></setG>
		<setR set="method" line="50"><f a="rr">
	<c path="Float"/>
	<c path="Float"/>
</f></setR>
		<color public="1" get="getColor" set="null"><c path="Int"/></color>
		<b public="1" get="null" set="setB"><c path="Float"/></b>
		<g public="1" get="null" set="setG"><c path="Float"/></g>
		<r public="1" get="null" set="setR"><c path="Float"/></r>
		<set public="1" set="method" line="38"><f a="rr:gg:bb">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<new public="1" set="method" line="32"><f a="rr:gg:bb">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Color for debug drawing. Each value has the range [0,1].</haxe_doc>
	</class>
	<class path="box2D.common.B2Settings" params="" file="../../lib/box2D/common/B2Settings.hx">
		<VERSION public="1" line="30" static="1">
			<c path="String"/>
			<haxe_doc>* The current version of Box2D</haxe_doc>
		</VERSION>
		<USHRT_MAX public="1" line="33" static="1"><c path="Int"/></USHRT_MAX>
		<b2_pi public="1" line="36" static="1"><c path="Float"/></b2_pi>
		<b2_maxManifoldPoints public="1" line="44" static="1">
			<c path="Int"/>
			<haxe_doc>*   Number of manifold points in a b2Manifold. This should NEVER change.</haxe_doc>
		</b2_maxManifoldPoints>
		<b2_aabbExtension public="1" line="58" static="1">
			<c path="Float"/>
			<haxe_doc>* This is used to fatten AABBs in the dynamic tree. This allows proxies
	 * to move by a small amount without triggering a tree adjustment.
	 * This is in meters.</haxe_doc>
		</b2_aabbExtension>
		<b2_aabbMultiplier public="1" line="65" static="1">
			<c path="Float"/>
			<haxe_doc>* This is used to fatten AABBs in the dynamic tree. This is used to predict
 	 * the future position based on the current displacement.
	 * This is a dimensionless multiplier.</haxe_doc>
		</b2_aabbMultiplier>
		<b2_polygonRadius public="1" line="72" static="1">
			<c path="Float"/>
			<haxe_doc>* The radius of the polygon/edge shape skin. This should not be modified. Making
	 * this smaller means polygons will have and insufficient for continuous collision.
	 * Making it larger may create artifacts for vertex collision.</haxe_doc>
		</b2_polygonRadius>
		<b2_linearSlop public="1" line="80" static="1">
			<c path="Float"/>
			<haxe_doc>* A small length used as a collision and constraint tolerance. Usually it is
	* chosen to be numerically significant, but visually insignificant.</haxe_doc>
		</b2_linearSlop>
		<b2_angularSlop public="1" line="86" static="1">
			<c path="Float"/>
			<haxe_doc>* A small angle used as a collision and constraint tolerance. Usually it is
	* chosen to be numerically significant, but visually insignificant.</haxe_doc>
		</b2_angularSlop>
		<b2_toiSlop public="1" line="94" static="1">
			<c path="Float"/>
			<haxe_doc>* Continuous collision detection (CCD) works with core, shrunken shapes. This is the
	* amount by which shapes are automatically shrunk to work with CCD. This must be
	* larger than b2_linearSlop.
    * @see b2_linearSlop</haxe_doc>
		</b2_toiSlop>
		<b2_maxTOIContactsPerIsland public="1" line="99" static="1">
			<c path="Int"/>
			<haxe_doc>* Maximum number of contacts to be handled to solve a TOI island.</haxe_doc>
		</b2_maxTOIContactsPerIsland>
		<b2_maxTOIJointsPerIsland public="1" line="104" static="1">
			<c path="Int"/>
			<haxe_doc>* Maximum number of joints to be handled to solve a TOI island.</haxe_doc>
		</b2_maxTOIJointsPerIsland>
		<b2_velocityThreshold public="1" line="110" static="1">
			<c path="Float"/>
			<haxe_doc>* A velocity threshold for elastic collisions. Any collision with a relative linear
	* velocity below this threshold will be treated as inelastic.</haxe_doc>
		</b2_velocityThreshold>
		<b2_maxLinearCorrection public="1" line="116" static="1">
			<c path="Float"/>
			<haxe_doc>* The maximum linear position correction used when solving constraints. This helps to
	* prevent overshoot.</haxe_doc>
		</b2_maxLinearCorrection>
		<b2_maxAngularCorrection public="1" line="122" static="1">
			<c path="Float"/>
			<haxe_doc>* The maximum angular position correction used when solving constraints. This helps to
	* prevent overshoot.</haxe_doc>
		</b2_maxAngularCorrection>
		<b2_maxTranslation public="1" line="128" static="1">
			<c path="Float"/>
			<haxe_doc>* The maximum linear velocity of a body. This limit is very large and is used
	* to prevent numerical problems. You shouldn't need to adjust this.</haxe_doc>
		</b2_maxTranslation>
		<b2_maxTranslationSquared public="1" line="129" static="1"><c path="Float"/></b2_maxTranslationSquared>
		<b2_maxRotation public="1" line="135" static="1">
			<c path="Float"/>
			<haxe_doc>* The maximum angular velocity of a body. This limit is very large and is used
	* to prevent numerical problems. You shouldn't need to adjust this.</haxe_doc>
		</b2_maxRotation>
		<b2_maxRotationSquared public="1" line="136" static="1"><c path="Float"/></b2_maxRotationSquared>
		<b2_contactBaumgarte public="1" line="143" static="1">
			<c path="Float"/>
			<haxe_doc>* This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
	* that overlap is removed in one time step. However using values close to 1 often lead
	* to overshoot.</haxe_doc>
		</b2_contactBaumgarte>
		<b2MixFriction public="1" set="method" line="148" static="1">
			<f a="friction1:friction2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Friction mixing law. Feel free to customize this.</haxe_doc>
		</b2MixFriction>
		<b2MixRestitution public="1" set="method" line="156" static="1">
			<f a="restitution1:restitution2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Restitution mixing law. Feel free to customize this.</haxe_doc>
		</b2MixRestitution>
		<b2_timeToSleep public="1" line="168" static="1">
			<c path="Float"/>
			<haxe_doc>* The time that a body must be still before it will go to sleep.</haxe_doc>
		</b2_timeToSleep>
		<b2_linearSleepTolerance public="1" line="172" static="1">
			<c path="Float"/>
			<haxe_doc>* A body cannot sleep if its linear velocity is above this tolerance.</haxe_doc>
		</b2_linearSleepTolerance>
		<b2_angularSleepTolerance public="1" line="176" static="1">
			<c path="Float"/>
			<haxe_doc>* A body cannot sleep if its angular velocity is above this tolerance.</haxe_doc>
		</b2_angularSleepTolerance>
		<b2Assert public="1" set="method" line="183" static="1">
			<f a="a">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* b2Assert is used internally to handle assertions. By default, calls are commented out to save performance,
    * so they serve more as documentation than anything else.</haxe_doc>
		</b2Assert>
		<haxe_doc>* This class controls Box2D global settings</haxe_doc>
	</class>
	<class path="box2D.common.math.B2Mat33" params="" file="../../lib/box2D/common/math/B2Mat33.hx">
		<col3 public="1"><c path="box2D.common.math.B2Vec3"/></col3>
		<col2 public="1"><c path="box2D.common.math.B2Vec3"/></col2>
		<col1 public="1"><c path="box2D.common.math.B2Vec3"/></col1>
		<solve33 public="1" set="method" line="114"><f a="out:bX:bY:bZ">
	<c path="box2D.common.math.B2Vec3"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec3"/>
</f></solve33>
		<solve22 public="1" set="method" line="94"><f a="out:bX:bY">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></solve22>
		<setZero public="1" set="method" line="86"><f a=""><e path="Void"/></f></setZero>
		<setIdentity public="1" set="method" line="79"><f a=""><e path="Void"/></f></setIdentity>
		<addM public="1" set="method" line="66"><f a="m">
	<c path="box2D.common.math.B2Mat33"/>
	<e path="Void"/>
</f></addM>
		<setM public="1" set="method" line="59"><f a="m">
	<c path="box2D.common.math.B2Mat33"/>
	<e path="Void"/>
</f></setM>
		<copy public="1" set="method" line="55"><f a=""><c path="box2D.common.math.B2Mat33"/></f></copy>
		<setVVV public="1" set="method" line="48"><f a="c1:c2:c3">
	<c path="box2D.common.math.B2Vec3"/>
	<c path="box2D.common.math.B2Vec3"/>
	<c path="box2D.common.math.B2Vec3"/>
	<e path="Void"/>
</f></setVVV>
		<new public="1" set="method" line="27"><f a="?c1:?c2:?c3">
	<c path="box2D.common.math.B2Vec3"/>
	<c path="box2D.common.math.B2Vec3"/>
	<c path="box2D.common.math.B2Vec3"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* A 3-by-3 matrix. Stored in column-major order.</haxe_doc>
	</class>
	<class path="box2D.common.math.B2Math" params="" file="../../lib/box2D/common/math/B2Math.hx">
		<isValid public="1" set="method" line="34" static="1">
			<f a="x">
				<c path="Float"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* This function is used to ensure that a floating point number is
	* not a NaN or infinity.</haxe_doc>
		</isValid>
		<dot public="1" set="method" line="61" static="1"><f a="a:b">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
</f></dot>
		<crossVV public="1" set="method" line="66" static="1"><f a="a:b">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
</f></crossVV>
		<crossVF public="1" set="method" line="71" static="1"><f a="a:s">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></crossVF>
		<crossFV public="1" set="method" line="77" static="1"><f a="s:a">
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></crossFV>
		<mulMV public="1" set="method" line="83" static="1"><f a="A:v">
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></mulMV>
		<mulTMV public="1" set="method" line="91" static="1"><f a="A:v">
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></mulTMV>
		<mulX public="1" set="method" line="99" static="1"><f a="T:v">
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></mulX>
		<mulXT public="1" set="method" line="108" static="1"><f a="T:v">
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></mulXT>
		<addVV public="1" set="method" line="118" static="1"><f a="a:b">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></addVV>
		<subtractVV public="1" set="method" line="124" static="1"><f a="a:b">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></subtractVV>
		<distance public="1" set="method" line="130" static="1"><f a="a:b">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
</f></distance>
		<distanceSquared public="1" set="method" line="136" static="1"><f a="a:b">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
</f></distanceSquared>
		<mulFV public="1" set="method" line="142" static="1"><f a="s:a">
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></mulFV>
		<addMM public="1" set="method" line="148" static="1"><f a="A:B">
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Mat22"/>
</f></addMM>
		<mulMM public="1" set="method" line="155" static="1"><f a="A:B">
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Mat22"/>
</f></mulMM>
		<mulTMM public="1" set="method" line="162" static="1"><f a="A:B">
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Mat22"/>
</f></mulTMM>
		<abs public="1" set="method" line="170" static="1"><f a="a">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<absV public="1" set="method" line="175" static="1"><f a="a">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></absV>
		<absM public="1" set="method" line="181" static="1"><f a="A">
	<c path="box2D.common.math.B2Mat22"/>
	<c path="box2D.common.math.B2Mat22"/>
</f></absM>
		<min public="1" set="method" line="187" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<minV public="1" set="method" line="192" static="1"><f a="a:b">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></minV>
		<max public="1" set="method" line="198" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<maxV public="1" set="method" line="203" static="1"><f a="a:b">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></maxV>
		<clamp public="1" set="method" line="209" static="1"><f a="a:low:high">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></clamp>
		<clampV public="1" set="method" line="214" static="1"><f a="a:low:high">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
</f></clampV>
		<swap public="1" set="method" line="219" static="1"><f a="a:b">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></swap>
		<random public="1" set="method" line="227" static="1"><f a=""><c path="Float"/></f></random>
		<randomRange public="1" set="method" line="232" static="1"><f a="lo:hi">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></randomRange>
		<isPowerOfTwo public="1" set="method" line="256" static="1"><f a="x">
	<c path="Int"/>
	<e path="Bool"/>
</f></isPowerOfTwo>
		<b2Vec2_zero public="1" line="274" static="1"><c path="box2D.common.math.B2Vec2"/></b2Vec2_zero>
		<b2Mat22_identity public="1" line="275" static="1"><c path="box2D.common.math.B2Mat22"/></b2Mat22_identity>
		<b2Transform_identity public="1" line="276" static="1"><c path="box2D.common.math.B2Transform"/></b2Transform_identity>
		<MIN_VALUE public="1" get="inline" set="null" line="281" static="1"><c path="Float"/></MIN_VALUE>
		<MAX_VALUE public="1" get="inline" set="null" line="282" static="1"><c path="Float"/></MAX_VALUE>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.common.math.B2Sweep" params="" file="../../lib/box2D/common/math/B2Sweep.hx">
		<t0 public="1">
			<c path="Float"/>
			<haxe_doc>Time interval = [t0,1], where t0 is in [0,1]</haxe_doc>
		</t0>
		<a public="1">
			<c path="Float"/>
			<haxe_doc>World angle</haxe_doc>
		</a>
		<a0 public="1">
			<c path="Float"/>
			<haxe_doc>World angle</haxe_doc>
		</a0>
		<c public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Center world position</haxe_doc>
		</c>
		<c0 public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Center world position</haxe_doc>
		</c0>
		<localCenter public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>Local center of mass position</haxe_doc>
		</localCenter>
		<advance public="1" set="method" line="83">
			<f a="t">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Advance the sweep forward, yielding a new initial state.
	* @param t the new initial time.</haxe_doc>
		</advance>
		<getTransform public="1" set="method" line="65">
			<f a="xf:alpha">
				<c path="box2D.common.math.B2Transform"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Get the interpolated transform at a specific time.
	* @param alpha is a factor in [0,1], where 0 indicates t0.</haxe_doc>
		</getTransform>
		<copy public="1" set="method" line="49"><f a=""><c path="box2D.common.math.B2Sweep"/></f></copy>
		<set public="1" set="method" line="39"><f a="other">
	<c path="box2D.common.math.B2Sweep"/>
	<e path="Void"/>
</f></set>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* This describes the motion of a body/shape for TOI computation.
* Shapes are defined with respect to the body origin, which may
* no coincide with the center of mass. However, to support dynamics
* we must interpolate the center of mass position.</haxe_doc>
	</class>
	<class path="box2D.common.math.B2Vec3" params="" file="../../lib/box2D/common/math/B2Vec3.hx">
		<z public="1"><c path="Float"/></z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<multiply public="1" set="method" line="84"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></multiply>
		<subtract public="1" set="method" line="79"><f a="v">
	<c path="box2D.common.math.B2Vec3"/>
	<e path="Void"/>
</f></subtract>
		<add public="1" set="method" line="74"><f a="v">
	<c path="box2D.common.math.B2Vec3"/>
	<e path="Void"/>
</f></add>
		<copy public="1" set="method" line="70"><f a=""><c path="box2D.common.math.B2Vec3"/></f></copy>
		<negativeSelf public="1" set="method" line="68"><f a=""><e path="Void"/></f></negativeSelf>
		<getNegative public="1" set="method" line="66">
			<f a=""><c path="box2D.common.math.B2Vec3"/></f>
			<haxe_doc>* Negate this vector</haxe_doc>
		</getNegative>
		<setV public="1" set="method" line="56"><f a="v">
	<c path="box2D.common.math.B2Vec3"/>
	<e path="Void"/>
</f></setV>
		<set public="1" set="method" line="49">
			<f a="x:y:z">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set this vector to some specified coordinates.</haxe_doc>
		</set>
		<setZero public="1" set="method" line="41">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Sets this vector to all zeros</haxe_doc>
		</setZero>
		<new public="1" set="method" line="31">
			<f a="?x:?y:?z">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Construct using co-ordinates</haxe_doc>
		</new>
		<haxe_doc>* A 2D column vector with 3 elements.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2Body" params="" file="../../lib/box2D/dynamics/B2Body.hx">
		<s_xf1 line="1267" static="1"><c path="box2D.common.math.B2Transform"/></s_xf1>
		<e_islandFlag public="1" line="1375" static="1"><c path="Int"/></e_islandFlag>
		<e_awakeFlag public="1" line="1376" static="1"><c path="Int"/></e_awakeFlag>
		<e_allowSleepFlag public="1" line="1377" static="1"><c path="Int"/></e_allowSleepFlag>
		<e_bulletFlag public="1" line="1378" static="1"><c path="Int"/></e_bulletFlag>
		<e_fixedRotationFlag public="1" line="1379" static="1"><c path="Int"/></e_fixedRotationFlag>
		<e_activeFlag public="1" line="1380" static="1"><c path="Int"/></e_activeFlag>
		<b2_staticBody public="1" line="1390" static="1"><c path="Int"/></b2_staticBody>
		<b2_kinematicBody public="1" line="1391" static="1"><c path="Int"/></b2_kinematicBody>
		<b2_dynamicBody public="1" line="1392" static="1"><c path="Int"/></b2_dynamicBody>
		<m_userData><d/></m_userData>
		<m_sleepTime public="1"><c path="Float"/></m_sleepTime>
		<m_angularDamping public="1"><c path="Float"/></m_angularDamping>
		<m_linearDamping public="1"><c path="Float"/></m_linearDamping>
		<m_inertiaScale public="1"><c path="Float"/></m_inertiaScale>
		<m_invI public="1"><c path="Float"/></m_invI>
		<m_I public="1"><c path="Float"/></m_I>
		<m_invMass public="1"><c path="Float"/></m_invMass>
		<m_mass public="1"><c path="Float"/></m_mass>
		<m_contactList public="1"><c path="box2D.dynamics.contacts.B2ContactEdge"/></m_contactList>
		<m_jointList public="1"><c path="box2D.dynamics.joints.B2JointEdge"/></m_jointList>
		<m_controllerCount public="1"><c path="Int"/></m_controllerCount>
		<m_controllerList public="1"><c path="box2D.dynamics.controllers.B2ControllerEdge"/></m_controllerList>
		<m_fixtureCount public="1"><c path="Int"/></m_fixtureCount>
		<m_fixtureList public="1"><c path="box2D.dynamics.B2Fixture"/></m_fixtureList>
		<m_next public="1"><c path="box2D.dynamics.B2Body"/></m_next>
		<m_prev public="1"><c path="box2D.dynamics.B2Body"/></m_prev>
		<m_world public="1"><c path="box2D.dynamics.B2World"/></m_world>
		<m_torque public="1"><c path="Float"/></m_torque>
		<m_force public="1"><c path="box2D.common.math.B2Vec2"/></m_force>
		<m_angularVelocity public="1"><c path="Float"/></m_angularVelocity>
		<m_linearVelocity public="1"><c path="box2D.common.math.B2Vec2"/></m_linearVelocity>
		<m_sweep public="1"><c path="box2D.common.math.B2Sweep"/></m_sweep>
		<m_xf public="1"><c path="box2D.common.math.B2Transform"/></m_xf>
		<m_islandIndex public="1"><c path="Int"/></m_islandIndex>
		<m_type public="1"><c path="Int"/></m_type>
		<m_flags public="1"><c path="Int"/></m_flags>
		<advance public="1" set="method" line="1321"><f a="t">
	<c path="Float"/>
	<e path="Void"/>
</f></advance>
		<shouldCollide public="1" set="method" line="1300"><f a="other">
	<c path="box2D.dynamics.B2Body"/>
	<e path="Bool"/>
</f></shouldCollide>
		<synchronizeTransform public="1" set="method" line="1289"><f a=""><e path="Void"/></f></synchronizeTransform>
		<synchronizeFixtures public="1" set="method" line="1269"><f a=""><e path="Void"/></f></synchronizeFixtures>
		<getWorld public="1" set="method" line="1146">
			<f a=""><c path="box2D.dynamics.B2World"/></f>
			<haxe_doc>* Get the parent world of this body.</haxe_doc>
		</getWorld>
		<setUserData public="1" set="method" line="1138">
			<f a="data">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the user data. Use this to store your application specific data.</haxe_doc>
		</setUserData>
		<getUserData public="1" set="method" line="1131">
			<f a=""><d/></f>
			<haxe_doc>* Get the user data pointer that was provided in the body definition.</haxe_doc>
		</getUserData>
		<getNext public="1" set="method" line="1124">
			<f a=""><c path="box2D.dynamics.B2Body"/></f>
			<haxe_doc>* Get the next body in the world's body list.</haxe_doc>
		</getNext>
		<getContactList public="1" set="method" line="1117">
			<f a=""><c path="box2D.dynamics.contacts.B2ContactEdge"/></f>
			<haxe_doc>* Get a list of all contacts attached to this body.</haxe_doc>
		</getContactList>
		<getControllerList public="1" set="method" line="1110">
			<f a=""><c path="box2D.dynamics.controllers.B2ControllerEdge"/></f>
			<haxe_doc>* Get the list of all controllers attached to this body.</haxe_doc>
		</getControllerList>
		<getJointList public="1" set="method" line="1103">
			<f a=""><c path="box2D.dynamics.joints.B2JointEdge"/></f>
			<haxe_doc>* Get the list of all joints attached to this body.</haxe_doc>
		</getJointList>
		<getFixtureList public="1" set="method" line="1096">
			<f a=""><c path="box2D.dynamics.B2Fixture"/></f>
			<haxe_doc>* Get the list of all fixtures attached to this body.</haxe_doc>
		</getFixtureList>
		<isSleepingAllowed public="1" set="method" line="1088">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is this body allowed to sleep?</haxe_doc>
		</isSleepingAllowed>
		<isActive public="1" set="method" line="1081">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Get the active state of the body.
	 * @return true if active.</haxe_doc>
		</isActive>
		<setActive public="1" set="method" line="1030">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set the active state of the body. An inactive body is not
	* simulated and cannot be collided with or woken up.
	* If you pass a flag of true, all fixtures will be added to the
	* broad-phase.
	* If you pass a flag of false, all fixtures will be removed from
	* the broad-phase and all contacts will be destroyed.
	* Fixtures and joints are otherwise unaffected. You may continue
	* to create/destroy fixtures and joints on inactive bodies.
	* Fixtures on an inactive body are implicitly inactive and will
	* not participate in collisions, ray-casts, or queries.
	* Joints connected to an inactive body are implicitly inactive.
	* An inactive body is still owned by a b2World object and remains
	* in the body list.</haxe_doc>
		</setActive>
		<isFixedRotation public="1" set="method" line="1011">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Does this body have fixed rotation?
	* @return true means fixed rotation</haxe_doc>
		</isFixedRotation>
		<setFixedRotation public="1" set="method" line="993">
			<f a="fixed">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set this body to have fixed rotation. This causes the mass to be reset.
	 * @param	fixed - true means no rotation</haxe_doc>
		</setFixedRotation>
		<isAwake public="1" set="method" line="985">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Get the sleeping state of this body.
	 * @return true if body is sleeping</haxe_doc>
		</isAwake>
		<setAwake public="1" set="method" line="964">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the sleep state of the body. A sleeping body has vety low CPU cost.
	 * @param	flag - set to true to put body to sleep, false to wake it</haxe_doc>
		</setAwake>
		<setSleepingAllowed public="1" set="method" line="948">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Is this body allowed to sleep
	 * @param	flag</haxe_doc>
		</setSleepingAllowed>
		<isBullet public="1" set="method" line="940">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is this body treated like a bullet for continuous collision detection?</haxe_doc>
		</isBullet>
		<setBullet public="1" set="method" line="926">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Should this body be treated like a bullet for continuous collision detection?</haxe_doc>
		</setBullet>
		<getType public="1" set="method" line="918">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the type of this body.
	 * @return type enum as a uint</haxe_doc>
		</getType>
		<setType public="1" set="method" line="883">
			<f a="type">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the type of this body. This may alter the mass and velocity
	 * @param	type - enum stored as a static member of b2Body</haxe_doc>
		</setType>
		<setAngularDamping public="1" set="method" line="874">
			<f a="angularDamping">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the angular damping of the body.</haxe_doc>
		</setAngularDamping>
		<getAngularDamping public="1" set="method" line="866">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the angular damping of the body</haxe_doc>
		</getAngularDamping>
		<setLinearDamping public="1" set="method" line="858">
			<f a="linearDamping">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the linear damping of the body.</haxe_doc>
		</setLinearDamping>
		<getLinearDamping public="1" set="method" line="850">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the linear damping of the body.</haxe_doc>
		</getLinearDamping>
		<getLinearVelocityFromLocalPoint public="1" set="method" line="835">
			<f a="localPoint">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get the world velocity of a local point.
	* @param a point in local coordinates.
	* @return the world velocity of a point.</haxe_doc>
		</getLinearVelocityFromLocalPoint>
		<getLinearVelocityFromWorldPoint public="1" set="method" line="823">
			<f a="worldPoint">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get the world linear velocity of a world point attached to this body.
	* @param a point in world coordinates.
	* @return the world velocity of a point.</haxe_doc>
		</getLinearVelocityFromWorldPoint>
		<getLocalVector public="1" set="method" line="814">
			<f a="worldVector">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Gets a local vector given a world vector.
	 * @param a vector in world coordinates.
	 * @return the corresponding local vector.</haxe_doc>
		</getLocalVector>
		<getLocalPoint public="1" set="method" line="805">
			<f a="worldPoint">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Gets a local point relative to the body's origin given a world point.
	 * @param a point in world coordinates.
	 * @return the corresponding local point relative to the body's origin.</haxe_doc>
		</getLocalPoint>
		<getWorldVector public="1" set="method" line="796">
			<f a="localVector">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get the world coordinates of a vector given the local coordinates.
	 * @param localVector a vector fixed in the body.
	 * @return the same vector expressed in world coordinates.</haxe_doc>
		</getWorldVector>
		<getWorldPoint public="1" set="method" line="781">
			<f a="localPoint">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get the world coordinates of a point given the local coordinates.
	 * @param localPoint a point on the body measured relative the the body's origin.
	 * @return the same point expressed in world coordinates.</haxe_doc>
		</getWorldPoint>
		<resetMassData public="1" set="method" line="700">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This resets the mass properties to the sum of the mass properties of the fixtures.
	 * This normally does not need to be called unless you called SetMassData to override
	 * the mass and later you want to reset the mass.</haxe_doc>
		</resetMassData>
		<setMassData public="1" set="method" line="649">
			<f a="massData">
				<c path="box2D.collision.shapes.B2MassData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the mass properties to override the mass properties of the fixtures
	 * Note that this changes the center of mass position.
	 * Note that creating or destroying fixtures can also alter the mass.
	 * This function has no effect if the body isn't dynamic.
	 * @warning The supplied rotational inertia should be relative to the center of mass
	 * @param	data the mass properties.</haxe_doc>
		</setMassData>
		<getMassData public="1" set="method" line="634">
			<f a="data">
				<c path="box2D.collision.shapes.B2MassData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Get the mass data of the body. The rotational inertial is relative to the center of mass.</haxe_doc>
		</getMassData>
		<getInertia public="1" set="method" line="627">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the central rotational inertia of the body.
	* @return the rotational inertia, usually in kg-m^2.</haxe_doc>
		</getInertia>
		<getMass public="1" set="method" line="619">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the total mass of the body.
	* @return the mass, usually in kilograms (kg).</haxe_doc>
		</getMass>
		<merge public="1" set="method" line="571">
			<f a="other">
				<c path="box2D.dynamics.B2Body"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Merges another body into this. Only fixtures, mass and velocity are effected,
	 * Other properties are ignored
	 * @asonly</haxe_doc>
		</merge>
		<split public="1" set="method" line="502">
			<f a="callbackMethod">
				<f a="">
					<c path="box2D.dynamics.B2Fixture"/>
					<e path="Bool"/>
				</f>
				<c path="box2D.dynamics.B2Body"/>
			</f>
			<haxe_doc><![CDATA[* Splits a body into two, preserving dynamic properties
	 * @param	callback Called once per fixture, return true to move this fixture to the new body
	 * <code>function Callback(fixture:B2Fixture):Bool</code>
	 * @return The newly created bodies
	 * @asonly]]></haxe_doc>
		</split>
		<applyImpulse public="1" set="method" line="478">
			<f a="impulse:point">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Apply an impulse at a point. This immediately modifies the velocity.
	* It also modifies the angular velocity if the point of application
	* is not at the center of mass. This wakes up the body.
	* @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
	* @param point the world position of the point of application.</haxe_doc>
		</applyImpulse>
		<applyTorque public="1" set="method" line="458">
			<f a="torque">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Apply a torque. This affects the angular velocity
	* without affecting the linear velocity of the center of mass.
	* This wakes up the body.
	* @param torque about the z-axis (out of the screen), usually in N-m.</haxe_doc>
		</applyTorque>
		<applyForce public="1" set="method" line="434">
			<f a="force:point">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Apply a force at a world point. If the force is not
	* applied at the center of mass, it will generate a torque and
	* affect the angular velocity. This wakes up the body.
	* @param force the world force vector, usually in Newtons (N).
	* @param point the world position of the point of application.</haxe_doc>
		</applyForce>
		<getDefinition public="1" set="method" line="409">
			<f a=""><c path="box2D.dynamics.B2BodyDef"/></f>
			<haxe_doc>* Get the definition containing the body properties.
	 * @asonly</haxe_doc>
		</getDefinition>
		<getAngularVelocity public="1" set="method" line="401">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the angular velocity.
	* @return the angular velocity in radians/second.</haxe_doc>
		</getAngularVelocity>
		<setAngularVelocity public="1" set="method" line="389">
			<f a="omega">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the angular velocity.
	* @param omega the new angular velocity in radians/second.</haxe_doc>
		</setAngularVelocity>
		<getLinearVelocity public="1" set="method" line="381">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the linear velocity of the center of mass.
	* @return the linear velocity of the center of mass.</haxe_doc>
		</getLinearVelocity>
		<setLinearVelocity public="1" set="method" line="369">
			<f a="v">
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the linear velocity of the center of mass.
	* @param v the new linear velocity of the center of mass.</haxe_doc>
		</setLinearVelocity>
		<getLocalCenter public="1" set="method" line="361">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the local position of the center of mass.</haxe_doc>
		</getLocalCenter>
		<getWorldCenter public="1" set="method" line="354">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the world position of the center of mass.</haxe_doc>
		</getWorldCenter>
		<setAngle public="1" set="method" line="345">
			<f a="angle">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the world body angle
	 * @param angle the new angle of the body.</haxe_doc>
		</setAngle>
		<getAngle public="1" set="method" line="337">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the angle in radians.
	* @return the current world rotation angle in radians.</haxe_doc>
		</getAngle>
		<setPosition public="1" set="method" line="328">
			<f a="position">
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Setthe world body origin position.
	 * @param position the new position of the body</haxe_doc>
		</setPosition>
		<getPosition public="1" set="method" line="320">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the world body origin position.
	* @return the world position of the body's origin.</haxe_doc>
		</getPosition>
		<getTransform public="1" set="method" line="312">
			<f a=""><c path="box2D.common.math.B2Transform"/></f>
			<haxe_doc>* Get the body transform for the body's origin.
	* @return the world transform of the body's origin.</haxe_doc>
		</getTransform>
		<setTransform public="1" set="method" line="303">
			<f a="xf">
				<c path="box2D.common.math.B2Transform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the position of the body's origin and rotation (radians).
	 * This breaks any contacts and wakes the other bodies.
	 * Note this is less efficient than the other overload - you should use that
	 * if the angle is available.
	 * @param xf the transform of position and angle to set the bdoy to.</haxe_doc>
		</setTransform>
		<setPositionAndAngle public="1" set="method" line="257">
			<f a="position:angle">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the position of the body's origin and rotation (radians).
	* This breaks any contacts and wakes the other bodies.
	* @param position the new world position of the body's origin (not necessarily
	* the center of mass).
	* @param angle the new world rotation angle of the body in radians.</haxe_doc>
		</setPositionAndAngle>
		<DestroyFixture public="1" set="method" line="180">
			<f a="fixture">
				<c path="box2D.dynamics.B2Fixture"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Destroy a fixture. This removes the fixture from the broad-phase and
	 * destroys all contacts associated with this fixture. This will
	 * automatically adjust the mass of the body if the body is dynamic and the
	 * fixture has positive density.
	 * All fixtures attached to a body are implicitly destroyed when the body is destroyed.
	 * @param fixture the fixture to be removed.
	 * @warning This function is locked during callbacks.</haxe_doc>
		</DestroyFixture>
		<createFixture2 public="1" set="method" line="162">
			<f a="shape:?density">
				<c path="box2D.collision.shapes.B2Shape"/>
				<c path="Float"/>
				<c path="box2D.dynamics.B2Fixture"/>
			</f>
			<haxe_doc>* Creates a fixture from a shape and attach it to this body.
	 * This is a convenience function. Use b2FixtureDef if you need to set parameters
	 * like friction, restitution, user data, or filtering.
	 * This function automatically updates the mass of the body.
	 * @param shape the shape to be cloned.
	 * @param density the shape density (set to zero for static bodies).
	 * @warning This function is locked during callbacks.</haxe_doc>
		</createFixture2>
		<createFixture public="1" set="method" line="70">
			<f a="def">
				<c path="box2D.dynamics.B2FixtureDef"/>
				<c path="box2D.dynamics.B2Fixture"/>
			</f>
			<haxe_doc>* Creates a fixture and attach it to this body. Use this function if you need
	 * to set some fixture parameters, like friction. Otherwise you can create the
	 * fixture directly from a shape.
	 * If the density is non-zero, this function automatically updates the mass of the body.
	 * Contacts are not created until the next time step.
	 * @param fixtureDef the fixture definition.
	 * @warning This function is locked during callbacks.</haxe_doc>
		</createFixture>
		<connectEdges set="method" line="45"><f a="s1:s2:angle1">
	<c path="box2D.collision.shapes.B2EdgeShape"/>
	<c path="box2D.collision.shapes.B2EdgeShape"/>
	<c path="Float"/>
	<c path="Float"/>
</f></connectEdges>
		<new public="1" set="method" line="1158">
			<f a="bd:world">
				<c path="box2D.dynamics.B2BodyDef"/>
				<c path="box2D.dynamics.B2World"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* A rigid body.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2BodyDef" params="" file="../../lib/box2D/dynamics/B2BodyDef.hx">
		<inertiaScale public="1">
			<c path="Float"/>
			<haxe_doc>* Scales the inertia tensor.
	 * @warning Experimental</haxe_doc>
		</inertiaScale>
		<userData public="1">
			<d/>
			<haxe_doc>* Use this to store application specific body data.</haxe_doc>
		</userData>
		<active public="1">
			<e path="Bool"/>
			<haxe_doc>* Does this body start out active?</haxe_doc>
		</active>
		<bullet public="1">
			<e path="Bool"/>
			<haxe_doc>* Is this a fast moving body that should be prevented from tunneling through
	 * other moving bodies? Note that all bodies are prevented from tunneling through
	 * static bodies.
	 * @warning You should use this flag sparingly since it increases processing time.</haxe_doc>
		</bullet>
		<fixedRotation public="1">
			<e path="Bool"/>
			<haxe_doc>* Should this body be prevented from rotating? Useful for characters.</haxe_doc>
		</fixedRotation>
		<awake public="1">
			<e path="Bool"/>
			<haxe_doc>* Is this body initially awake or sleeping?</haxe_doc>
		</awake>
		<allowSleep public="1">
			<e path="Bool"/>
			<haxe_doc>* Set this flag to false if this body should never fall asleep. Note that
	 * this increases CPU usage.</haxe_doc>
		</allowSleep>
		<angularDamping public="1">
			<c path="Float"/>
			<haxe_doc>* Angular damping is use to reduce the angular velocity. The damping parameter
	 * can be larger than 1.0f but the damping effect becomes sensitive to the
	 * time step when the damping parameter is large.</haxe_doc>
		</angularDamping>
		<linearDamping public="1">
			<c path="Float"/>
			<haxe_doc>* Linear damping is use to reduce the linear velocity. The damping parameter
	 * can be larger than 1.0f but the damping effect becomes sensitive to the
	 * time step when the damping parameter is large.</haxe_doc>
		</linearDamping>
		<angularVelocity public="1">
			<c path="Float"/>
			<haxe_doc>* The angular velocity of the body.</haxe_doc>
		</angularVelocity>
		<linearVelocity public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The linear velocity of the body's origin in world co-ordinates.</haxe_doc>
		</linearVelocity>
		<angle public="1">
			<c path="Float"/>
			<haxe_doc>* The world angle of the body in radians.</haxe_doc>
		</angle>
		<position public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The world position of the body. Avoid creating bodies at the origin
	 * since this can lead to many overlapping shapes.</haxe_doc>
		</position>
		<type public="1">
			<c path="Int"/>
			<haxe_doc>The body type: static, kinematic, or dynamic. A member of the b2BodyType class
	 * Note: if a dynamic body would have zero mass, the mass is set to one.
	 * @see b2Body#b2_staticBody
	 * @see b2Body#b2_dynamicBody
	 * @see b2Body#b2_kinematicBody</haxe_doc>
		</type>
		<new public="1" set="method" line="34">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This constructor sets the body definition default values.</haxe_doc>
		</new>
		<haxe_doc>* A body definition holds all the data needed to construct a rigid body.
* You can safely re-use body definitions.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2ContactFilter" params="" file="../../lib/box2D/dynamics/B2ContactFilter.hx">
		<b2_defaultFilter public="1" line="64" static="1"><c path="box2D.dynamics.B2ContactFilter"/></b2_defaultFilter>
		<rayCollide public="1" set="method" line="58">
			<f a="userData:fixture">
				<d/>
				<c path="box2D.dynamics.B2Fixture"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Return true if the given fixture should be considered for ray intersection.
	* By default, userData is cast as a b2Fixture and collision is resolved according to ShouldCollide
	* @see ShouldCollide()
	* @see b2World#Raycast
	* @param userData	arbitrary data passed from Raycast or RaycastOne
	* @param fixture		the fixture that we are testing for filtering
	* @return a Boolean, with a value of false indicating that this fixture should be ignored.</haxe_doc>
		</rayCollide>
		<shouldCollide public="1" set="method" line="36">
			<f a="fixtureA:fixtureB">
				<c path="box2D.dynamics.B2Fixture"/>
				<c path="box2D.dynamics.B2Fixture"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Return true if contact calculations should be performed between these two fixtures.
	* @warning for performance reasons this is only called when the AABBs begin to overlap.</haxe_doc>
		</shouldCollide>
		<new public="1" set="method" line="28"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Implement this class to provide collision filtering. In other words, you can implement
* this class if you want finer control over contact creation.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2ContactImpulse" params="" file="../../lib/box2D/dynamics/B2ContactImpulse.hx">
		<tangentImpulses public="1"><c path="Array"><c path="Float"/></c></tangentImpulses>
		<normalImpulses public="1"><c path="Array"><c path="Float"/></c></normalImpulses>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Contact impulses for reporting. Impulses are used instead of forces because
 * sub-step forces may approach infinity for rigid body collisions. These
 * match up one-to-one with the contact points in b2Manifold.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2ContactListener" params="" file="../../lib/box2D/dynamics/B2ContactListener.hx">
		<b2_defaultListener public="1" line="80" static="1"><c path="box2D.dynamics.B2ContactListener"/></b2_defaultListener>
		<postSolve public="1" set="method" line="78">
			<f a="contact:impulse">
				<c path="box2D.dynamics.contacts.B2Contact"/>
				<c path="box2D.dynamics.B2ContactImpulse"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* This lets you inspect a contact after the solver is finished. This is useful
	 * for inspecting impulses.
	 * Note: the contact manifold does not include time of impact impulses, which can be
	 * arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly
	 * in a separate data structure.
	 * Note: this is only called for contacts that are touching, solid, and awake.</haxe_doc>
		</postSolve>
		<preSolve public="1" set="method" line="68">
			<f a="contact:oldManifold">
				<c path="box2D.dynamics.contacts.B2Contact"/>
				<c path="box2D.collision.B2Manifold"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* This is called after a contact is updated. This allows you to inspect a
	 * contact before it goes to the solver. If you are careful, you can modify the
	 * contact manifold (e.g. disable contact).
	 * A copy of the old manifold is provided so that you can detect changes.
	 * Note: this is called only for awake bodies.
	 * Note: this is called even when the number of contact points is zero.
	 * Note: this is not called for sensors.
	 * Note: if you set the number of contact points to zero, you will not
	 * get an EndContact callback. However, you may get a BeginContact callback
	 * the next step.</haxe_doc>
		</preSolve>
		<endContact public="1" set="method" line="54">
			<f a="contact">
				<c path="box2D.dynamics.contacts.B2Contact"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when two fixtures cease to touch.</haxe_doc>
		</endContact>
		<beginContact public="1" set="method" line="49">
			<f a="contact">
				<c path="box2D.dynamics.contacts.B2Contact"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when two fixtures begin to touch.</haxe_doc>
		</beginContact>
		<new public="1" set="method" line="40"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Implement this class to get contact information. You can use these results for
 * things like sounds and game logic. You can also get contact results by
 * traversing the contact lists after the time step. However, you might miss
 * some contacts because continuous physics leads to sub-stepping.
 * Additionally you may receive multiple callbacks for the same contact in a
 * single time step.
 * You should strive to make your callbacks efficient because there may be
 * many callbacks per time step.
 * @warning You cannot create/destroy Box2D entities inside these callbacks.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2ContactManager" params="" file="../../lib/box2D/dynamics/B2ContactManager.hx">
		<s_evalCP line="141" static="1"><c path="box2D.collision.B2ContactPoint"/></s_evalCP>
		<m_allocator public="1"><d/></m_allocator>
		<m_contactFactory public="1"><c path="box2D.dynamics.contacts.B2ContactFactory"/></m_contactFactory>
		<m_contactListener public="1"><c path="box2D.dynamics.B2ContactListener"/></m_contactListener>
		<m_contactFilter public="1"><c path="box2D.dynamics.B2ContactFilter"/></m_contactFilter>
		<m_contactCount public="1"><c path="Int"/></m_contactCount>
		<m_contactList public="1"><c path="box2D.dynamics.contacts.B2Contact"/></m_contactList>
		<m_broadPhase public="1"><c path="box2D.collision.IBroadPhase"/></m_broadPhase>
		<m_world public="1"><c path="box2D.dynamics.B2World"/></m_world>
		<collide public="1" set="method" line="212"><f a=""><e path="Void"/></f></collide>
		<destroy public="1" set="method" line="142"><f a="c">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<e path="Void"/>
</f></destroy>
		<findNewContacts public="1" set="method" line="136"><f a=""><e path="Void"/></f></findNewContacts>
		<addPair public="1" set="method" line="47"><f a="proxyUserDataA:proxyUserDataB">
	<d/>
	<d/>
	<e path="Void"/>
</f></addPair>
		<new public="1" set="method" line="36"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2DebugDraw" params="" file="../../lib/box2D/dynamics/B2DebugDraw.hx">
		<e_shapeBit public="1" line="53" static="1">
			<c path="Int"/>
			<haxe_doc>Draw shapes</haxe_doc>
		</e_shapeBit>
		<e_jointBit public="1" line="55" static="1">
			<c path="Int"/>
			<haxe_doc>Draw joint connections</haxe_doc>
		</e_jointBit>
		<e_aabbBit public="1" line="57" static="1">
			<c path="Int"/>
			<haxe_doc>Draw axis aligned bounding boxes</haxe_doc>
		</e_aabbBit>
		<e_pairBit public="1" line="59" static="1">
			<c path="Int"/>
			<haxe_doc>Draw broad-phase pairs</haxe_doc>
		</e_pairBit>
		<e_centerOfMassBit public="1" line="61" static="1">
			<c path="Int"/>
			<haxe_doc>Draw center of mass frame</haxe_doc>
		</e_centerOfMassBit>
		<e_controllerBit public="1" line="63" static="1">
			<c path="Int"/>
			<haxe_doc>Draw controllers</haxe_doc>
		</e_controllerBit>
		<m_xformScale><c path="Float"/></m_xformScale>
		<m_fillAlpha><c path="Float"/></m_fillAlpha>
		<m_alpha><c path="Float"/></m_alpha>
		<m_lineThickness><c path="Float"/></m_lineThickness>
		<m_drawScale><c path="Float"/></m_drawScale>
		<m_sprite public="1"><t path="nme.display.Sprite"/></m_sprite>
		<m_drawFlags><c path="Int"/></m_drawFlags>
		<drawTransform public="1" set="method" line="249">
			<f a="xf">
				<c path="box2D.common.math.B2Transform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Draw a transform. Choose your own length scale.
	* @param xf a transform.</haxe_doc>
		</drawTransform>
		<drawSegment public="1" set="method" line="237">
			<f a="p1:p2:color">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.B2Color"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Draw a line segment.</haxe_doc>
		</drawSegment>
		<drawSolidCircle public="1" set="method" line="221">
			<f a="center:radius:axis:color">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.B2Color"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Draw a solid circle.</haxe_doc>
		</drawSolidCircle>
		<drawCircle public="1" set="method" line="211">
			<f a="center:radius:color">
				<c path="box2D.common.math.B2Vec2"/>
				<c path="Float"/>
				<c path="box2D.common.B2Color"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Draw a circle.</haxe_doc>
		</drawCircle>
		<drawSolidPolygon public="1" set="method" line="195">
			<f a="vertices:vertexCount:color">
				<c path="Array"><c path="box2D.common.math.B2Vec2"/></c>
				<c path="Int"/>
				<c path="box2D.common.B2Color"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Draw a solid closed polygon provided in CCW order.</haxe_doc>
		</drawSolidPolygon>
		<drawPolygon public="1" set="method" line="181">
			<f a="vertices:vertexCount:color">
				<c path="Array"><c path="box2D.common.math.B2Vec2"/></c>
				<c path="Int"/>
				<c path="box2D.common.B2Color"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Draw a closed polygon provided in CCW order.</haxe_doc>
		</drawPolygon>
		<getXFormScale public="1" set="method" line="174">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the scale used for drawing XForms</haxe_doc>
		</getXFormScale>
		<setXFormScale public="1" set="method" line="167">
			<f a="xformScale">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the scale used for drawing XForms</haxe_doc>
		</setXFormScale>
		<getFillAlpha public="1" set="method" line="160">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the alpha value used for fills</haxe_doc>
		</getFillAlpha>
		<setFillAlpha public="1" set="method" line="153">
			<f a="alpha">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the alpha value used for fills</haxe_doc>
		</setFillAlpha>
		<getAlpha public="1" set="method" line="146">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the alpha value used for lines</haxe_doc>
		</getAlpha>
		<setAlpha public="1" set="method" line="139">
			<f a="alpha">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the alpha value used for lines</haxe_doc>
		</setAlpha>
		<getLineThickness public="1" set="method" line="132">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the line thickness</haxe_doc>
		</getLineThickness>
		<setLineThickness public="1" set="method" line="125">
			<f a="lineThickness">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the line thickness</haxe_doc>
		</setLineThickness>
		<getDrawScale public="1" set="method" line="118">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the draw</haxe_doc>
		</getDrawScale>
		<setDrawScale public="1" set="method" line="111">
			<f a="drawScale">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the draw scale</haxe_doc>
		</setDrawScale>
		<getSprite public="1" set="method" line="104">
			<f a=""><t path="nme.display.Sprite"/></f>
			<haxe_doc>* Get the sprite</haxe_doc>
		</getSprite>
		<setSprite public="1" set="method" line="97">
			<f a="sprite">
				<t path="nme.display.Sprite"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the sprite</haxe_doc>
		</setSprite>
		<clearFlags public="1" set="method" line="90">
			<f a="flags">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Clear flags from the current flags.</haxe_doc>
		</clearFlags>
		<appendFlags public="1" set="method" line="83">
			<f a="flags">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Append flags to the current flags.</haxe_doc>
		</appendFlags>
		<getFlags public="1" set="method" line="76">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the drawing flags.</haxe_doc>
		</getFlags>
		<setFlags public="1" set="method" line="69">
			<f a="flags">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the drawing flags.</haxe_doc>
		</setFlags>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Implement and register this class with a b2World to provide debug drawing of physics
* entities in your game.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2DestructionListener" params="" file="../../lib/box2D/dynamics/B2DestructionListener.hx">
		<sayGoodbyeFixture public="1" set="method" line="43">
			<f a="fixture">
				<c path="box2D.dynamics.B2Fixture"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when any fixture is about to be destroyed due
	* to the destruction of its parent body.</haxe_doc>
		</sayGoodbyeFixture>
		<sayGoodbyeJoint public="1" set="method" line="37">
			<f a="joint">
				<c path="box2D.dynamics.joints.B2Joint"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when any joint is about to be destroyed due
	* to the destruction of one of its attached bodies.</haxe_doc>
		</sayGoodbyeJoint>
		<haxe_doc>* Joints and shapes are destroyed when their associated
* body is destroyed. Implement this listener so that you
* may nullify references to these joints and shapes.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2FilterData" params="" file="../../lib/box2D/dynamics/B2FilterData.hx">
		<groupIndex public="1">
			<c path="Int"/>
			<haxe_doc>* Collision groups allow a certain group of objects to never collide (negative)
	* or always collide (positive). Zero means no collision group. Non-zero group
	* filtering always wins against the mask bits.</haxe_doc>
		</groupIndex>
		<maskBits public="1">
			<c path="Int"/>
			<haxe_doc>* The collision mask bits. This states the categories that this
	* shape would accept for collision.</haxe_doc>
		</maskBits>
		<categoryBits public="1">
			<c path="Int"/>
			<haxe_doc>* The collision category bits. Normally you would just set one bit.</haxe_doc>
		</categoryBits>
		<copy public="1" set="method" line="39"><f a=""><c path="box2D.dynamics.B2FilterData"/></f></copy>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* This holds contact filtering data.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2Fixture" params="" file="../../lib/box2D/dynamics/B2Fixture.hx">
		<m_userData public="1"><d/></m_userData>
		<m_isSensor public="1"><e path="Bool"/></m_isSensor>
		<m_filter public="1"><c path="box2D.dynamics.B2FilterData"/></m_filter>
		<m_proxy public="1"><d/></m_proxy>
		<m_restitution public="1"><c path="Float"/></m_restitution>
		<m_friction public="1"><c path="Float"/></m_friction>
		<m_shape public="1"><c path="box2D.collision.shapes.B2Shape"/></m_shape>
		<m_body public="1"><c path="box2D.dynamics.B2Body"/></m_body>
		<m_next public="1"><c path="box2D.dynamics.B2Fixture"/></m_next>
		<m_density public="1"><c path="Float"/></m_density>
		<m_aabb public="1"><c path="box2D.collision.B2AABB"/></m_aabb>
		<m_massData><c path="box2D.collision.shapes.B2MassData"/></m_massData>
		<synchronize public="1" set="method" line="337"><f a="broadPhase:transform1:transform2">
	<c path="box2D.collision.IBroadPhase"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></synchronize>
		<destroyProxy public="1" set="method" line="326">
			<f a="broadPhase">
				<c path="box2D.collision.IBroadPhase"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* This supports body activation/deactivation.</haxe_doc>
		</destroyProxy>
		<createProxy public="1" set="method" line="315">
			<f a="broadPhase:xf">
				<c path="box2D.collision.IBroadPhase"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* This supports body activation/deactivation.</haxe_doc>
		</createProxy>
		<destroy public="1" set="method" line="303">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* the destructor cannot access the allocator (no destructor arguments allowed by C++).
	 *  We need separation create/destroy functions from the constructor/destructor because</haxe_doc>
		</destroy>
		<create public="1" set="method" line="281">
			<f a="body:xf:def">
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.common.math.B2Transform"/>
				<c path="box2D.dynamics.B2FixtureDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* the destructor cannot access the allocator (no destructor arguments allowed by C++).
	 *  We need separation create/destroy functions from the constructor/destructor because</haxe_doc>
		</create>
		<getAABB public="1" set="method" line="255">
			<f a=""><c path="box2D.collision.B2AABB"/></f>
			<haxe_doc>* Get the fixture's AABB. This AABB may be enlarge and/or stale.
	 * If you need a more accurate AABB, compute it using the shape and
	 * the body transform.
	 * @return</haxe_doc>
		</getAABB>
		<setRestitution public="1" set="method" line="244">
			<f a="restitution">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Get the coefficient of restitution.</haxe_doc>
		</setRestitution>
		<getRestitution public="1" set="method" line="236">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the coefficient of restitution.</haxe_doc>
		</getRestitution>
		<setFriction public="1" set="method" line="228">
			<f a="friction">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the coefficient of friction.</haxe_doc>
		</setFriction>
		<getFriction public="1" set="method" line="220">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the coefficient of friction.</haxe_doc>
		</getFriction>
		<getDensity public="1" set="method" line="213">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the density of this fixture.
	 * @return density</haxe_doc>
		</getDensity>
		<setDensity public="1" set="method" line="204">
			<f a="density">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the density of this fixture. This will _not_ automatically adjust the mass
	 * of the body. You must call b2Body::ResetMassData to update the body's mass.
	 * @param	density</haxe_doc>
		</setDensity>
		<getMassData public="1" set="method" line="189">
			<f a="?massData">
				<c path="box2D.collision.shapes.B2MassData"/>
				<c path="box2D.collision.shapes.B2MassData"/>
			</f>
			<haxe_doc>* Get the mass data for this fixture. The mass data is based on the density and
	 * the shape. The rotational inertia is about the shape's origin. This operation may be expensive
	 * @param massData - this is a reference to a valid massData, if it is null a new B2MassData is allocated and then returned
	 * @note if the input is null then you must get the return value.</haxe_doc>
		</getMassData>
		<rayCast public="1" set="method" line="178">
			<f a="output:input">
				<c path="box2D.collision.B2RayCastOutput"/>
				<c path="box2D.collision.B2RayCastInput"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Perform a ray cast against this shape.
	 * @param output the ray-cast results.
	 * @param input the ray-cast input parameters.</haxe_doc>
		</rayCast>
		<testPoint public="1" set="method" line="168">
			<f a="p">
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Test a point for containment in this fixture.
	 * @param xf the shape world transform.
	 * @param p a point in world coordinates.</haxe_doc>
		</testPoint>
		<SetUserData public="1" set="method" line="158">
			<f a="data">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the user data. Use this to store your application specific data.</haxe_doc>
		</SetUserData>
		<getUserData public="1" set="method" line="150">
			<f a=""><d/></f>
			<haxe_doc>* Get the user data that was assigned in the fixture definition. Use this to
	 * store your application specific data.</haxe_doc>
		</getUserData>
		<getNext public="1" set="method" line="141">
			<f a=""><c path="box2D.dynamics.B2Fixture"/></f>
			<haxe_doc>* Get the next fixture in the parent body's fixture list.
	 * @return the next shape.</haxe_doc>
		</getNext>
		<getBody public="1" set="method" line="132">
			<f a=""><c path="box2D.dynamics.B2Body"/></f>
			<haxe_doc>* Get the parent body of this fixture. This is NULL if the fixture is not attached.
	 * @return the parent body.</haxe_doc>
		</getBody>
		<getFilterData public="1" set="method" line="123">
			<f a=""><c path="box2D.dynamics.B2FilterData"/></f>
			<haxe_doc>* Get the contact filtering data.</haxe_doc>
		</getFilterData>
		<setFilterData public="1" set="method" line="101">
			<f a="filter">
				<c path="box2D.dynamics.B2FilterData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the contact filtering data. This will not update contacts until the next time
	 * step when either parent body is active and awake.</haxe_doc>
		</setFilterData>
		<isSensor public="1" set="method" line="92">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is this fixture a sensor (non-solid)?
	 * @return the true if the shape is a sensor.</haxe_doc>
		</isSensor>
		<setSensor public="1" set="method" line="65">
			<f a="sensor">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set if this fixture is a sensor.</haxe_doc>
		</setSensor>
		<getShape public="1" set="method" line="57">
			<f a=""><c path="box2D.collision.shapes.B2Shape"/></f>
			<haxe_doc>* Get the child shape. You can modify the child shape, however you should not change the
	 * number of vertices because this will crash some collision caching mechanisms.</haxe_doc>
		</getShape>
		<getType public="1" set="method" line="48">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the type of the child shape. You can use this to down cast to the concrete shape.
	 * @return the shape type.</haxe_doc>
		</getType>
		<new public="1" set="method" line="262">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</new>
		<haxe_doc>* A fixture is used to attach a shape to a body for collision detection. A fixture
 * inherits its transform from its parent. Fixtures hold additional non-geometric data
 * such as friction, collision filters, etc.
 * Fixtures are created via b2Body::CreateFixture.
 * @warning you cannot reuse fixtures.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2FixtureDef" params="" file="../../lib/box2D/dynamics/B2FixtureDef.hx">
		<filter public="1">
			<c path="box2D.dynamics.B2FilterData"/>
			<haxe_doc>* Contact filtering data.</haxe_doc>
		</filter>
		<isSensor public="1">
			<e path="Bool"/>
			<haxe_doc>* A sensor shape collects contact information but never generates a collision
	 * response.</haxe_doc>
		</isSensor>
		<density public="1">
			<c path="Float"/>
			<haxe_doc>* The density, usually in kg/m^2.</haxe_doc>
		</density>
		<restitution public="1">
			<c path="Float"/>
			<haxe_doc>* The restitution (elasticity) usually in the range [0,1].</haxe_doc>
		</restitution>
		<friction public="1">
			<c path="Float"/>
			<haxe_doc>* The friction coefficient, usually in the range [0,1].</haxe_doc>
		</friction>
		<userData public="1">
			<d/>
			<haxe_doc>* Use this to store application specific fixture data.</haxe_doc>
		</userData>
		<shape public="1">
			<c path="box2D.collision.shapes.B2Shape"/>
			<haxe_doc>* The shape, this must be set. The shape will be cloned, so you
	 * can create the shape on the stack.</haxe_doc>
		</shape>
		<new public="1" set="method" line="34">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* The constructor sets the default fixture definition values.</haxe_doc>
		</new>
		<haxe_doc>* A fixture definition is used to create a fixture. This class defines an
 * abstract fixture definition. You can reuse fixture definitions safely.</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2Island" params="" file="../../lib/box2D/dynamics/B2Island.hx">
		<s_impulse line="443" static="1"><c path="box2D.dynamics.B2ContactImpulse"/></s_impulse>
		<m_jointCapacity public="1"><c path="Int"/></m_jointCapacity>
		<m_contactCapacity public="1"><c path="Int"/></m_contactCapacity>
		<m_bodyCapacity><c path="Int"/></m_bodyCapacity>
		<m_contactCount public="1"><c path="Int"/></m_contactCount>
		<m_jointCount public="1"><c path="Int"/></m_jointCount>
		<m_bodyCount public="1"><c path="Int"/></m_bodyCount>
		<m_joints public="1"><c path="Array"><c path="box2D.dynamics.joints.B2Joint"/></c></m_joints>
		<m_contacts public="1"><c path="Array"><c path="box2D.dynamics.contacts.B2Contact"/></c></m_contacts>
		<m_bodies public="1"><c path="Array"><c path="box2D.dynamics.B2Body"/></c></m_bodies>
		<m_contactSolver><c path="box2D.dynamics.contacts.B2ContactSolver"/></m_contactSolver>
		<m_listener><c path="box2D.dynamics.B2ContactListener"/></m_listener>
		<m_allocator><d/></m_allocator>
		<addJoint public="1" set="method" line="479"><f a="joint">
	<c path="box2D.dynamics.joints.B2Joint"/>
	<e path="Void"/>
</f></addJoint>
		<addContact public="1" set="method" line="473"><f a="contact">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<e path="Void"/>
</f></addContact>
		<addBody public="1" set="method" line="466"><f a="body">
	<c path="box2D.dynamics.B2Body"/>
	<e path="Void"/>
</f></addBody>
		<report public="1" set="method" line="444"><f a="constraints">
	<c path="Array"><c path="box2D.dynamics.contacts.B2ContactConstraint"/></c>
	<e path="Void"/>
</f></report>
		<solveTOI public="1" set="method" line="344"><f a="subStep">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveTOI>
		<solve public="1" set="method" line="164"><f a="step:gravity:allowSleep">
	<c path="box2D.dynamics.B2TimeStep"/>
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></solve>
		<clear public="1" set="method" line="157"><f a=""><e path="Void"/></f></clear>
		<initialize public="1" set="method" line="124"><f a="bodyCapacity:contactCapacity:jointCapacity:allocator:listener:contactSolver">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<d/>
	<c path="box2D.dynamics.B2ContactListener"/>
	<c path="box2D.dynamics.contacts.B2ContactSolver"/>
	<e path="Void"/>
</f></initialize>
		<new public="1" set="method" line="117"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2TimeStep" params="" file="../../lib/box2D/dynamics/B2TimeStep.hx">
		<warmStarting public="1"><e path="Bool"/></warmStarting>
		<positionIterations public="1"><c path="Int"/></positionIterations>
		<velocityIterations public="1"><c path="Int"/></velocityIterations>
		<dtRatio public="1"><c path="Float"/></dtRatio>
		<inv_dt public="1"><c path="Float"/></inv_dt>
		<dt public="1"><c path="Float"/></dt>
		<set public="1" set="method" line="28"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></set>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.B2World" params="" file="../../lib/box2D/dynamics/B2World.hx">
		<s_timestep2 line="565" static="1"><c path="box2D.dynamics.B2TimeStep"/></s_timestep2>
		<s_xf line="636" static="1"><c path="box2D.common.math.B2Transform"/></s_xf>
		<s_backupA line="1176" static="1"><c path="box2D.common.math.B2Sweep"/></s_backupA>
		<s_backupB line="1177" static="1"><c path="box2D.common.math.B2Sweep"/></s_backupB>
		<s_timestep line="1178" static="1"><c path="box2D.dynamics.B2TimeStep"/></s_timestep>
		<s_queue line="1179" static="1"><c path="Array"><c path="box2D.dynamics.B2Body"/></c></s_queue>
		<s_jointColor line="1553" static="1"><c path="box2D.common.B2Color"/></s_jointColor>
		<m_warmStarting static="1"><e path="Bool"/></m_warmStarting>
		<m_continuousPhysics static="1"><e path="Bool"/></m_continuousPhysics>
		<e_newFixture public="1" line="1677" static="1"><c path="Int"/></e_newFixture>
		<e_locked public="1" line="1678" static="1"><c path="Int"/></e_locked>
		<m_inv_dt0><c path="Float"/></m_inv_dt0>
		<m_debugDraw><c path="box2D.dynamics.B2DebugDraw"/></m_debugDraw>
		<m_destructionListener><c path="box2D.dynamics.B2DestructionListener"/></m_destructionListener>
		<m_groundBody public="1"><c path="box2D.dynamics.B2Body"/></m_groundBody>
		<m_allowSleep><e path="Bool"/></m_allowSleep>
		<m_gravity><c path="box2D.common.math.B2Vec2"/></m_gravity>
		<m_controllerCount><c path="Int"/></m_controllerCount>
		<m_controllerList><c path="box2D.dynamics.controllers.B2Controller"/></m_controllerList>
		<m_jointCount><c path="Int"/></m_jointCount>
		<m_contactCount public="1"><c path="Int"/></m_contactCount>
		<m_bodyCount><c path="Int"/></m_bodyCount>
		<m_contactList public="1"><c path="box2D.dynamics.contacts.B2Contact"/></m_contactList>
		<m_jointList><c path="box2D.dynamics.joints.B2Joint"/></m_jointList>
		<m_bodyList public="1"><c path="box2D.dynamics.B2Body"/></m_bodyList>
		<m_island><c path="box2D.dynamics.B2Island"/></m_island>
		<m_contactSolver><c path="box2D.dynamics.contacts.B2ContactSolver"/></m_contactSolver>
		<m_contactManager public="1"><c path="box2D.dynamics.B2ContactManager"/></m_contactManager>
		<m_flags public="1"><c path="Int"/></m_flags>
		<drawShape public="1" set="method" line="1596"><f a="shape:xf:color">
	<c path="box2D.collision.shapes.B2Shape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.common.B2Color"/>
	<e path="Void"/>
</f></drawShape>
		<drawJoint public="1" set="method" line="1555"><f a="joint">
	<c path="box2D.dynamics.joints.B2Joint"/>
	<e path="Void"/>
</f></drawJoint>
		<solveTOI public="1" set="method" line="1181"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveTOI>
		<solve public="1" set="method" line="966"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solve>
		<s_stack><c path="Array"><c path="box2D.dynamics.B2Body"/></c></s_stack>
		<isLocked public="1" set="method" line="956">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is the world locked (in the middle of a time step).</haxe_doc>
		</isLocked>
		<getContactList public="1" set="method" line="948">
			<f a=""><c path="box2D.dynamics.contacts.B2Contact"/></f>
			<haxe_doc>* Get the world contact list. With the returned contact, use b2Contact::GetNext to get
	 * the next contact in the world list. A NULL contact indicates the end of the list.
	 * @return the head of the world contact list.
	 * @warning contacts are</haxe_doc>
		</getContactList>
		<getJointList public="1" set="method" line="938">
			<f a=""><c path="box2D.dynamics.joints.B2Joint"/></f>
			<haxe_doc>* Get the world joint list. With the returned joint, use b2Joint::GetNext to get
	* the next joint in the world list. A NULL joint indicates the end of the list.
	* @return the head of the world joint list.</haxe_doc>
		</getJointList>
		<getBodyList public="1" set="method" line="929">
			<f a=""><c path="box2D.dynamics.B2Body"/></f>
			<haxe_doc>* Get the world body list. With the returned body, use b2Body::GetNext to get
	* the next body in the world list. A NULL body indicates the end of the list.
	* @return the head of the world body list.</haxe_doc>
		</getBodyList>
		<rayCastAll public="1" set="method" line="912"><f a="point1:point2">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Array"><c path="box2D.dynamics.B2Fixture"/></c>
</f></rayCastAll>
		<rayCastOne public="1" set="method" line="900"><f a="point1:point2">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.dynamics.B2Fixture"/>
</f></rayCastOne>
		<rayCast public="1" set="method" line="877">
			<f a="callbackMethod:point1:point2">
				<f a=":::">
					<c path="box2D.dynamics.B2Fixture"/>
					<c path="box2D.common.math.B2Vec2"/>
					<c path="box2D.common.math.B2Vec2"/>
					<c path="Float"/>
					<d/>
				</f>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Ray-cast the world for all fixtures in the path of the ray. Your callback
	 * Controls whether you get the closest point, any point, or n-points
	 * The ray-cast ignores shapes that contain the starting point
	 * @param callback A callback function which must be of signature:
	 * <code>function Callback(fixture:B2Fixture,    // The fixture hit by the ray
	 * point:B2Vec2,         // The point of initial intersection
	 * normal:B2Vec2,        // The normal vector at the point of intersection
	 * fraction:Float       // The fractional length along the ray of the intersection
	 * ):Float
	 * </code>
	 * Callback should return the new length of the ray as a fraction of the original length.
	 * By returning 0, you immediately terminate.
	 * By returning 1, you continue wiht the original ray.
	 * By returning the current fraction, you proceed to find the closest point.
	 * @param point1 the ray starting point
	 * @param point2 the ray ending point]]></haxe_doc>
		</rayCast>
		<queryPoint public="1" set="method" line="842">
			<f a="callbackMethod:p">
				<f a="">
					<c path="box2D.dynamics.B2Fixture"/>
					<d/>
				</f>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Query the world for all fixtures that contain a point.
	 * @param callback a user implemented callback class. It should match signature
	 * <code>function Callback(fixture:B2Fixture):Bool</code>
	 * Return true to continue to the next fixture.
	 * @asonly]]></haxe_doc>
		</queryPoint>
		<queryShape public="1" set="method" line="815">
			<f a="callbackMethod:shape:?transform">
				<f a="">
					<c path="box2D.dynamics.B2Fixture"/>
					<d/>
				</f>
				<c path="box2D.collision.shapes.B2Shape"/>
				<c path="box2D.common.math.B2Transform"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Query the world for all fixtures that precisely overlap the
	 * provided transformed shape.
	 * @param callback a user implemented callback class. It should match signature
	 * <code>function Callback(fixture:B2Fixture):Bool</code>
	 * Return true to continue to the next fixture.
	 * @asonly]]></haxe_doc>
		</queryShape>
		<queryAABB public="1" set="method" line="798">
			<f a="callbackMethod:aabb">
				<f a="">
					<c path="box2D.dynamics.B2Fixture"/>
					<d/>
				</f>
				<c path="box2D.collision.B2AABB"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Query the world for all fixtures that potentially overlap the
	 * provided AABB.
	 * @param callback a user implemented callback class. It should match signature
	 * <code>function Callback(fixture:B2Fixture):Bool</code>
	 * Return true to continue to the next fixture.
	 * @param aabb the query box.]]></haxe_doc>
		</queryAABB>
		<drawDebugData public="1" set="method" line="640">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Call this to draw shapes and other debug draw data.</haxe_doc>
		</drawDebugData>
		<clearForces public="1" set="method" line="625">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Call this after you are done with time steps to clear the forces. You normally
	 * call this after each call to Step, unless you are performing sub-steps.</haxe_doc>
		</clearForces>
		<step public="1" set="method" line="573">
			<f a="dt:velocityIterations:positionIterations">
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Take a time step. This performs collision detection, integration,
	* and constraint solution.
	* @param timeStep the amount of time to simulate, this should not vary.
	* @param velocityIterations for the velocity constraint solver.
	* @param positionIterations for the position constraint solver.</haxe_doc>
		</step>
		<getGroundBody public="1" set="method" line="561">
			<f a=""><c path="box2D.dynamics.B2Body"/></f>
			<haxe_doc>* The world provides a single static ground body with no collision shapes.
	* You can use this to simplify the creation of joints and static shapes.</haxe_doc>
		</getGroundBody>
		<getGravity public="1" set="method" line="553">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the global gravity vector.</haxe_doc>
		</getGravity>
		<setGravity public="1" set="method" line="545">
			<f a="gravity">
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Change the global gravity vector.</haxe_doc>
		</setGravity>
		<getContactCount public="1" set="method" line="537">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the number of contacts (each may have 0 or more contact points).</haxe_doc>
		</getContactCount>
		<getJointCount public="1" set="method" line="529">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the number of joints.</haxe_doc>
		</getJointCount>
		<getBodyCount public="1" set="method" line="521">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the number of bodies.</haxe_doc>
		</getBodyCount>
		<setContinuousPhysics public="1" set="method" line="516">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable continuous physics. For testing.</haxe_doc>
		</setContinuousPhysics>
		<setWarmStarting public="1" set="method" line="511">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable warm starting. For testing.</haxe_doc>
		</setWarmStarting>
		<destroyController public="1" set="method" line="495"><f a="controller">
	<c path="box2D.dynamics.controllers.B2Controller"/>
	<e path="Void"/>
</f></destroyController>
		<createController public="1" set="method" line="477"><f a="controller">
	<c path="box2D.dynamics.controllers.B2Controller"/>
	<c path="box2D.dynamics.controllers.B2Controller"/>
</f></createController>
		<removeController public="1" set="method" line="464"><f a="c">
	<c path="box2D.dynamics.controllers.B2Controller"/>
	<e path="Void"/>
</f></removeController>
		<addController public="1" set="method" line="451">
			<f a="c">
				<c path="box2D.dynamics.controllers.B2Controller"/>
				<c path="box2D.dynamics.controllers.B2Controller"/>
			</f>
			<haxe_doc>* Add a controller to the world list</haxe_doc>
		</addController>
		<destroyJoint public="1" set="method" line="356">
			<f a="j">
				<c path="box2D.dynamics.joints.B2Joint"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Destroy a joint. This may cause the connected bodies to begin colliding.
	* @warning This function is locked during callbacks.</haxe_doc>
		</destroyJoint>
		<createJoint public="1" set="method" line="295">
			<f a="def">
				<c path="box2D.dynamics.joints.B2JointDef"/>
				<c path="box2D.dynamics.joints.B2Joint"/>
			</f>
			<haxe_doc>* Create a joint to constrain bodies together. No reference to the definition
	* is retained. This may cause the connected bodies to cease colliding.
	* @warning This function is locked during callbacks.</haxe_doc>
		</createJoint>
		<destroyBody public="1" set="method" line="203">
			<f a="b">
				<c path="box2D.dynamics.B2Body"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Destroy a rigid body given a definition. No reference to the definition
	* is retained. This function is locked during callbacks.
	* @warning This automatically deletes all associated shapes and joints.
	* @warning This function is locked during callbacks.</haxe_doc>
		</destroyBody>
		<createBody public="1" set="method" line="172">
			<f a="def">
				<c path="box2D.dynamics.B2BodyDef"/>
				<c path="box2D.dynamics.B2Body"/>
			</f>
			<haxe_doc>* Create a rigid body given a definition. No reference to the definition
	* is retained.
	* @warning This function is locked during callbacks.</haxe_doc>
		</createBody>
		<getProxyCount public="1" set="method" line="162">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the number of broad-phase proxies.</haxe_doc>
		</getProxyCount>
		<validate public="1" set="method" line="154">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Perform validation of internal data structures.</haxe_doc>
		</validate>
		<setBroadPhase public="1" set="method" line="135">
			<f a="broadPhase">
				<c path="box2D.collision.IBroadPhase"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Use the given object as a broadphase.
	 * The old broadphase will not be cleanly emptied.
	 * @warning It is not recommended you call this except immediately after constructing the world.
	 * @warning This function is locked during callbacks.</haxe_doc>
		</setBroadPhase>
		<setDebugDraw public="1" set="method" line="125">
			<f a="debugDraw">
				<c path="box2D.dynamics.B2DebugDraw"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Register a routine for debug drawing. The debug draw functions are called
	* inside the b2World::Step method, so make sure your renderer is ready to
	* consume draw commands when you call Step().</haxe_doc>
		</setDebugDraw>
		<setContactListener public="1" set="method" line="116">
			<f a="listener">
				<c path="box2D.dynamics.B2ContactListener"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Register a contact event listener</haxe_doc>
		</setContactListener>
		<setContactFilter public="1" set="method" line="109">
			<f a="filter">
				<c path="box2D.dynamics.B2ContactFilter"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Register a contact filter to provide specific control over collision.
	* Otherwise the default filter is used (b2_defaultFilter).</haxe_doc>
		</setContactFilter>
		<setDestructionListener public="1" set="method" line="101">
			<f a="listener">
				<c path="box2D.dynamics.B2DestructionListener"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Register a destruction listener.</haxe_doc>
		</setDestructionListener>
		<new public="1" set="method" line="59">
			<f a="gravity:doSleep">
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param gravity the world gravity vector.
	* @param doSleep improve performance by not simulating inactive bodies.</haxe_doc>
		</new>
		<haxe_doc>* The world class manages all physics entities, dynamic simulation,
* and asynchronous queries.</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2Contact" params="" file="../../lib/box2D/dynamics/contacts/B2Contact.hx">
		<e_sensorFlag public="1" line="169" static="1"><c path="Int"/></e_sensorFlag>
		<e_continuousFlag public="1" line="171" static="1"><c path="Int"/></e_continuousFlag>
		<e_islandFlag public="1" line="173" static="1"><c path="Int"/></e_islandFlag>
		<e_toiFlag public="1" line="175" static="1"><c path="Int"/></e_toiFlag>
		<e_touchingFlag public="1" line="177" static="1"><c path="Int"/></e_touchingFlag>
		<e_enabledFlag public="1" line="179" static="1"><c path="Int"/></e_enabledFlag>
		<e_filterFlag public="1" line="181" static="1"><c path="Int"/></e_filterFlag>
		<s_input line="351" static="1"><c path="box2D.collision.B2TOIInput"/></s_input>
		<m_toi public="1"><c path="Float"/></m_toi>
		<m_oldManifold public="1"><c path="box2D.collision.B2Manifold"/></m_oldManifold>
		<m_manifold public="1"><c path="box2D.collision.B2Manifold"/></m_manifold>
		<m_fixtureB public="1"><c path="box2D.dynamics.B2Fixture"/></m_fixtureB>
		<m_fixtureA public="1"><c path="box2D.dynamics.B2Fixture"/></m_fixtureA>
		<m_nodeB public="1"><c path="box2D.dynamics.contacts.B2ContactEdge"/></m_nodeB>
		<m_nodeA public="1"><c path="box2D.dynamics.contacts.B2ContactEdge"/></m_nodeA>
		<m_next public="1"><c path="box2D.dynamics.contacts.B2Contact"/></m_next>
		<m_prev public="1"><c path="box2D.dynamics.contacts.B2Contact"/></m_prev>
		<m_flags public="1"><c path="Int"/></m_flags>
		<computeTOI public="1" set="method" line="352"><f a="sweepA:sweepB">
	<c path="box2D.common.math.B2Sweep"/>
	<c path="box2D.common.math.B2Sweep"/>
	<c path="Float"/>
</f></computeTOI>
		<evaluate public="1" set="method" line="349"><f a=""><e path="Void"/></f></evaluate>
		<update public="1" set="method" line="237"><f a="listener">
	<c path="box2D.dynamics.B2ContactListener"/>
	<e path="Void"/>
</f></update>
		<reset public="1" set="method" line="195">
			<f a="?fixtureA:?fixtureB">
				<c path="box2D.dynamics.B2Fixture"/>
				<c path="box2D.dynamics.B2Fixture"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</reset>
		<flagForFiltering public="1" set="method" line="158">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Flag this contact for filtering. Filtering will occur the next time step.</haxe_doc>
		</flagForFiltering>
		<getFixtureB public="1" set="method" line="150">
			<f a=""><c path="box2D.dynamics.B2Fixture"/></f>
			<haxe_doc>* Get the second fixture in this contact.</haxe_doc>
		</getFixtureB>
		<getFixtureA public="1" set="method" line="142">
			<f a=""><c path="box2D.dynamics.B2Fixture"/></f>
			<haxe_doc>* Get the first fixture in this contact.</haxe_doc>
		</getFixtureA>
		<getNext public="1" set="method" line="135">
			<f a=""><c path="box2D.dynamics.contacts.B2Contact"/></f>
			<haxe_doc>* Get the next contact in the world's contact list.</haxe_doc>
		</getNext>
		<isEnabled public="1" set="method" line="128">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Has this contact been disabled?
	 * @return</haxe_doc>
		</isEnabled>
		<setEnabled public="1" set="method" line="113">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable this contact. This can be used inside the pre-solve
	 * contact listener. The contact is only disabled for the current
	 * time step (or sub-step in continuous collision).</haxe_doc>
		</setEnabled>
		<isSensor public="1" set="method" line="104">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is this contact a sensor?</haxe_doc>
		</isSensor>
		<setSensor public="1" set="method" line="90">
			<f a="sensor">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Change this to be a sensor or-non-sensor contact.</haxe_doc>
		</setSensor>
		<isContinuous public="1" set="method" line="82">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Does this contact generate TOI events for continuous simulation</haxe_doc>
		</isContinuous>
		<isTouching public="1" set="method" line="74">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is this contact touching.</haxe_doc>
		</isTouching>
		<getWorldManifold public="1" set="method" line="61">
			<f a="worldManifold">
				<c path="box2D.collision.B2WorldManifold"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Get the world manifold</haxe_doc>
		</getWorldManifold>
		<getManifold public="1" set="method" line="53">
			<f a=""><c path="box2D.collision.B2Manifold"/></f>
			<haxe_doc>* Get the contact manifold. Do not modify the manifold unless you understand the
	 * internals of Box2D</haxe_doc>
		</getManifold>
		<new public="1" set="method" line="183"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* The class manages contact between two shapes. A contact exists for each overlapping
* AABB in the broad-phase (except if filtered). Therefore a contact object may exist
* that has no contact points.</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2CircleContact" params="" file="../../lib/box2D/dynamics/contacts/B2CircleContact.hx">
		<extends path="box2D.dynamics.contacts.B2Contact"/>
		<create public="1" set="method" line="33" static="1"><f a="allocator">
	<d/>
	<c path="box2D.dynamics.contacts.B2Contact"/>
</f></create>
		<destroy public="1" set="method" line="36" static="1"><f a="contact:allocator">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<d/>
	<e path="Void"/>
</f></destroy>
		<evaluate public="1" set="method" line="47" override="1"><f a=""><e path="Void"/></f></evaluate>
		<reset public="1" set="method" line="40" override="1"><f a="?fixtureA:?fixtureB">
	<c path="box2D.dynamics.B2Fixture"/>
	<c path="box2D.dynamics.B2Fixture"/>
	<e path="Void"/>
</f></reset>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2ContactConstraint" params="" file="../../lib/box2D/dynamics/contacts/B2ContactConstraint.hx">
		<manifold public="1"><c path="box2D.collision.B2Manifold"/></manifold>
		<pointCount public="1"><c path="Int"/></pointCount>
		<restitution public="1"><c path="Float"/></restitution>
		<friction public="1"><c path="Float"/></friction>
		<radius public="1"><c path="Float"/></radius>
		<type public="1"><c path="Int"/></type>
		<bodyB public="1"><c path="box2D.dynamics.B2Body"/></bodyB>
		<bodyA public="1"><c path="box2D.dynamics.B2Body"/></bodyA>
		<K public="1"><c path="box2D.common.math.B2Mat22"/></K>
		<normalMass public="1"><c path="box2D.common.math.B2Mat22"/></normalMass>
		<normal public="1"><c path="box2D.common.math.B2Vec2"/></normal>
		<localPoint public="1"><c path="box2D.common.math.B2Vec2"/></localPoint>
		<localPlaneNormal public="1"><c path="box2D.common.math.B2Vec2"/></localPlaneNormal>
		<points public="1"><c path="Array"><c path="box2D.dynamics.contacts.B2ContactConstraintPoint"/></c></points>
		<new public="1" set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2ContactConstraintPoint" params="" file="../../lib/box2D/dynamics/contacts/B2ContactConstraintPoint.hx">
		<velocityBias public="1"><c path="Float"/></velocityBias>
		<equalizedMass public="1"><c path="Float"/></equalizedMass>
		<tangentMass public="1"><c path="Float"/></tangentMass>
		<normalMass public="1"><c path="Float"/></normalMass>
		<tangentImpulse public="1"><c path="Float"/></tangentImpulse>
		<normalImpulse public="1"><c path="Float"/></normalImpulse>
		<rB public="1"><c path="box2D.common.math.B2Vec2"/></rB>
		<rA public="1"><c path="box2D.common.math.B2Vec2"/></rA>
		<localPoint public="1"><c path="box2D.common.math.B2Vec2"/></localPoint>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2ContactEdge" params="" file="../../lib/box2D/dynamics/contacts/B2ContactEdge.hx">
		<next public="1"><c path="box2D.dynamics.contacts.B2ContactEdge"/></next>
		<prev public="1"><c path="box2D.dynamics.contacts.B2ContactEdge"/></prev>
		<contact public="1"><c path="box2D.dynamics.contacts.B2Contact"/></contact>
		<other public="1"><c path="box2D.dynamics.B2Body"/></other>
		<new public="1" set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* A contact edge is used to connect bodies and contacts together
* in a contact graph where each body is a node and each contact
* is an edge. A contact edge belongs to a doubly linked list
* maintained in each attached body. Each contact has two contact
* nodes, one for each attached body.</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2ContactFactory" params="" file="../../lib/box2D/dynamics/contacts/B2ContactFactory.hx">
		<m_allocator><d/></m_allocator>
		<m_registers><c path="Array"><c path="Array"><c path="box2D.dynamics.contacts.B2ContactRegister"/></c></c></m_registers>
		<destroy public="1" set="method" line="117"><f a="contact">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<e path="Void"/>
</f></destroy>
		<create public="1" set="method" line="75"><f a="fixtureA:fixtureB">
	<c path="box2D.dynamics.B2Fixture"/>
	<c path="box2D.dynamics.B2Fixture"/>
	<c path="box2D.dynamics.contacts.B2Contact"/>
</f></create>
		<initializeRegisters public="1" set="method" line="59"><f a=""><e path="Void"/></f></initializeRegisters>
		<addType public="1" set="method" line="43"><f a="createFcn:destroyFcn:type1:type2">
	<d/>
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addType>
		<new public="1" set="method" line="37"><f a="allocator">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* This class manages creation and destruction of b2Contact objects.
 * @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2ContactRegister" params="" file="../../lib/box2D/dynamics/contacts/B2ContactRegister.hx">
		<poolCount public="1"><c path="Int"/></poolCount>
		<pool public="1"><c path="box2D.dynamics.contacts.B2Contact"/></pool>
		<primary public="1"><e path="Bool"/></primary>
		<destroyFcn public="1"><d/></destroyFcn>
		<createFcn public="1"><d/></createFcn>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2PositionSolverManifold" params="" file="../../lib/box2D/dynamics/contacts/B2PositionSolverManifold.hx">
		<circlePointA line="42" static="1"><c path="box2D.common.math.B2Vec2"/></circlePointA>
		<circlePointB line="43" static="1"><c path="box2D.common.math.B2Vec2"/></circlePointB>
		<m_separations public="1"><c path="Array"><c path="Float"/></c></m_separations>
		<m_points public="1"><c path="Array"><c path="box2D.common.math.B2Vec2"/></c></m_points>
		<m_normal public="1"><c path="box2D.common.math.B2Vec2"/></m_normal>
		<initialize public="1" set="method" line="44"><f a="cc">
	<c path="box2D.dynamics.contacts.B2ContactConstraint"/>
	<e path="Void"/>
</f></initialize>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="box2D.dynamics.contacts.B2ContactSolver" params="" file="../../lib/box2D/dynamics/contacts/B2ContactSolver.hx">
		<staticFix line="40" static="1"><c path="Int"/></staticFix>
		<s_worldManifold line="48" static="1"><c path="box2D.collision.B2WorldManifold"/></s_worldManifold>
		<s_psm line="862" static="1"><c path="box2D.dynamics.contacts.B2PositionSolverManifold"/></s_psm>
		<m_constraintCount><c path="Int"/></m_constraintCount>
		<m_constraints public="1"><c path="Array"><c path="box2D.dynamics.contacts.B2ContactConstraint"/></c></m_constraints>
		<m_allocator><d/></m_allocator>
		<m_step><c path="box2D.dynamics.B2TimeStep"/></m_step>
		<solvePositionConstraints public="1" set="method" line="863"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<finalizeVelocityConstraints public="1" set="method" line="741"><f a=""><e path="Void"/></f></finalizeVelocityConstraints>
		<solveVelocityConstraints public="1" set="method" line="287"><f a=""><e path="Void"/></f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="224"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<initialize public="1" set="method" line="49"><f a="step:contacts:contactCount:allocator">
	<c path="box2D.dynamics.B2TimeStep"/>
	<c path="Array"><c path="box2D.dynamics.contacts.B2Contact"/></c>
	<c path="Int"/>
	<d/>
	<e path="Void"/>
</f></initialize>
		<new public="1" set="method" line="42"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2EdgeAndCircleContact" params="" file="../../lib/box2D/dynamics/contacts/B2EdgeAndCircleContact.hx">
		<extends path="box2D.dynamics.contacts.B2Contact"/>
		<create public="1" set="method" line="36" static="1"><f a="allocator">
	<d/>
	<c path="box2D.dynamics.contacts.B2Contact"/>
</f></create>
		<destroy public="1" set="method" line="39" static="1"><f a="contact:allocator">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<d/>
	<e path="Void"/>
</f></destroy>
		<b2CollideEdgeAndCircle set="method" line="58"><f a="manifold:edge:xf1:circle:xf2">
	<c path="box2D.collision.B2Manifold"/>
	<c path="box2D.collision.shapes.B2EdgeShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.shapes.B2CircleShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></b2CollideEdgeAndCircle>
		<evaluate public="1" set="method" line="50" override="1"><f a=""><e path="Void"/></f></evaluate>
		<reset public="1" set="method" line="43" override="1"><f a="?fixtureA:?fixtureB">
	<c path="box2D.dynamics.B2Fixture"/>
	<c path="box2D.dynamics.B2Fixture"/>
	<e path="Void"/>
</f></reset>
		<new public="1" set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2PolyAndCircleContact" params="" file="../../lib/box2D/dynamics/contacts/B2PolyAndCircleContact.hx">
		<extends path="box2D.dynamics.contacts.B2Contact"/>
		<create public="1" set="method" line="36" static="1"><f a="allocator">
	<d/>
	<c path="box2D.dynamics.contacts.B2Contact"/>
</f></create>
		<destroy public="1" set="method" line="39" static="1"><f a="contact:allocator">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<d/>
	<e path="Void"/>
</f></destroy>
		<evaluate public="1" set="method" line="49" override="1"><f a=""><e path="Void"/></f></evaluate>
		<reset public="1" set="method" line="42" override="1"><f a="?fixtureA:?fixtureB">
	<c path="box2D.dynamics.B2Fixture"/>
	<c path="box2D.dynamics.B2Fixture"/>
	<e path="Void"/>
</f></reset>
		<new public="1" set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2PolyAndEdgeContact" params="" file="../../lib/box2D/dynamics/contacts/B2PolyAndEdgeContact.hx">
		<extends path="box2D.dynamics.contacts.B2Contact"/>
		<create public="1" set="method" line="37" static="1"><f a="allocator">
	<d/>
	<c path="box2D.dynamics.contacts.B2Contact"/>
</f></create>
		<destroy public="1" set="method" line="40" static="1"><f a="contact:allocator">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<d/>
	<e path="Void"/>
</f></destroy>
		<b2CollidePolyAndEdge set="method" line="59"><f a="manifold:polygon:xf1:edge:xf2">
	<c path="box2D.collision.B2Manifold"/>
	<c path="box2D.collision.shapes.B2PolygonShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<c path="box2D.collision.shapes.B2EdgeShape"/>
	<c path="box2D.common.math.B2Transform"/>
	<e path="Void"/>
</f></b2CollidePolyAndEdge>
		<evaluate public="1" set="method" line="50" override="1"><f a=""><e path="Void"/></f></evaluate>
		<reset public="1" set="method" line="43" override="1"><f a="?fixtureA:?fixtureB">
	<c path="box2D.dynamics.B2Fixture"/>
	<c path="box2D.dynamics.B2Fixture"/>
	<e path="Void"/>
</f></reset>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.contacts.B2PolygonContact" params="" file="../../lib/box2D/dynamics/contacts/B2PolygonContact.hx">
		<extends path="box2D.dynamics.contacts.B2Contact"/>
		<create public="1" set="method" line="33" static="1"><f a="allocator">
	<d/>
	<c path="box2D.dynamics.contacts.B2Contact"/>
</f></create>
		<destroy public="1" set="method" line="37" static="1"><f a="contact:allocator">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<d/>
	<e path="Void"/>
</f></destroy>
		<evaluate public="1" set="method" line="49" override="1"><f a=""><e path="Void"/></f></evaluate>
		<reset public="1" set="method" line="42" override="1"><f a="?fixtureA:?fixtureB">
	<c path="box2D.dynamics.B2Fixture"/>
	<c path="box2D.dynamics.B2Fixture"/>
	<e path="Void"/>
</f></reset>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.controllers.B2Controller" params="" file="../../lib/box2D/dynamics/controllers/B2Controller.hx">
		<m_world public="1"><c path="box2D.dynamics.B2World"/></m_world>
		<m_bodyCount public="1"><c path="Int"/></m_bodyCount>
		<m_bodyList public="1"><c path="box2D.dynamics.controllers.B2ControllerEdge"/></m_bodyList>
		<m_prev public="1"><c path="box2D.dynamics.controllers.B2Controller"/></m_prev>
		<m_next public="1"><c path="box2D.dynamics.controllers.B2Controller"/></m_next>
		<getBodyList public="1" set="method" line="95"><f a=""><c path="box2D.dynamics.controllers.B2ControllerEdge"/></f></getBodyList>
		<getWorld public="1" set="method" line="93"><f a=""><c path="box2D.dynamics.B2World"/></f></getWorld>
		<getNext public="1" set="method" line="92"><f a=""><c path="box2D.dynamics.controllers.B2Controller"/></f></getNext>
		<clear public="1" set="method" line="86"><f a=""><e path="Void"/></f></clear>
		<removeBody public="1" set="method" line="59"><f a="body">
	<c path="box2D.dynamics.B2Body"/>
	<e path="Void"/>
</f></removeBody>
		<addBody public="1" set="method" line="38"><f a="body">
	<c path="box2D.dynamics.B2Body"/>
	<e path="Void"/>
</f></addBody>
		<draw public="1" set="method" line="36"><f a="debugDraw">
	<c path="box2D.dynamics.B2DebugDraw"/>
	<e path="Void"/>
</f></draw>
		<step public="1" set="method" line="34"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></step>
		<haxe_doc>* Base class for controllers. Controllers are a convience for encapsulating common
 * per-step functionality.</haxe_doc>
	</class>
	<class path="box2D.dynamics.controllers.B2ControllerEdge" params="" file="../../lib/box2D/dynamics/controllers/B2ControllerEdge.hx">
		<nextController public="1">
			<c path="box2D.dynamics.controllers.B2ControllerEdge"/>
			<haxe_doc>the next controller edge in the body's controller list</haxe_doc>
		</nextController>
		<prevController public="1">
			<c path="box2D.dynamics.controllers.B2ControllerEdge"/>
			<haxe_doc>the previous controller edge in the body's controller list</haxe_doc>
		</prevController>
		<nextBody public="1">
			<c path="box2D.dynamics.controllers.B2ControllerEdge"/>
			<haxe_doc>the next controller edge in the controllers's body list</haxe_doc>
		</nextBody>
		<prevBody public="1">
			<c path="box2D.dynamics.controllers.B2ControllerEdge"/>
			<haxe_doc>the previous controller edge in the controllers's body list</haxe_doc>
		</prevBody>
		<body public="1">
			<c path="box2D.dynamics.B2Body"/>
			<haxe_doc>the body</haxe_doc>
		</body>
		<controller public="1">
			<c path="box2D.dynamics.controllers.B2Controller"/>
			<haxe_doc>provides quick access to other end of this edge</haxe_doc>
		</controller>
		<new public="1" set="method" line="7"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="box2D.dynamics.joints.B2Joint" params="" file="../../lib/box2D/dynamics/joints/B2Joint.hx">
		<create public="1" set="method" line="107" static="1"><f a="def:allocator">
	<c path="box2D.dynamics.joints.B2JointDef"/>
	<d/>
	<c path="box2D.dynamics.joints.B2Joint"/>
</f></create>
		<destroy public="1" set="method" line="173" static="1"><f a="joint:allocator">
	<c path="box2D.dynamics.joints.B2Joint"/>
	<d/>
	<e path="Void"/>
</f></destroy>
		<e_unknownJoint public="1" line="270" static="1"><c path="Int"/></e_unknownJoint>
		<e_revoluteJoint public="1" line="271" static="1"><c path="Int"/></e_revoluteJoint>
		<e_prismaticJoint public="1" line="272" static="1"><c path="Int"/></e_prismaticJoint>
		<e_distanceJoint public="1" line="273" static="1"><c path="Int"/></e_distanceJoint>
		<e_pulleyJoint public="1" line="274" static="1"><c path="Int"/></e_pulleyJoint>
		<e_mouseJoint public="1" line="275" static="1"><c path="Int"/></e_mouseJoint>
		<e_gearJoint public="1" line="276" static="1"><c path="Int"/></e_gearJoint>
		<e_lineJoint public="1" line="277" static="1"><c path="Int"/></e_lineJoint>
		<e_weldJoint public="1" line="278" static="1"><c path="Int"/></e_weldJoint>
		<e_frictionJoint public="1" line="279" static="1"><c path="Int"/></e_frictionJoint>
		<e_inactiveLimit public="1" line="282" static="1"><c path="Int"/></e_inactiveLimit>
		<e_atLowerLimit public="1" line="283" static="1"><c path="Int"/></e_atLowerLimit>
		<e_atUpperLimit public="1" line="284" static="1"><c path="Int"/></e_atUpperLimit>
		<e_equalLimits public="1" line="285" static="1"><c path="Int"/></e_equalLimits>
		<m_invIB public="1"><c path="Float"/></m_invIB>
		<m_invIA public="1"><c path="Float"/></m_invIA>
		<m_invMassB public="1"><c path="Float"/></m_invMassB>
		<m_invMassA public="1"><c path="Float"/></m_invMassA>
		<m_localCenterB public="1"><c path="box2D.common.math.B2Vec2"/></m_localCenterB>
		<m_localCenterA public="1"><c path="box2D.common.math.B2Vec2"/></m_localCenterA>
		<m_userData><d/></m_userData>
		<m_collideConnected public="1"><e path="Bool"/></m_collideConnected>
		<m_islandFlag public="1"><e path="Bool"/></m_islandFlag>
		<m_bodyB public="1"><c path="box2D.dynamics.B2Body"/></m_bodyB>
		<m_bodyA public="1"><c path="box2D.dynamics.B2Body"/></m_bodyA>
		<m_edgeB public="1"><c path="box2D.dynamics.joints.B2JointEdge"/></m_edgeB>
		<m_edgeA public="1"><c path="box2D.dynamics.joints.B2JointEdge"/></m_edgeA>
		<m_next public="1"><c path="box2D.dynamics.joints.B2Joint"/></m_next>
		<m_prev public="1"><c path="box2D.dynamics.joints.B2Joint"/></m_prev>
		<m_type public="1"><c path="Int"/></m_type>
		<solvePositionConstraints public="1" set="method" line="244"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<finalizeVelocityConstraints public="1" set="method" line="241"><f a=""><e path="Void"/></f></finalizeVelocityConstraints>
		<solveVelocityConstraints public="1" set="method" line="240"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="239"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<isActive public="1" set="method" line="101">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Short-cut function to determine if either body is inactive.
	 * @return</haxe_doc>
		</isActive>
		<setUserData public="1" set="method" line="93">
			<f a="data">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the user data pointer.</haxe_doc>
		</setUserData>
		<getUserData public="1" set="method" line="86">
			<f a=""><d/></f>
			<haxe_doc>* Get the user data pointer.</haxe_doc>
		</getUserData>
		<getNext public="1" set="method" line="79">
			<f a=""><c path="box2D.dynamics.joints.B2Joint"/></f>
			<haxe_doc>* Get the next joint the world joint list.</haxe_doc>
		</getNext>
		<getBodyB public="1" set="method" line="71">
			<f a=""><c path="box2D.dynamics.B2Body"/></f>
			<haxe_doc>* Get the second body attached to this joint.</haxe_doc>
		</getBodyB>
		<getBodyA public="1" set="method" line="63">
			<f a=""><c path="box2D.dynamics.B2Body"/></f>
			<haxe_doc>* Get the first body attached to this joint.</haxe_doc>
		</getBodyA>
		<getReactionTorque public="1" set="method" line="58">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Get the reaction torque on body2 in N*m.</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="54">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>* Get the reaction force on body2 at the joint anchor in Newtons.</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="49">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the anchor point on bodyB in world coordinates.</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="45">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the anchor point on bodyA in world coordinates.</haxe_doc>
		</getAnchorA>
		<getType public="1" set="method" line="38">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* Get the type of the concrete joint.</haxe_doc>
		</getType>
		<new public="1" set="method" line="220">
			<f a="def">
				<c path="box2D.dynamics.joints.B2JointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* The base joint class. Joints are used to constraint two bodies together in
* various fashions. Some joints also feature limits and motors.
* @see b2JointDef</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2DistanceJoint" params="" file="../../lib/box2D/dynamics/joints/B2DistanceJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<m_length><c path="Float"/></m_length>
		<m_mass><c path="Float"/></m_mass>
		<m_impulse><c path="Float"/></m_impulse>
		<m_bias><c path="Float"/></m_bias>
		<m_gamma><c path="Float"/></m_gamma>
		<m_dampingRatio><c path="Float"/></m_dampingRatio>
		<m_frequencyHz><c path="Float"/></m_frequencyHz>
		<m_u><c path="box2D.common.math.B2Vec2"/></m_u>
		<m_localAnchor2><c path="box2D.common.math.B2Vec2"/></m_localAnchor2>
		<m_localAnchor1><c path="box2D.common.math.B2Vec2"/></m_localAnchor1>
		<solvePositionConstraints public="1" set="method" line="286" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="236" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="138" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<setDampingRatio public="1" set="method" line="108"><f a="ratio">
	<c path="Float"/>
	<e path="Void"/>
</f></setDampingRatio>
		<getDampingRatio public="1" set="method" line="102"><f a=""><c path="Float"/></f></getDampingRatio>
		<setFrequency public="1" set="method" line="96"><f a="hz">
	<c path="Float"/>
	<e path="Void"/>
</f></setFrequency>
		<getFrequency public="1" set="method" line="90"><f a=""><c path="Float"/></f></getFrequency>
		<setLength public="1" set="method" line="84"><f a="length">
	<c path="Float"/>
	<e path="Void"/>
</f></setLength>
		<getLength public="1" set="method" line="78"><f a=""><c path="Float"/></f></getLength>
		<getReactionTorque public="1" set="method" line="71" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="63" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="58" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="54" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="116">
			<f a="def">
				<c path="box2D.dynamics.joints.B2DistanceJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* A distance joint constrains two points on two bodies
* to remain at a fixed distance from each other. You can view
* this as a massless, rigid rod.
* @see b2DistanceJointDef</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2JointDef" params="" file="../../lib/box2D/dynamics/joints/B2JointDef.hx">
		<collideConnected public="1">
			<e path="Bool"/>
			<haxe_doc>* Set this flag to true if the attached bodies should collide.</haxe_doc>
		</collideConnected>
		<bodyB public="1">
			<c path="box2D.dynamics.B2Body"/>
			<haxe_doc>* The second attached body.</haxe_doc>
		</bodyB>
		<bodyA public="1">
			<c path="box2D.dynamics.B2Body"/>
			<haxe_doc>* The first attached body.</haxe_doc>
		</bodyA>
		<userData public="1">
			<d/>
			<haxe_doc>* Use this to attach application specific data to your joints.</haxe_doc>
		</userData>
		<type public="1">
			<c path="Int"/>
			<haxe_doc>* The joint type is set automatically for concrete joint types.</haxe_doc>
		</type>
		<new public="1" set="method" line="32"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Joint definitions are used to construct joints.
* @see b2Joint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2DistanceJointDef" params="" file="../../lib/box2D/dynamics/joints/B2DistanceJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<dampingRatio public="1">
			<c path="Float"/>
			<haxe_doc>* The damping ratio. 0 = no damping, 1 = critical damping.</haxe_doc>
		</dampingRatio>
		<frequencyHz public="1">
			<c path="Float"/>
			<haxe_doc>* The mass-spring-damper frequency in Hertz.</haxe_doc>
		</frequencyHz>
		<length public="1">
			<c path="Float"/>
			<haxe_doc>* The natural length between the anchor points.</haxe_doc>
		</length>
		<localAnchorB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to body2's origin.</haxe_doc>
		</localAnchorB>
		<localAnchorA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to body1's origin.</haxe_doc>
		</localAnchorA>
		<initialize public="1" set="method" line="55">
			<f a="bA:bB:anchorA:anchorB">
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.common.math.B2Vec2"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Initialize the bodies, anchors, and length using the world
	* anchors.</haxe_doc>
		</initialize>
		<new public="1" set="method" line="37"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Distance joint definition. This requires defining an
* anchor point on both bodies and the non-zero length of the
* distance joint. The definition uses local anchor points
* so that the initial configuration can violate the constraint
* slightly. This helps when saving and loading a game.
* @warning Do not use a zero or short length.
* @see b2DistanceJoint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2FrictionJoint" params="" file="../../lib/box2D/dynamics/joints/B2FrictionJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<m_maxTorque><c path="Float"/></m_maxTorque>
		<m_maxForce><c path="Float"/></m_maxForce>
		<m_angularImpulse><c path="Float"/></m_angularImpulse>
		<m_linearImpulse><c path="box2D.common.math.B2Vec2"/></m_linearImpulse>
		<m_angularMass public="1"><c path="Float"/></m_angularMass>
		<m_linearMass public="1"><c path="box2D.common.math.B2Mat22"/></m_linearMass>
		<m_localAnchorB><c path="box2D.common.math.B2Vec2"/></m_localAnchorB>
		<m_localAnchorA><c path="box2D.common.math.B2Vec2"/></m_localAnchorA>
		<solvePositionConstraints public="1" set="method" line="283" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="196" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="114" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<getMaxTorque public="1" set="method" line="85"><f a=""><c path="Float"/></f></getMaxTorque>
		<setMaxTorque public="1" set="method" line="80"><f a="torque">
	<c path="Float"/>
	<e path="Void"/>
</f></setMaxTorque>
		<getMaxForce public="1" set="method" line="75"><f a=""><c path="Float"/></f></getMaxForce>
		<setMaxForce public="1" set="method" line="70"><f a="force">
	<c path="Float"/>
	<e path="Void"/>
</f></setMaxForce>
		<getReactionTorque public="1" set="method" line="64" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="58" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="53" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="49" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="93">
			<f a="def">
				<c path="box2D.dynamics.joints.B2FrictionJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* Friction joint. This is used for top-down friction.
 * It provides 2D translational friction and angular friction.
 * @see b2FrictionJointDef</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2FrictionJointDef" params="" file="../../lib/box2D/dynamics/joints/B2FrictionJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<maxTorque public="1">
			<c path="Float"/>
			<haxe_doc>* The maximun friction torque in N-m</haxe_doc>
		</maxTorque>
		<maxForce public="1">
			<c path="Float"/>
			<haxe_doc>* The maximun force in N.</haxe_doc>
		</maxForce>
		<localAnchorB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyB's origin.</haxe_doc>
		</localAnchorB>
		<localAnchorA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyA's origin.</haxe_doc>
		</localAnchorA>
		<initialize public="1" set="method" line="48">
			<f a="bA:bB:anchor">
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Initialize the bodies, anchors, axis, and reference angle using the world
	 * anchor and world axis.</haxe_doc>
		</initialize>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Friction joint defintion
 * @see b2FrictionJoint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2GearJoint" params="" file="../../lib/box2D/dynamics/joints/B2GearJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<m_impulse><c path="Float"/></m_impulse>
		<m_mass><c path="Float"/></m_mass>
		<m_ratio><c path="Float"/></m_ratio>
		<m_constant><c path="Float"/></m_constant>
		<m_J><c path="box2D.dynamics.joints.B2Jacobian"/></m_J>
		<m_localAnchor2><c path="box2D.common.math.B2Vec2"/></m_localAnchor2>
		<m_localAnchor1><c path="box2D.common.math.B2Vec2"/></m_localAnchor1>
		<m_groundAnchor2><c path="box2D.common.math.B2Vec2"/></m_groundAnchor2>
		<m_groundAnchor1><c path="box2D.common.math.B2Vec2"/></m_groundAnchor1>
		<m_prismatic2><c path="box2D.dynamics.joints.B2PrismaticJoint"/></m_prismatic2>
		<m_revolute2><c path="box2D.dynamics.joints.B2RevoluteJoint"/></m_revolute2>
		<m_prismatic1><c path="box2D.dynamics.joints.B2PrismaticJoint"/></m_prismatic1>
		<m_revolute1><c path="box2D.dynamics.joints.B2RevoluteJoint"/></m_revolute1>
		<m_ground2><c path="box2D.dynamics.B2Body"/></m_ground2>
		<m_ground1><c path="box2D.dynamics.B2Body"/></m_ground1>
		<solvePositionConstraints public="1" set="method" line="285" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="264" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="168" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<setRatio public="1" set="method" line="89">
			<f a="ratio">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the gear ratio.</haxe_doc>
		</setRatio>
		<getRatio public="1" set="method" line="82">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the gear ratio.</haxe_doc>
		</getRatio>
		<getReactionTorque public="1" set="method" line="62" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="55" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="50" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="45" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="97">
			<f a="def">
				<c path="box2D.dynamics.joints.B2GearJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* A gear joint is used to connect two joints together. Either joint
* can be a revolute or prismatic joint. You specify a gear ratio
* to bind the motions together:
* coordinate1 + ratio * coordinate2 = constant
* The ratio can be negative or positive. If one joint is a revolute joint
* and the other joint is a prismatic joint, then the ratio will have units
* of length or units of 1/length.
* @warning The revolute and prismatic joints must be attached to
* fixed bodies (which must be body1 on those joints).
* @see b2GearJointDef</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2GearJointDef" params="" file="../../lib/box2D/dynamics/joints/B2GearJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<ratio public="1">
			<c path="Float"/>
			<haxe_doc>* The gear ratio.
	* @see b2GearJoint for explanation.</haxe_doc>
		</ratio>
		<joint2 public="1">
			<c path="box2D.dynamics.joints.B2Joint"/>
			<haxe_doc>* The second revolute/prismatic joint attached to the gear joint.</haxe_doc>
		</joint2>
		<joint1 public="1">
			<c path="box2D.dynamics.joints.B2Joint"/>
			<haxe_doc>* The first revolute/prismatic joint attached to the gear joint.</haxe_doc>
		</joint1>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Gear joint definition. This definition requires two existing
* revolute or prismatic joints (any combination will work).
* The provided joints must attach a dynamic body to a static body.
* @see b2GearJoint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2Jacobian" params="" file="../../lib/box2D/dynamics/joints/B2Jacobian.hx">
		<compute public="1" set="method" line="51"><f a="x1:a1:x2:a2">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<c path="Float"/>
</f></compute>
		<set public="1" set="method" line="47"><f a="x1:a1:x2:a2">
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<setZero public="1" set="method" line="43"><f a=""><e path="Void"/></f></setZero>
		<angularB public="1"><c path="Float"/></angularB>
		<linearB public="1"><c path="box2D.common.math.B2Vec2"/></linearB>
		<angularA public="1"><c path="Float"/></angularA>
		<linearA public="1"><c path="box2D.common.math.B2Vec2"/></linearA>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @private</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2JointEdge" params="" file="../../lib/box2D/dynamics/joints/B2JointEdge.hx">
		<next public="1">
			<c path="box2D.dynamics.joints.B2JointEdge"/>
			<haxe_doc>The next joint edge in the body's joint list</haxe_doc>
		</next>
		<prev public="1">
			<c path="box2D.dynamics.joints.B2JointEdge"/>
			<haxe_doc>The previous joint edge in the body's joint list</haxe_doc>
		</prev>
		<joint public="1">
			<c path="box2D.dynamics.joints.B2Joint"/>
			<haxe_doc>The joint</haxe_doc>
		</joint>
		<other public="1">
			<c path="box2D.dynamics.B2Body"/>
			<haxe_doc>Provides quick access to the other body attached.</haxe_doc>
		</other>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* A joint edge is used to connect bodies and joints together
* in a joint graph where each body is a node and each joint
* is an edge. A joint edge belongs to a doubly linked list
* maintained in each attached body. Each joint has two joint
* nodes, one for each attached body.</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2LineJoint" params="" file="../../lib/box2D/dynamics/joints/B2LineJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<m_limitState><c path="Int"/></m_limitState>
		<m_enableMotor><e path="Bool"/></m_enableMotor>
		<m_enableLimit><e path="Bool"/></m_enableLimit>
		<m_motorSpeed><c path="Float"/></m_motorSpeed>
		<m_maxMotorForce><c path="Float"/></m_maxMotorForce>
		<m_upperTranslation><c path="Float"/></m_upperTranslation>
		<m_lowerTranslation><c path="Float"/></m_lowerTranslation>
		<m_motorImpulse><c path="Float"/></m_motorImpulse>
		<m_motorMass><c path="Float"/></m_motorMass>
		<m_impulse><c path="box2D.common.math.B2Vec2"/></m_impulse>
		<m_K><c path="box2D.common.math.B2Mat22"/></m_K>
		<m_a2><c path="Float"/></m_a2>
		<m_a1><c path="Float"/></m_a1>
		<m_s2><c path="Float"/></m_s2>
		<m_s1><c path="Float"/></m_s1>
		<m_perp><c path="box2D.common.math.B2Vec2"/></m_perp>
		<m_axis><c path="box2D.common.math.B2Vec2"/></m_axis>
		<m_localYAxis1><c path="box2D.common.math.B2Vec2"/></m_localYAxis1>
		<m_localXAxis1 public="1"><c path="box2D.common.math.B2Vec2"/></m_localXAxis1>
		<m_localAnchor2 public="1"><c path="box2D.common.math.B2Vec2"/></m_localAnchor2>
		<m_localAnchor1 public="1"><c path="box2D.common.math.B2Vec2"/></m_localAnchor1>
		<solvePositionConstraints public="1" set="method" line="603" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="482" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="340" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<getMotorForce public="1" set="method" line="288">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current motor force, usually in N.</haxe_doc>
		</getMotorForce>
		<getMaxMotorForce public="1" set="method" line="280">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the maximum motor force, usually in N.</haxe_doc>
		</getMaxMotorForce>
		<setMaxMotorForce public="1" set="method" line="270">
			<f a="force">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the maximum motor force, usually in N.</haxe_doc>
		</setMaxMotorForce>
		<getMotorSpeed public="1" set="method" line="262">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the motor speed, usually in meters per second.</haxe_doc>
		</getMotorSpeed>
		<setMotorSpeed public="1" set="method" line="253">
			<f a="speed">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the motor speed, usually in meters per second.</haxe_doc>
		</setMotorSpeed>
		<enableMotor public="1" set="method" line="244">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable the joint motor.</haxe_doc>
		</enableMotor>
		<isMotorEnabled public="1" set="method" line="237">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is the joint motor enabled?</haxe_doc>
		</isMotorEnabled>
		<setLimits public="1" set="method" line="226">
			<f a="lower:upper">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the joint limits, usually in meters.</haxe_doc>
		</setLimits>
		<getUpperLimit public="1" set="method" line="219">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the upper joint limit, usually in meters.</haxe_doc>
		</getUpperLimit>
		<getLowerLimit public="1" set="method" line="212">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the lower joint limit, usually in meters.</haxe_doc>
		</getLowerLimit>
		<enableLimit public="1" set="method" line="203">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable the joint limit.</haxe_doc>
		</enableLimit>
		<isLimitEnabled public="1" set="method" line="196">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is the joint limit enabled?</haxe_doc>
		</isLimitEnabled>
		<getJointSpeed public="1" set="method" line="147">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current joint translation speed, usually in meters per second.</haxe_doc>
		</getJointSpeed>
		<getJointTranslation public="1" set="method" line="125">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current joint translation, usually in meters.</haxe_doc>
		</getJointTranslation>
		<getReactionTorque public="1" set="method" line="117" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="109" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="105" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="101" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="297">
			<f a="def">
				<c path="box2D.dynamics.joints.B2LineJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* A line joint. This joint provides one degree of freedom: translation
 * along an axis fixed in body1. You can use a joint limit to restrict
 * the range of motion and a joint motor to drive the motion or to
 * model joint friction.
 * @see b2LineJointDef</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2LineJointDef" params="" file="../../lib/box2D/dynamics/joints/B2LineJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<motorSpeed public="1">
			<c path="Float"/>
			<haxe_doc>* The desired motor speed in radians per second.</haxe_doc>
		</motorSpeed>
		<maxMotorForce public="1">
			<c path="Float"/>
			<haxe_doc>* The maximum motor torque, usually in N-m.</haxe_doc>
		</maxMotorForce>
		<enableMotor public="1">
			<e path="Bool"/>
			<haxe_doc>* Enable/disable the joint motor.</haxe_doc>
		</enableMotor>
		<upperTranslation public="1">
			<c path="Float"/>
			<haxe_doc>* The upper translation limit, usually in meters.</haxe_doc>
		</upperTranslation>
		<lowerTranslation public="1">
			<c path="Float"/>
			<haxe_doc>* The lower translation limit, usually in meters.</haxe_doc>
		</lowerTranslation>
		<enableLimit public="1">
			<e path="Bool"/>
			<haxe_doc>* Enable/disable the joint limit.</haxe_doc>
		</enableLimit>
		<localAxisA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local translation axis in bodyA.</haxe_doc>
		</localAxisA>
		<localAnchorB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyB's origin.</haxe_doc>
		</localAnchorB>
		<localAnchorA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyA's origin.</haxe_doc>
		</localAnchorA>
		<initialize public="1" set="method" line="56"><f a="bA:bB:anchor:axis">
	<c path="box2D.dynamics.B2Body"/>
	<c path="box2D.dynamics.B2Body"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></initialize>
		<b2LineJointDef public="1" set="method" line="37"><f a=""><e path="Void"/></f></b2LineJointDef>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Line joint definition. This requires defining a line of
 * motion using an axis and an anchor point. The definition uses local
 * anchor points and a local axis so that the initial configuration
 * can violate the constraint slightly. The joint translation is zero
 * when the local anchor points coincide in world space. Using local
 * anchors and a local axis helps when saving and loading a game.
 * @see b2LineJoint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2MouseJoint" params="" file="../../lib/box2D/dynamics/joints/B2MouseJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<m_gamma><c path="Float"/></m_gamma>
		<m_beta><c path="Float"/></m_beta>
		<m_dampingRatio><c path="Float"/></m_dampingRatio>
		<m_frequencyHz><c path="Float"/></m_frequencyHz>
		<m_maxForce><c path="Float"/></m_maxForce>
		<m_C><c path="box2D.common.math.B2Vec2"/></m_C>
		<m_mass><c path="box2D.common.math.B2Mat22"/></m_mass>
		<m_impulse><c path="box2D.common.math.B2Vec2"/></m_impulse>
		<m_target><c path="box2D.common.math.B2Vec2"/></m_target>
		<m_localAnchor><c path="box2D.common.math.B2Vec2"/></m_localAnchor>
		<solvePositionConstraints public="1" set="method" line="284" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="235" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="162" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<K2><c path="box2D.common.math.B2Mat22"/></K2>
		<K1><c path="box2D.common.math.B2Mat22"/></K1>
		<K><c path="box2D.common.math.B2Mat22"/></K>
		<setDampingRatio public="1" set="method" line="113"><f a="ratio">
	<c path="Float"/>
	<e path="Void"/>
</f></setDampingRatio>
		<getDampingRatio public="1" set="method" line="107"><f a=""><c path="Float"/></f></getDampingRatio>
		<setFrequency public="1" set="method" line="101"><f a="hz">
	<c path="Float"/>
	<e path="Void"/>
</f></setFrequency>
		<getFrequency public="1" set="method" line="95"><f a=""><c path="Float"/></f></getFrequency>
		<setMaxForce public="1" set="method" line="89"><f a="maxForce">
	<c path="Float"/>
	<e path="Void"/>
</f></setMaxForce>
		<getMaxForce public="1" set="method" line="83"><f a=""><c path="Float"/></f></getMaxForce>
		<setTarget public="1" set="method" line="75">
			<f a="target">
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Use this to update the target point.</haxe_doc>
		</setTarget>
		<getTarget public="1" set="method" line="67"><f a=""><c path="box2D.common.math.B2Vec2"/></f></getTarget>
		<getReactionTorque public="1" set="method" line="62" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="57" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="53" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="49" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="121">
			<f a="def">
				<c path="box2D.dynamics.joints.B2MouseJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* A mouse joint is used to make a point on a body track a
* specified world point. This a soft constraint with a maximum
* force. This allows the constraint to stretch and without
* applying huge forces.
* Note: this joint is not fully documented as it is intended primarily
* for the testbed. See that for more instructions.
* @see b2MouseJointDef</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2MouseJointDef" params="" file="../../lib/box2D/dynamics/joints/B2MouseJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<dampingRatio public="1">
			<c path="Float"/>
			<haxe_doc>* The damping ratio. 0 = no damping, 1 = critical damping.</haxe_doc>
		</dampingRatio>
		<frequencyHz public="1">
			<c path="Float"/>
			<haxe_doc>* The response speed.</haxe_doc>
		</frequencyHz>
		<maxForce public="1">
			<c path="Float"/>
			<haxe_doc>* The maximum constraint force that can be exerted
	* to move the candidate body. Usually you will express
	* as some multiple of the weight (multiplier * mass * gravity).</haxe_doc>
		</maxForce>
		<target public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The initial world target point. This is assumed
	* to coincide with the body anchor initially.</haxe_doc>
		</target>
		<new public="1" set="method" line="32"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Mouse joint definition. This requires a world target point,
* tuning parameters, and the time step.
* @see b2MouseJoint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2PrismaticJoint" params="" file="../../lib/box2D/dynamics/joints/B2PrismaticJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<m_limitState><c path="Int"/></m_limitState>
		<m_enableMotor><e path="Bool"/></m_enableMotor>
		<m_enableLimit><e path="Bool"/></m_enableLimit>
		<m_motorSpeed><c path="Float"/></m_motorSpeed>
		<m_maxMotorForce><c path="Float"/></m_maxMotorForce>
		<m_upperTranslation><c path="Float"/></m_upperTranslation>
		<m_lowerTranslation><c path="Float"/></m_lowerTranslation>
		<m_motorImpulse><c path="Float"/></m_motorImpulse>
		<m_motorMass><c path="Float"/></m_motorMass>
		<m_impulse><c path="box2D.common.math.B2Vec3"/></m_impulse>
		<m_K><c path="box2D.common.math.B2Mat33"/></m_K>
		<m_a2><c path="Float"/></m_a2>
		<m_a1><c path="Float"/></m_a1>
		<m_s2><c path="Float"/></m_s2>
		<m_s1><c path="Float"/></m_s1>
		<m_perp><c path="box2D.common.math.B2Vec2"/></m_perp>
		<m_axis><c path="box2D.common.math.B2Vec2"/></m_axis>
		<m_refAngle><c path="Float"/></m_refAngle>
		<m_localYAxis1><c path="box2D.common.math.B2Vec2"/></m_localYAxis1>
		<m_localXAxis1 public="1"><c path="box2D.common.math.B2Vec2"/></m_localXAxis1>
		<m_localAnchor2 public="1"><c path="box2D.common.math.B2Vec2"/></m_localAnchor2>
		<m_localAnchor1 public="1"><c path="box2D.common.math.B2Vec2"/></m_localAnchor1>
		<solvePositionConstraints public="1" set="method" line="604" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="487" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="339" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<getMotorForce public="1" set="method" line="287">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current motor force, usually in N.</haxe_doc>
		</getMotorForce>
		<setMaxMotorForce public="1" set="method" line="278">
			<f a="force">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the maximum motor force, usually in N.</haxe_doc>
		</setMaxMotorForce>
		<getMotorSpeed public="1" set="method" line="270">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the motor speed, usually in meters per second.</haxe_doc>
		</getMotorSpeed>
		<setMotorSpeed public="1" set="method" line="261">
			<f a="speed">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the motor speed, usually in meters per second.</haxe_doc>
		</setMotorSpeed>
		<enableMotor public="1" set="method" line="252">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable the joint motor.</haxe_doc>
		</enableMotor>
		<isMotorEnabled public="1" set="method" line="245">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is the joint motor enabled?</haxe_doc>
		</isMotorEnabled>
		<setLimits public="1" set="method" line="234">
			<f a="lower:upper">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the joint limits, usually in meters.</haxe_doc>
		</setLimits>
		<getUpperLimit public="1" set="method" line="227">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the upper joint limit, usually in meters.</haxe_doc>
		</getUpperLimit>
		<getLowerLimit public="1" set="method" line="220">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the lower joint limit, usually in meters.</haxe_doc>
		</getLowerLimit>
		<enableLimit public="1" set="method" line="211">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable the joint limit.</haxe_doc>
		</enableLimit>
		<isLimitEnabled public="1" set="method" line="204">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is the joint limit enabled?</haxe_doc>
		</isLimitEnabled>
		<getJointSpeed public="1" set="method" line="155">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current joint translation speed, usually in meters per second.</haxe_doc>
		</getJointSpeed>
		<getJointTranslation public="1" set="method" line="133">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current joint translation, usually in meters.</haxe_doc>
		</getJointTranslation>
		<getReactionTorque public="1" set="method" line="125" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="117" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="113" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="109" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="296">
			<f a="def">
				<c path="box2D.dynamics.joints.B2PrismaticJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* A prismatic joint. This joint provides one degree of freedom: translation
* along an axis fixed in body1. Relative rotation is prevented. You can
* use a joint limit to restrict the range of motion and a joint motor to
* drive the motion or to model joint friction.
* @see b2PrismaticJointDef</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2PrismaticJointDef" params="" file="../../lib/box2D/dynamics/joints/B2PrismaticJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<motorSpeed public="1">
			<c path="Float"/>
			<haxe_doc>* The desired motor speed in radians per second.</haxe_doc>
		</motorSpeed>
		<maxMotorForce public="1">
			<c path="Float"/>
			<haxe_doc>* The maximum motor torque, usually in N-m.</haxe_doc>
		</maxMotorForce>
		<enableMotor public="1">
			<e path="Bool"/>
			<haxe_doc>* Enable/disable the joint motor.</haxe_doc>
		</enableMotor>
		<upperTranslation public="1">
			<c path="Float"/>
			<haxe_doc>* The upper translation limit, usually in meters.</haxe_doc>
		</upperTranslation>
		<lowerTranslation public="1">
			<c path="Float"/>
			<haxe_doc>* The lower translation limit, usually in meters.</haxe_doc>
		</lowerTranslation>
		<enableLimit public="1">
			<e path="Bool"/>
			<haxe_doc>* Enable/disable the joint limit.</haxe_doc>
		</enableLimit>
		<referenceAngle public="1">
			<c path="Float"/>
			<haxe_doc>* The constrained angle between the bodies: bodyB_angle - bodyA_angle.</haxe_doc>
		</referenceAngle>
		<localAxisA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local translation axis in body1.</haxe_doc>
		</localAxisA>
		<localAnchorB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyB's origin.</haxe_doc>
		</localAnchorB>
		<localAnchorA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyA's origin.</haxe_doc>
		</localAnchorA>
		<initialize public="1" set="method" line="57"><f a="bA:bB:anchor:axis">
	<c path="box2D.dynamics.B2Body"/>
	<c path="box2D.dynamics.B2Body"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></initialize>
		<new public="1" set="method" line="37"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Prismatic joint definition. This requires defining a line of
* motion using an axis and an anchor point. The definition uses local
* anchor points and a local axis so that the initial configuration
* can violate the constraint slightly. The joint translation is zero
* when the local anchor points coincide in world space. Using local
* anchors and a local axis helps when saving and loading a game.
* @see b2PrismaticJoint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2PulleyJoint" params="" file="../../lib/box2D/dynamics/joints/B2PulleyJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<b2_minPulleyLength public="1" line="674" static="1"><c path="Float"/></b2_minPulleyLength>
		<m_limitState2><c path="Int"/></m_limitState2>
		<m_limitState1><c path="Int"/></m_limitState1>
		<m_state><c path="Int"/></m_state>
		<m_limitImpulse2><c path="Float"/></m_limitImpulse2>
		<m_limitImpulse1><c path="Float"/></m_limitImpulse1>
		<m_impulse><c path="Float"/></m_impulse>
		<m_limitMass2><c path="Float"/></m_limitMass2>
		<m_limitMass1><c path="Float"/></m_limitMass1>
		<m_pulleyMass><c path="Float"/></m_pulleyMass>
		<m_maxLength2><c path="Float"/></m_maxLength2>
		<m_maxLength1><c path="Float"/></m_maxLength1>
		<m_ratio><c path="Float"/></m_ratio>
		<m_constant><c path="Float"/></m_constant>
		<m_u2><c path="box2D.common.math.B2Vec2"/></m_u2>
		<m_u1><c path="box2D.common.math.B2Vec2"/></m_u1>
		<m_localAnchor2><c path="box2D.common.math.B2Vec2"/></m_localAnchor2>
		<m_localAnchor1><c path="box2D.common.math.B2Vec2"/></m_localAnchor1>
		<m_groundAnchor2><c path="box2D.common.math.B2Vec2"/></m_groundAnchor2>
		<m_groundAnchor1><c path="box2D.common.math.B2Vec2"/></m_groundAnchor1>
		<m_ground><c path="box2D.dynamics.B2Body"/></m_ground>
		<solvePositionConstraints public="1" set="method" line="436" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="318" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="174" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<getRatio public="1" set="method" line="122">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the pulley ratio.</haxe_doc>
		</getRatio>
		<getLength2 public="1" set="method" line="106">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current length of the segment attached to body2.</haxe_doc>
		</getLength2>
		<getLength1 public="1" set="method" line="90">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current length of the segment attached to body1.</haxe_doc>
		</getLength1>
		<getGroundAnchorB public="1" set="method" line="79">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the second ground anchor.</haxe_doc>
		</getGroundAnchorB>
		<getGroundAnchorA public="1" set="method" line="68">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>* Get the first ground anchor.</haxe_doc>
		</getGroundAnchorA>
		<getReactionTorque public="1" set="method" line="59" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="51" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="46" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="42" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="129">
			<f a="def">
				<c path="box2D.dynamics.joints.B2PulleyJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The pulley joint is connected to two bodies and two fixed ground points.
* The pulley supports a ratio such that:
* length1 + ratio * length2 <= constant
* Yes, the force transmitted is scaled by the ratio.
* The pulley also enforces a maximum length limit on both sides. This is
* useful to prevent one side of the pulley hitting the top.
* @see b2PulleyJointDef]]></haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2PulleyJointDef" params="" file="../../lib/box2D/dynamics/joints/B2PulleyJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<ratio public="1">
			<c path="Float"/>
			<haxe_doc>* The pulley ratio, used to simulate a block-and-tackle.</haxe_doc>
		</ratio>
		<maxLengthB public="1">
			<c path="Float"/>
			<haxe_doc>* The maximum length of the segment attached to bodyB.</haxe_doc>
		</maxLengthB>
		<lengthB public="1">
			<c path="Float"/>
			<haxe_doc>* The a reference length for the segment attached to bodyB.</haxe_doc>
		</lengthB>
		<maxLengthA public="1">
			<c path="Float"/>
			<haxe_doc>* The maximum length of the segment attached to bodyA.</haxe_doc>
		</maxLengthA>
		<lengthA public="1">
			<c path="Float"/>
			<haxe_doc>* The a reference length for the segment attached to bodyA.</haxe_doc>
		</lengthA>
		<localAnchorB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyB's origin.</haxe_doc>
		</localAnchorB>
		<localAnchorA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyA's origin.</haxe_doc>
		</localAnchorA>
		<groundAnchorB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The second ground anchor in world coordinates. This point never moves.</haxe_doc>
		</groundAnchorB>
		<groundAnchorA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The first ground anchor in world coordinates. This point never moves.</haxe_doc>
		</groundAnchorA>
		<initialize public="1" set="method" line="57"><f a="bA:bB:gaA:gaB:anchorA:anchorB:r">
	<c path="box2D.dynamics.B2Body"/>
	<c path="box2D.dynamics.B2Body"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="box2D.common.math.B2Vec2"/>
	<c path="Float"/>
	<e path="Void"/>
</f></initialize>
		<new public="1" set="method" line="36"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Pulley joint definition. This requires two ground anchors,
* two dynamic body anchor points, max lengths for each side,
* and a pulley ratio.
* @see b2PulleyJoint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2RevoluteJoint" params="" file="../../lib/box2D/dynamics/joints/B2RevoluteJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<tImpulse line="499" static="1"><c path="box2D.common.math.B2Vec2"/></tImpulse>
		<m_limitState><c path="Int"/></m_limitState>
		<m_upperAngle><c path="Float"/></m_upperAngle>
		<m_lowerAngle><c path="Float"/></m_lowerAngle>
		<m_referenceAngle><c path="Float"/></m_referenceAngle>
		<m_enableLimit><e path="Bool"/></m_enableLimit>
		<m_motorSpeed><c path="Float"/></m_motorSpeed>
		<m_maxMotorTorque><c path="Float"/></m_maxMotorTorque>
		<m_enableMotor><e path="Bool"/></m_enableMotor>
		<m_motorMass><c path="Float"/></m_motorMass>
		<m_mass><c path="box2D.common.math.B2Mat33"/></m_mass>
		<m_motorImpulse><c path="Float"/></m_motorImpulse>
		<m_impulse><c path="box2D.common.math.B2Vec3"/></m_impulse>
		<m_localAnchor2 public="1"><c path="box2D.common.math.B2Vec2"/></m_localAnchor2>
		<m_localAnchor1 public="1"><c path="box2D.common.math.B2Vec2"/></m_localAnchor1>
		<solvePositionConstraints public="1" set="method" line="500" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="351" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<reduced><c path="box2D.common.math.B2Vec2"/></reduced>
		<impulse2><c path="box2D.common.math.B2Vec2"/></impulse2>
		<impulse3><c path="box2D.common.math.B2Vec3"/></impulse3>
		<initVelocityConstraints public="1" set="method" line="219" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<K3><c path="box2D.common.math.B2Mat22"/></K3>
		<K2><c path="box2D.common.math.B2Mat22"/></K2>
		<K1><c path="box2D.common.math.B2Mat22"/></K1>
		<K><c path="box2D.common.math.B2Mat22"/></K>
		<getMotorTorque public="1" set="method" line="170">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current motor torque, usually in N-m.</haxe_doc>
		</getMotorTorque>
		<setMaxMotorTorque public="1" set="method" line="163">
			<f a="torque">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the maximum motor torque, usually in N-m.</haxe_doc>
		</setMaxMotorTorque>
		<getMotorSpeed public="1" set="method" line="156">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the motor speed in radians per second.</haxe_doc>
		</getMotorSpeed>
		<setMotorSpeed public="1" set="method" line="147">
			<f a="speed">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the motor speed in radians per second.</haxe_doc>
		</setMotorSpeed>
		<enableMotor public="1" set="method" line="140">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable the joint motor.</haxe_doc>
		</enableMotor>
		<isMotorEnabled public="1" set="method" line="131">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is the joint motor enabled?</haxe_doc>
		</isMotorEnabled>
		<setLimits public="1" set="method" line="122">
			<f a="lower:upper">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Set the joint limits in radians.</haxe_doc>
		</setLimits>
		<getUpperLimit public="1" set="method" line="115">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the upper joint limit in radians.</haxe_doc>
		</getUpperLimit>
		<getLowerLimit public="1" set="method" line="108">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the lower joint limit in radians.</haxe_doc>
		</getLowerLimit>
		<enableLimit public="1" set="method" line="101">
			<f a="flag">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Enable/disable the joint limit.</haxe_doc>
		</enableLimit>
		<isLimitEnabled public="1" set="method" line="94">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Is the joint limit enabled?</haxe_doc>
		</isLimitEnabled>
		<getJointSpeed public="1" set="method" line="85">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current joint angle speed in radians per second.</haxe_doc>
		</getJointSpeed>
		<getJointAngle public="1" set="method" line="76">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Get the current joint angle in radians.</haxe_doc>
		</getJointAngle>
		<getReactionTorque public="1" set="method" line="69" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="65" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="60" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="56" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="177">
			<f a="def">
				<c path="box2D.dynamics.joints.B2RevoluteJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* A revolute joint constrains to bodies to share a common point while they
* are free to rotate about the point. The relative rotation about the shared
* point is the joint angle. You can limit the relative rotation with
* a joint limit that specifies a lower and upper angle. You can use a motor
* to drive the relative rotation about the shared point. A maximum motor torque
* is provided so that infinite forces are not generated.
* @see b2RevoluteJointDef</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2RevoluteJointDef" params="" file="../../lib/box2D/dynamics/joints/B2RevoluteJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<maxMotorTorque public="1">
			<c path="Float"/>
			<haxe_doc>* The maximum motor torque used to achieve the desired motor speed.
	* Usually in N-m.</haxe_doc>
		</maxMotorTorque>
		<motorSpeed public="1">
			<c path="Float"/>
			<haxe_doc>* The desired motor speed. Usually in radians per second.</haxe_doc>
		</motorSpeed>
		<enableMotor public="1">
			<e path="Bool"/>
			<haxe_doc>* A flag to enable the joint motor.</haxe_doc>
		</enableMotor>
		<upperAngle public="1">
			<c path="Float"/>
			<haxe_doc>* The upper angle for the joint limit (radians).</haxe_doc>
		</upperAngle>
		<lowerAngle public="1">
			<c path="Float"/>
			<haxe_doc>* The lower angle for the joint limit (radians).</haxe_doc>
		</lowerAngle>
		<enableLimit public="1">
			<e path="Bool"/>
			<haxe_doc>* A flag to enable joint limits.</haxe_doc>
		</enableLimit>
		<referenceAngle public="1">
			<c path="Float"/>
			<haxe_doc>* The bodyB angle minus bodyA angle in the reference state (radians).</haxe_doc>
		</referenceAngle>
		<localAnchorB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyB's origin.</haxe_doc>
		</localAnchorB>
		<localAnchorA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyA's origin.</haxe_doc>
		</localAnchorA>
		<initialize public="1" set="method" line="65">
			<f a="bA:bB:anchor">
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Initialize the bodies, anchors, and reference angle using the world
	* anchor.</haxe_doc>
		</initialize>
		<new public="1" set="method" line="43"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Revolute joint definition. This requires defining an
* anchor point where the bodies are joined. The definition
* uses local anchor points so that the initial configuration
* can violate the constraint slightly. You also need to
* specify the initial relative angle for joint limits. This
* helps when saving and loading a game.
* The local anchor points are measured from the body's origin
* rather than the center of mass because:
* 1. you might not know where the center of mass will be.
* 2. if you add/remove shapes from a body and recompute the mass,
* the joints will be broken.
* @see b2RevoluteJoint</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2WeldJoint" params="" file="../../lib/box2D/dynamics/joints/B2WeldJoint.hx">
		<extends path="box2D.dynamics.joints.B2Joint"/>
		<m_mass><c path="box2D.common.math.B2Mat33"/></m_mass>
		<m_impulse><c path="box2D.common.math.B2Vec3"/></m_impulse>
		<m_referenceAngle><c path="Float"/></m_referenceAngle>
		<m_localAnchorB><c path="box2D.common.math.B2Vec2"/></m_localAnchorB>
		<m_localAnchorA><c path="box2D.common.math.B2Vec2"/></m_localAnchorA>
		<solvePositionConstraints public="1" set="method" line="220" override="1"><f a="baumgarte">
	<c path="Float"/>
	<e path="Bool"/>
</f></solvePositionConstraints>
		<solveVelocityConstraints public="1" set="method" line="161" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></solveVelocityConstraints>
		<initVelocityConstraints public="1" set="method" line="90" override="1"><f a="step">
	<c path="box2D.dynamics.B2TimeStep"/>
	<e path="Void"/>
</f></initVelocityConstraints>
		<getReactionTorque public="1" set="method" line="65" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionTorque>
		<getReactionForce public="1" set="method" line="59" override="1">
			<f a="inv_dt">
				<c path="Float"/>
				<c path="box2D.common.math.B2Vec2"/>
			</f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getReactionForce>
		<getAnchorB public="1" set="method" line="54" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorB>
		<getAnchorA public="1" set="method" line="50" override="1">
			<f a=""><c path="box2D.common.math.B2Vec2"/></f>
			<haxe_doc>@inheritDoc</haxe_doc>
		</getAnchorA>
		<new public="1" set="method" line="73">
			<f a="def">
				<c path="box2D.dynamics.joints.B2WeldJointDef"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</new>
		<haxe_doc>* A weld joint essentially glues two bodies together. A weld joint may
 * distort somewhat because the island constraint solver is approximate.</haxe_doc>
	</class>
	<class path="box2D.dynamics.joints.B2WeldJointDef" params="" file="../../lib/box2D/dynamics/joints/B2WeldJointDef.hx">
		<extends path="box2D.dynamics.joints.B2JointDef"/>
		<referenceAngle public="1">
			<c path="Float"/>
			<haxe_doc>* The body2 angle minus body1 angle in the reference state (radians).</haxe_doc>
		</referenceAngle>
		<localAnchorB public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyB's origin.</haxe_doc>
		</localAnchorB>
		<localAnchorA public="1">
			<c path="box2D.common.math.B2Vec2"/>
			<haxe_doc>* The local anchor point relative to bodyA's origin.</haxe_doc>
		</localAnchorA>
		<initialize public="1" set="method" line="48">
			<f a="bA:bB:anchor">
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.dynamics.B2Body"/>
				<c path="box2D.common.math.B2Vec2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Initialize the bodies, anchors, axis, and reference angle using the world
	 * anchor and world axis.</haxe_doc>
		</initialize>
		<new public="1" set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Weld joint definition. You need to specify local anchor points
 * where they are attached and the relative body angle. The position
 * of the anchor points is important for computing the reaction torque.
 * @see b2WeldJoint</haxe_doc>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.component.base.FEntityComponent" params="" file="../../lib/firmament/component/base/FEntityComponent.hx">
		<extends path="flash.events.EventDispatcher"/>
		<removeAllEventListenersFromEntity public="1" set="method" line="71"><f a=""><e path="Void"/></f></removeAllEventListenersFromEntity>
		<removeEventListenerFromEntity public="1" set="method" line="66"><f a="event">
	<c path="String"/>
	<e path="Void"/>
</f></removeEventListenerFromEntity>
		<addEventListenerToEntity public="1" set="method" line="59"><f a="event:listener">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></addEventListenerToEntity>
		<destruct public="1" set="method" line="54"><f a=""><e path="Void"/></f></destruct>
		<getConfig public="1" set="method" line="49"><f a=""><unknown/></f></getConfig>
		<setConfig public="1" set="method" line="45"><f a="c">
	<d/>
	<e path="Void"/>
</f></setConfig>
		<getEntity public="1" set="method" line="41"><f a=""><c path="firmament.core.FEntity"/></f></getEntity>
		<setEntity public="1" set="method" line="37"><f a="entity">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></setEntity>
		<getType public="1" set="method" line="32"><f a=""><c path="String"/></f></getType>
		<init public="1" set="method" line="27"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_listeners><c path="Hash"><f a="">
	<d/>
	<e path="Void"/>
</f></c></_listeners>
		<_entity><c path="firmament.core.FEntity"/></_entity>
		<_config><d/></_config>
		<new public="1" set="method" line="21"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.component.animation.FAnimationComponentInterface" params="" file="../../lib/firmament/component/animation/FAnimationComponentInterface.hx" interface="1"/>
	<class path="firmament.component.animation.FAnimationComponent" params="" file="../../lib/firmament/component/animation/FAnimationComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<implements path="firmament.component.animation.FAnimationComponentInterface"/>
		<jumpToFrame public="1" set="method" line="52"><f a="frame">
	<c path="Int"/>
	<e path="Void"/>
</f></jumpToFrame>
		<setAnimation public="1" set="method" line="47"><f a="animation:?frame">
	<c path="firmament.core.FAnimation"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setAnimation>
		<beforeRender public="1" set="method" line="37"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></beforeRender>
		<getType public="1" set="method" line="33" override="1"><f a=""><c path="String"/></f></getType>
		<init public="1" set="method" line="25" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_timeOfLastFrameChange><c path="Float"/></_timeOfLastFrameChange>
		<_currentFrame><c path="Int"/></_currentFrame>
		<_currentAnimation><c path="firmament.core.FAnimation"/></_currentAnimation>
		<new public="1" set="method" line="19"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.component.base.FEntityComponentFactory" params="" file="../../lib/firmament/component/base/FEntityComponentFactory.hx">
		<createComponent public="1" set="method" line="16" static="1"><f a="type">
	<c path="String"/>
	<c path="firmament.component.base.FEntityComponent"/>
</f></createComponent>
		<getClassFromType public="1" set="method" line="29" static="1"><f a="type">
	<c path="String"/>
	<c path="String"/>
</f></getClassFromType>
	</class>
	<class path="firmament.component.event.FCollisionEventMapperComponent" params="" file="../../lib/firmament/component/event/FCollisionEventMapperComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<getType public="1" set="method" line="48" override="1"><f a=""><c path="String"/></f></getType>
		<init public="1" set="method" line="20" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_types><c path="Array"><c path="String"/></c></_types>
		<_map><d/></_map>
		<new public="1" set="method" line="15"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.component.event.FEntityEmitterComponent" params="" file="../../lib/firmament/component/event/FEntityEmitterComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<getType public="1" set="method" line="53" override="1"><f a=""><c path="String"/></f></getType>
		<init public="1" set="method" line="20" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<new public="1" set="method" line="15"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.component.event.FEventMapperComponent" params="" file="../../lib/firmament/component/event/FEventMapperComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<getType public="1" set="method" line="32" override="1"><f a=""><c path="String"/></f></getType>
		<init public="1" set="method" line="18" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_map><d/></_map>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.component.event.FEventRelayComponent" params="" file="../../lib/firmament/component/event/FEventRelayComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<eventFired set="method" line="43"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></eventFired>
		<getType public="1" set="method" line="39" override="1"><f a=""><c path="String"/></f></getType>
		<init public="1" set="method" line="26" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_fireEvent><c path="String"/></_fireEvent>
		<_eventsToFire><c path="Array"><c path="String"/></c></_eventsToFire>
		<new public="1" set="method" line="22"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.world.FWorldPositionalInterface" params="" file="../../lib/firmament/core/FWorldPositionalInterface.hx" interface="1">
		<setAngle public="1" set="method"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></setAngle>
		<getAngle public="1" set="method"><f a=""><c path="Float"/></f></getAngle>
		<getPositionY public="1" set="method"><f a=""><c path="Float"/></f></getPositionY>
		<getPositionX public="1" set="method"><f a=""><c path="Float"/></f></getPositionX>
		<getPosition public="1" set="method"><f a=""><c path="firmament.core.FVector"/></f></getPosition>
		<setPosition public="1" set="method"><f a="pos">
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></setPosition>
		<haxe_doc>* Interface: FWorldPositionalInterface 
 * 
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.component.physics.FPhysicsComponentInterface" params="" file="../../lib/firmament/component/physics/FPhysicsComponentInterface.hx" interface="1">
		<getShapes public="1" set="method"><f a=""><c path="Array"><c path="firmament.core.FShape"/></c></f></getShapes>
		<addAngularVelocity public="1" set="method"><f a="omega">
	<c path="Float"/>
	<e path="Void"/>
</f></addAngularVelocity>
		<getAngularVelocity public="1" set="method"><f a=""><c path="Float"/></f></getAngularVelocity>
		<setAngularVelocity public="1" set="method"><f a="omega">
	<c path="Float"/>
	<e path="Void"/>
</f></setAngularVelocity>
		<getLinearVelocity public="1" set="method"><f a=""><c path="firmament.core.FVector"/></f></getLinearVelocity>
		<setLinearVelocity public="1" set="method"><f a="v">
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></setLinearVelocity>
		<applyLinearForce public="1" set="method"><f a="v:?point">
	<c path="firmament.core.FVector"/>
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></applyLinearForce>
		<getWorld public="1" set="method"><f a=""><c path="firmament.world.FWorld"/></f></getWorld>
		<setWorld public="1" set="method"><f a="world">
	<c path="firmament.world.FWorld"/>
	<e path="Void"/>
</f></setWorld>
		<setZPosition public="1" set="method"><f a="p">
	<c path="Float"/>
	<e path="Void"/>
</f></setZPosition>
		<getZPosition public="1" set="method"><f a=""><c path="Float"/></f></getZPosition>
		<setAngle public="1" set="method">
			<f a="a">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: setAngle
	 * 
	 * Returns:
		 * Float</haxe_doc>
		</setAngle>
		<getAngle public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Function: getAngle
	 * 
	 * Returns:
		 * Float</haxe_doc>
		</getAngle>
		<getPositionY public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Function: getPositionY
	 * 
	 * Returns:
		 * Float</haxe_doc>
		</getPositionY>
		<getPositionX public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Function: getPositionX
	 * 
	 * Returns:
		 * Float</haxe_doc>
		</getPositionX>
		<getPosition public="1" set="method">
			<f a=""><c path="firmament.core.FVector"/></f>
			<haxe_doc><![CDATA[* Function: getPosition
	 * 
	 * Returns:
		 * <FVector>]]></haxe_doc>
		</getPosition>
		<setPosition public="1" set="method">
			<f a="pos">
				<c path="firmament.core.FVector"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Function: setPosition
	 * 
	 * Parameters:
		 * pos - <FVector>]]></haxe_doc>
		</setPosition>
		<init public="1" set="method"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<haxe_doc>* Interface: FPhysicsComponentInterface
 * Author: Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.component.physics.FBox2DComponent" params="" file="../../lib/firmament/component/physics/FBox2DComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<implements path="firmament.world.FWorldPositionalInterface"/>
		<implements path="firmament.component.physics.FPhysicsComponentInterface"/>
		<destruct public="1" set="method" line="359" override="1"><f a=""><e path="Void"/></f></destruct>
		<getShapes public="1" set="method" line="333"><f a=""><c path="Array"><c path="firmament.core.FShape"/></c></f></getShapes>
		<hasShapes public="1" set="method" line="328"><f a=""><e path="Bool"/></f></hasShapes>
		<getType public="1" set="method" line="324" override="1"><f a=""><c path="String"/></f></getType>
		<getWorld public="1" set="method" line="320"><f a=""><c path="firmament.world.FWorld"/></f></getWorld>
		<setWorld public="1" set="method" line="316"><f a="world">
	<c path="firmament.world.FWorld"/>
	<e path="Void"/>
</f></setWorld>
		<setZPosition public="1" set="method" line="313"><f a="p">
	<c path="Float"/>
	<e path="Void"/>
</f></setZPosition>
		<getZPosition public="1" set="method" line="310"><f a=""><c path="Float"/></f></getZPosition>
		<addAngularVelocity public="1" set="method" line="304"><f a="omega">
	<c path="Float"/>
	<e path="Void"/>
</f></addAngularVelocity>
		<getAngularVelocity public="1" set="method" line="300"><f a=""><c path="Float"/></f></getAngularVelocity>
		<setAngularVelocity public="1" set="method" line="296"><f a="omega">
	<c path="Float"/>
	<e path="Void"/>
</f></setAngularVelocity>
		<getLinearVelocity public="1" set="method" line="292"><f a=""><c path="firmament.core.FVector"/></f></getLinearVelocity>
		<setLinearVelocity public="1" set="method" line="287"><f a="vel">
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></setLinearVelocity>
		<applyLinearForce public="1" set="method" line="281"><f a="v:?point">
	<c path="firmament.core.FVector"/>
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></applyLinearForce>
		<getAngle public="1" set="method" line="277"><f a=""><c path="Float"/></f></getAngle>
		<setAngle public="1" set="method" line="273"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></setAngle>
		<getPositionY public="1" set="method" line="269"><f a=""><c path="Float"/></f></getPositionY>
		<getPositionX public="1" set="method" line="265"><f a=""><c path="Float"/></f></getPositionX>
		<setPosition public="1" set="method" line="260"><f a="pos">
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></setPosition>
		<getPosition public="1" set="method" line="254"><f a=""><c path="firmament.core.FVector"/></f></getPosition>
		<deactivate set="method" line="249"><f a="?e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></deactivate>
		<onActiveStateChange public="1" set="method" line="237"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onActiveStateChange>
		<createJointEntity public="1" set="method" line="185"><f a="joint">
	<d/>
	<e path="Void"/>
</f></createJointEntity>
		<removeEventHandlers set="method" line="177"><f a=""><e path="Void"/></f></removeEventHandlers>
		<registerEventHandlers set="method" line="173"><f a=""><e path="Void"/></f></registerEventHandlers>
		<init public="1" set="method" line="52" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<world><c path="firmament.world.FWorld"/></world>
		<position><c path="firmament.core.FVector"/></position>
		<zPosition><c path="Float"/></zPosition>
		<body public="1"><c path="box2D.dynamics.B2Body"/></body>
		<new public="1" set="method" line="44"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Class: FBox2DComponent
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.component.physics.FNoPhysicsComponent" params="" file="../../lib/firmament/component/physics/FNoPhysicsComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<implements path="firmament.world.FWorldPositionalInterface"/>
		<implements path="firmament.component.physics.FPhysicsComponentInterface"/>
		<destruct public="1" set="method" line="265" override="1"><f a=""><e path="Void"/></f></destruct>
		<getShapes public="1" set="method" line="262"><f a=""><c path="Array"><c path="firmament.core.FShape"/></c></f></getShapes>
		<getBottomY public="1" set="method" line="259"><f a=""><c path="Float"/></f></getBottomY>
		<getBottomX public="1" set="method" line="255"><f a=""><c path="Float"/></f></getBottomX>
		<getTopY public="1" set="method" line="251"><f a=""><c path="Float"/></f></getTopY>
		<getTopX public="1" set="method" line="247"><f a=""><c path="Float"/></f></getTopX>
		<getHeight public="1" set="method" line="243"><f a=""><c path="Float"/></f></getHeight>
		<getWidth public="1" set="method" line="239"><f a=""><c path="Float"/></f></getWidth>
		<isSleeping public="1" set="method" line="235"><f a=""><e path="Bool"/></f></isSleeping>
		<hasShapes public="1" set="method" line="231"><f a=""><e path="Bool"/></f></hasShapes>
		<getType public="1" set="method" line="227" override="1"><f a=""><c path="String"/></f></getType>
		<getWorld public="1" set="method" line="223"><f a=""><c path="firmament.core.FNoPhysicsWorld"/></f></getWorld>
		<setWorld public="1" set="method" line="219"><f a="world">
	<c path="firmament.world.FWorld"/>
	<e path="Void"/>
</f></setWorld>
		<setZPosition public="1" set="method" line="215"><f a="p">
	<c path="Float"/>
	<e path="Void"/>
</f></setZPosition>
		<getZPosition public="1" set="method" line="211"><f a=""><c path="Float"/></f></getZPosition>
		<addAngularVelocity public="1" set="method" line="205"><f a="omega">
	<c path="Float"/>
	<e path="Void"/>
</f></addAngularVelocity>
		<getAngularVelocity public="1" set="method" line="201"><f a=""><c path="Float"/></f></getAngularVelocity>
		<setAngularVelocity public="1" set="method" line="196"><f a="omega">
	<c path="Float"/>
	<e path="Void"/>
</f></setAngularVelocity>
		<getLinearVelocity public="1" set="method" line="192"><f a=""><c path="firmament.core.FVector"/></f></getLinearVelocity>
		<setLinearVelocity public="1" set="method" line="186"><f a="vel">
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></setLinearVelocity>
		<applyLinearForce public="1" set="method" line="179"><f a="v:?point">
	<c path="firmament.core.FVector"/>
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></applyLinearForce>
		<getAngle public="1" set="method" line="175"><f a=""><c path="Float"/></f></getAngle>
		<setAngle public="1" set="method" line="171"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></setAngle>
		<getPositionY public="1" set="method" line="167"><f a=""><c path="Float"/></f></getPositionY>
		<getPositionX public="1" set="method" line="163"><f a=""><c path="Float"/></f></getPositionX>
		<setPosition public="1" set="method" line="154"><f a="pos">
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></setPosition>
		<getPosition public="1" set="method" line="150"><f a=""><c path="firmament.core.FVector"/></f></getPosition>
		<deactivate set="method" line="146"><f a="?e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></deactivate>
		<onActiveStateChange public="1" set="method" line="142"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onActiveStateChange>
		<removeEventHandlers set="method" line="138"><f a=""><e path="Void"/></f></removeEventHandlers>
		<registerEventHandlers set="method" line="134"><f a=""><e path="Void"/></f></registerEventHandlers>
		<buildShape set="method" line="125"><f a=""><e path="Void"/></f></buildShape>
		<init public="1" set="method" line="52" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_deleted><e path="Bool"/></_deleted>
		<_shape><c path="firmament.core.FPolygonShape"/></_shape>
		<_height><c path="Float"/></_height>
		<_width><c path="Float"/></_width>
		<_linearVelocity><c path="firmament.core.FVector"/></_linearVelocity>
		<_angularVelocity><c path="Float"/></_angularVelocity>
		<_isActive><e path="Bool"/></_isActive>
		<_isSleeping><e path="Bool"/></_isSleeping>
		<_allowSleep><e path="Bool"/></_allowSleep>
		<_fixedRotation><e path="Bool"/></_fixedRotation>
		<_angle><c path="Float"/></_angle>
		<world><c path="firmament.core.FNoPhysicsWorld"/></world>
		<position><c path="firmament.core.FVector"/></position>
		<_zPosition><c path="Float"/></_zPosition>
		<new public="1" set="method" line="40"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Class: FBox2DComponent
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.component.render.FRenderComponentInterface" params="" file="../../lib/firmament/component/render/FRenderComponentInterface.hx" interface="1">
		<getParallaxMultiplier public="1" set="method"><f a=""><c path="Float"/></f></getParallaxMultiplier>
		<getBitmapData public="1" set="method"><f a=""><t path="nme.display.BitmapData"/></f></getBitmapData>
		<render public="1" set="method"><f a="camera">
	<c path="firmament.core.FCamera"/>
	<e path="Void"/>
</f></render>
		<haxe_doc>* Class: FRenderer</haxe_doc>
	</class>
	<class path="firmament.component.render.FTilesheetRenderComponent" params="" file="../../lib/firmament/component/render/FTilesheetRenderComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<implements path="firmament.component.render.FRenderComponentInterface"/>
		<getParallaxMultiplier public="1" set="method" line="176"><f a=""><c path="Float"/></f></getParallaxMultiplier>
		<getType public="1" set="method" line="172" override="1"><f a=""><c path="String"/></f></getType>
		<getBitmapData public="1" set="method" line="159"><f a=""><t path="nme.display.BitmapData"/></f></getBitmapData>
		<setImageScale public="1" set="method" line="155"><f a="scale">
	<c path="Float"/>
	<e path="Void"/>
</f></setImageScale>
		<setTilesheet public="1" set="method" line="150"><f a="t">
	<c path="firmament.core.FTilesheet"/>
	<e path="Void"/>
</f></setTilesheet>
		<getTilesheet public="1" set="method" line="145"><f a=""><c path="firmament.core.FTilesheet"/></f></getTilesheet>
		<setTile public="1" set="method" line="141"><f a="t">
	<c path="Int"/>
	<e path="Void"/>
</f></setTile>
		<render public="1" set="method" line="108"><f a="camera">
	<c path="firmament.core.FCamera"/>
	<e path="Void"/>
</f></render>
		<initTilesheet public="1" set="method" line="69"><f a=""><e path="Void"/></f></initTilesheet>
		<init public="1" set="method" line="47" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_parallax><c path="Float"/></_parallax>
		<_tile><c path="Int"/></_tile>
		<imageScale><c path="Float"/></imageScale>
		<_tilesheet><c path="firmament.core.FTilesheet"/></_tilesheet>
		<drawList><c path="Array"><c path="Float"/></c></drawList>
		<new public="1" set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author jordan</haxe_doc>
	</class>
	<class path="firmament.component.render.FWireframeRenderComponent" params="" file="../../lib/firmament/component/render/FWireframeRenderComponent.hx">
		<extends path="firmament.component.base.FEntityComponent"/>
		<implements path="firmament.component.render.FRenderComponentInterface"/>
		<getParallaxMultiplier public="1" set="method" line="104"><f a=""><c path="Float"/></f></getParallaxMultiplier>
		<getType public="1" set="method" line="101" override="1"><f a=""><c path="String"/></f></getType>
		<getBitmapData public="1" set="method" line="97"><f a=""><t path="nme.display.BitmapData"/></f></getBitmapData>
		<render public="1" set="method" line="40"><f a="camera">
	<c path="firmament.core.FCamera"/>
	<e path="Void"/>
</f></render>
		<init public="1" set="method" line="36" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.core.FAnimation" params="" file="../../lib/firmament/core/FAnimation.hx">
		<getNextFrame public="1" set="method" line="71">
			<f a="currentFrame">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Function: getNextFrame
	 * Given the provided frame index, it returns the next one in the animation sequence.</haxe_doc>
		</getNextFrame>
		<getTileIndexForFrame public="1" set="method" line="62">
			<f a="frame">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>* Function: getTileIndexForFrame
	 * returns the tilesheet tile index for the specified animation frame</haxe_doc>
		</getTileIndexForFrame>
		<getTimeBetweenFrames public="1" set="method" line="54"><f a=""><c path="Float"/></f></getTimeBetweenFrames>
		<setTilesheet public="1" set="method" line="50"><f a="t">
	<c path="firmament.core.FTilesheet"/>
	<e path="Void"/>
</f></setTilesheet>
		<getTilesheet public="1" set="method" line="46"><f a=""><c path="firmament.core.FTilesheet"/></f></getTilesheet>
		<init public="1" set="method" line="18"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_config><d/></_config>
		<_timeBetweenFrames><c path="Float"/></_timeBetweenFrames>
		<_frames><c path="Array"><c path="Int"/></c></_frames>
		<_tilesheet><c path="firmament.core.FTilesheet"/></_tilesheet>
		<new public="1" set="method" line="14"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.core.FAnimationManager" params="" file="../../lib/firmament/core/FAnimationManager.hx">
		<_instance static="1"><c path="firmament.core.FAnimationManager"/></_instance>
		<getInstance public="1" set="method" line="18" static="1"><f a=""><c path="firmament.core.FAnimationManager"/></f></getInstance>
		<getAnimationByFileName public="1" set="method" line="34">
			<f a="fileName">
				<c path="String"/>
				<c path="firmament.core.FAnimation"/>
			</f>
			<haxe_doc>* Function: getAnimationByFileName
	 * returns an animation defined in the specified file. Will either load from file or internal cache.</haxe_doc>
		</getAnimationByFileName>
		<addAnimation public="1" set="method" line="26"><f a="fileName:animation">
	<c path="String"/>
	<c path="firmament.core.FAnimation"/>
	<e path="Void"/>
</f></addAnimation>
		<_animationsHash><c path="Hash"><c path="firmament.core.FAnimation"/></c></_animationsHash>
		<new set="method" line="13"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.core.FPhysicsWorldContactListener" params="" file="../../lib/firmament/core/FBox2DWorld.hx" module="firmament.world.FBox2DWorld">
		<extends path="box2D.dynamics.B2ContactListener"/>
		<preSolve public="1" set="method" line="50" override="1"><f a="contact:oldManifold">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<c path="box2D.collision.B2Manifold"/>
	<e path="Void"/>
</f></preSolve>
		<endContact public="1" set="method" line="43" override="1"><f a="contact">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<e path="Void"/>
</f></endContact>
		<beginContact public="1" set="method" line="34" override="1"><f a="contact">
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<e path="Void"/>
</f></beginContact>
		<world><c path="firmament.world.FBox2DWorld"/></world>
		<new public="1" set="method" line="27"><f a="world">
	<c path="firmament.world.FBox2DWorld"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaughz</haxe_doc>
	</class>
	<class path="firmament.world.FWorld" params="" file="../../lib/firmament/core/FWorld.hx">
		<destruct public="1" set="method" line="97"><f a=""><e path="Void"/></f></destruct>
		<getAlwaysRenderEntities public="1" set="method" line="93"><f a=""><c path="Array"><c path="firmament.core.FEntity"/></c></f></getAlwaysRenderEntities>
		<removeFromAlwaysRenderList public="1" set="method" line="89"><f a="ent">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></removeFromAlwaysRenderList>
		<addToAlwaysRenderList public="1" set="method" line="85"><f a="ent">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></addToAlwaysRenderList>
		<insideStep public="1" set="method" line="81"><f a=""><e path="Bool"/></f></insideStep>
		<setGravity public="1" set="method" line="77"><f a="gravity">
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></setGravity>
		<getType public="1" set="method" line="73"><f a=""><c path="String"/></f></getType>
		<deleteEntity public="1" set="method" line="68"><f a="ent">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></deleteEntity>
		<getTimeSinceLastStep public="1" set="method" line="62">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* returns the elapsed time since the last step in seconds.</haxe_doc>
		</getTimeSinceLastStep>
		<endOfStep set="method" line="55">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* This should always be called at the end of a step in a subclass.</haxe_doc>
		</endOfStep>
		<step public="1" set="method" line="49"><f a=""><e path="Void"/></f></step>
		<getEntitiesInBox public="1" set="method" line="44"><f a="topLeftX:topLeftY:bottomRightX:bottomRightY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesInBox>
		<getEntitiesAtPoint public="1" set="method" line="38"><f a="p">
	<c path="firmament.core.FVector"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesAtPoint>
		<getAllEntities public="1" set="method" line="34"><f a=""><c path="Array"><c path="firmament.core.FEntity"/></c></f></getAllEntities>
		<addEntity public="1" set="method" line="30"><f a="ent">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></addEntity>
		<init public="1" set="method" line="26"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<_config><d/></_config>
		<_alwaysRenderEntities><c path="Array"><c path="firmament.core.FEntity"/></c></_alwaysRenderEntities>
		<lastStep><c path="Float"/></lastStep>
		<entities><c path="Array"><c path="firmament.core.FEntity"/></c></entities>
		<new public="1" set="method" line="19"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.world.FBox2DWorld" params="" file="../../lib/firmament/core/FBox2DWorld.hx">
		<extends path="firmament.world.FWorld"/>
		<destruct public="1" set="method" line="205" override="1"><f a=""><e path="Void"/></f></destruct>
		<insideStep public="1" set="method" line="201" override="1"><f a=""><e path="Bool"/></f></insideStep>
		<setGravity public="1" set="method" line="197" override="1"><f a="gravity">
	<c path="box2D.common.math.B2Vec2"/>
	<e path="Void"/>
</f></setGravity>
		<getType public="1" set="method" line="193" override="1"><f a=""><c path="String"/></f></getType>
		<deleteEntity public="1" set="method" line="180" override="1"><f a="ent">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></deleteEntity>
		<step public="1" set="method" line="151" override="1"><f a=""><e path="Void"/></f></step>
		<getB2World public="1" set="method" line="145"><f a=""><c path="box2D.dynamics.B2World"/></f></getB2World>
		<getEntitiesAtPoint public="1" set="method" line="118" override="1"><f a="p">
	<c path="firmament.core.FVector"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesAtPoint>
		<rayCast public="1" set="method" line="114"><f a="a:b:callbackMethod">
	<c path="firmament.core.FVector"/>
	<c path="firmament.core.FVector"/>
	<f a=":::">
		<c path="box2D.dynamics.B2Fixture"/>
		<c path="box2D.common.math.B2Vec2"/>
		<c path="box2D.common.math.B2Vec2"/>
		<c path="Float"/>
		<d/>
	</f>
	<e path="Void"/>
</f></rayCast>
		<getEntitiesRay public="1" set="method" line="104"><f a="a:b">
	<c path="firmament.core.FVector"/>
	<c path="firmament.core.FVector"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesRay>
		<getEntitiesInBox public="1" set="method" line="89" override="1"><f a="topLeftX:topLeftY:bottomRightX:bottomRightY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesInBox>
		<init public="1" set="method" line="83" override="1"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<deleteQueue><c path="Array"><c path="firmament.core.FEntity"/></c></deleteQueue>
		<_inStep><e path="Bool"/></_inStep>
		<_b2world><c path="box2D.dynamics.B2World"/></_b2world>
		<new public="1" set="method" line="74"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<z public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<visible public="1"><e path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotationZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<rotationY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotation public="1"><c path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><c path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><c path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<requestSoftKeyboard public="1">
			<f a=""><e path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<needsSoftKeyboard public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<removeChildren public="1">
			<f a="?beginIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</removeChildren>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopTouchDrag public="1" set="method">
			<f a="touchPointID">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<startTouchDrag public="1" set="method">
			<f a="touchPointID:?lockCenter:?bounds">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</startTouchDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.core.FCamera" params="" file="../../lib/firmament/core/FCamera.hx">
		<extends path="flash.display.Sprite"/>
		<implements path="firmament.world.FWorldPositionalInterface"/>
		<BEFORE_RENDER_EVENT public="1" get="inline" set="null" line="26" static="1"><c path="String"/></BEFORE_RENDER_EVENT>
		<AFTER_RENDER_EVENT public="1" get="inline" set="null" line="27" static="1"><c path="String"/></AFTER_RENDER_EVENT>
		<setAngle public="1" set="method" line="236"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></setAngle>
		<getAngle public="1" set="method" line="233"><f a=""><c path="Float"/></f></getAngle>
		<setDebugMode public="1" set="method" line="229"><f a="debug">
	<e path="Bool"/>
	<e path="Void"/>
</f></setDebugMode>
		<getWorldPosition public="1" set="method" line="221"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="firmament.core.FVector"/>
</f></getWorldPosition>
		<resizeToStage public="1" set="method" line="212"><f a=""><e path="Void"/></f></resizeToStage>
		<setZoom public="1" set="method" line="208">
			<f a="z">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Function: setZoom
	 * 
	 * The zoom is 'pixels per meter'. By default, this value is set to 100, meaning we show 100 pixels for each meter in world space.
	 * 
	 * Parameters:
		 * z - Float
	 * 
	 * See Also: 
		 * <getZoom>]]></haxe_doc>
		</setZoom>
		<getZoom public="1" set="method" line="193">
			<f a=""><c path="Float"/></f>
			<haxe_doc><![CDATA[* Function: getZoom
	 * 
	 * The zoom is 'pixels per meter'. By default, this value is set to 100, meaning we show 100 pixels for each meter in world space.
	 * 
	 * Returns: 
		 * Float - the camera's current zoom value.
	 * 
	 * 
	 * See Also: 
		 * <setZoom>]]></haxe_doc>
		</getZoom>
		<getPositionY public="1" set="method" line="177">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Function: getPositionY
	 * 
	 * Returns:
		 * Float</haxe_doc>
		</getPositionY>
		<getPositionX public="1" set="method" line="167">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* Function: getPositionX
	 * 
	 * Returns:
		 * Float</haxe_doc>
		</getPositionX>
		<getPosition public="1" set="method" line="157">
			<f a=""><c path="firmament.core.FVector"/></f>
			<haxe_doc><![CDATA[* Function: getPosition
	 * 
	 * Returns:
		 * <FVector>]]></haxe_doc>
		</getPosition>
		<setPosition public="1" set="method" line="147">
			<f a="pos">
				<c path="firmament.core.FVector"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Function: setPosition
	 * 
	 * Parameters:
		 * pos - <FVector>]]></haxe_doc>
		</setPosition>
		<getBottomRightPosition public="1" set="method" line="133"><f a="?parallax">
	<c path="Float"/>
	<c path="firmament.core.FVector"/>
</f></getBottomRightPosition>
		<getTopLeftPosition public="1" set="method" line="126"><f a="?parallax">
	<c path="Float"/>
	<c path="firmament.core.FVector"/>
</f></getTopLeftPosition>
		<calculateTopLeftPosition set="method" line="119"><f a="?parallax">
	<c path="Float"/>
	<e path="Void"/>
</f></calculateTopLeftPosition>
		<render public="1" set="method" line="75"><f a="worlds">
	<c path="Hash"><c path="firmament.world.FWorld"/></c>
	<e path="Void"/>
</f></render>
		<init public="1" set="method" line="62"><f a="config">
	<d/>
	<e path="Void"/>
</f></init>
		<calculatedTopLeft><e path="Bool"/></calculatedTopLeft>
		<_debugRenderer><c path="firmament.component.render.FWireframeRenderComponent"/></_debugRenderer>
		<_debugRender><e path="Bool"/></_debugRender>
		<displayHeight><c path="Int"/></displayHeight>
		<displayWidth><c path="Int"/></displayWidth>
		<zoom><c path="Float"/></zoom>
		<angle><c path="Float"/></angle>
		<positionBase><c path="String"/></positionBase>
		<topLeftPosition><c path="firmament.core.FVector"/></topLeftPosition>
		<position><c path="firmament.core.FVector"/></position>
		<new public="1" set="method" line="47">
			<f a="?width:?height">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor: new
	 * 
	 * Parameters:
		 * width - Int The width of the camera
		 * height - Int The height of the camera</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Class: FCamera
 * 
 * Extends: Sprite
 * 
 * Implements: <FWorldPositionalInterface>
 * 
 * @author Jordan Wambaugh]]></haxe_doc>
	</class>
	<class path="firmament.core.FShape" params="" file="../../lib/firmament/core/FShape.hx"><new public="1" set="method" line="6"><f a=""><e path="Void"/></f></new></class>
	<class path="firmament.core.FCircleShape" params="" file="../../lib/firmament/core/FCircleShape.hx">
		<extends path="firmament.core.FShape"/>
		<getLocalPosition public="1" set="method" line="22"><f a=""><c path="firmament.core.FVector"/></f></getLocalPosition>
		<setRadius public="1" set="method" line="19"><f a="r">
	<c path="Float"/>
	<e path="Void"/>
</f></setRadius>
		<getRadius public="1" set="method" line="15"><f a=""><c path="Float"/></f></getRadius>
		<_localPosition><c path="firmament.core.FVector"/></_localPosition>
		<_radius><c path="Float"/></_radius>
		<new public="1" set="method" line="9"><f a="r:pos">
	<c path="Float"/>
	<c path="firmament.core.FVector"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.core.FEntity" params="" file="../../lib/firmament/core/FEntity.hx">
		<extends path="flash.events.EventDispatcher"/>
		<ACTIVE_STATE_CHANGE public="1" get="inline" set="null" line="32" static="1"><c path="String"/></ACTIVE_STATE_CHANGE>
		<hasTag public="1" set="method" line="185"><f a="tag">
	<c path="String"/>
	<e path="Bool"/>
</f></hasTag>
		<removeTag public="1" set="method" line="181"><f a="tag">
	<c path="String"/>
	<e path="Void"/>
</f></removeTag>
		<addTag public="1" set="method" line="177"><f a="tag">
	<c path="String"/>
	<e path="Void"/>
</f></addTag>
		<getTags public="1" set="method" line="173"><f a=""><c path="Array"><c path="String"/></c></f></getTags>
		<returnToPool public="1" set="method" line="161"><f a=""><e path="Void"/></f></returnToPool>
		<getPool public="1" set="method" line="157"><f a=""><c path="firmament.core.FEntityPool"/></f></getPool>
		<setPool public="1" set="method" line="154"><f a="pool">
	<c path="firmament.core.FEntityPool"/>
	<e path="Void"/>
</f></setPool>
		<isActive public="1" set="method" line="150"><f a=""><e path="Bool"/></f></isActive>
		<setActive public="1" set="method" line="143"><f a="active">
	<e path="Bool"/>
	<e path="Void"/>
</f></setActive>
		<delete public="1" set="method" line="131">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Function: delete
	 * Deleted the entity</haxe_doc>
		</delete>
		<getConfig public="1" set="method" line="123"><f a=""><d/></f></getConfig>
		<setComponent public="1" set="method" line="110"><f a="component">
	<c path="firmament.component.base.FEntityComponent"/>
	<e path="Void"/>
</f></setComponent>
		<getRenderComponent public="1" set="method" line="101"><f a=""><c path="firmament.component.render.FRenderComponentInterface"/></f></getRenderComponent>
		<getPhysicsComponent public="1" set="method" line="93">
			<f a=""><c path="firmament.component.physics.FPhysicsComponentInterface"/></f>
			<haxe_doc><![CDATA[* Function: getPhysicsComponent()
	 *	returns a physics component
	 * 
	 * Parameters: 
	 *	none
	 *
	 * Returns:
	 *	<FPysicsComponentInterface>]]></haxe_doc>
		</getPhysicsComponent>
		<getAllComponents public="1" set="method" line="78"><f a=""><c path="Array"><c path="firmament.component.base.FEntityComponent"/></c></f></getAllComponents>
		<getComponent public="1" set="method" line="74">
			<f a="type">
				<c path="String"/>
				<c path="Array"><c path="firmament.component.base.FEntityComponent"/></c>
			</f>
			<haxe_doc>* 
	 * 
	 * @return  [FentityComponent]</haxe_doc>
		</getComponent>
		<getTypeId public="1" set="method" line="64"><f a=""><c path="String"/></f></getTypeId>
		<_tags><c path="Array"><c path="String"/></c></_tags>
		<_listeners><c path="Hash"><d/></c></_listeners>
		<_typeId><c path="String"/></_typeId>
		<_active><e path="Bool"/></_active>
		<_pool><c path="firmament.core.FEntityPool"/></_pool>
		<_components><c path="Array"><c path="firmament.component.base.FEntityComponent"/></c></_components>
		<_componentsHash><c path="Hash"><c path="Array"><c path="firmament.component.base.FEntityComponent"/></c></c></_componentsHash>
		<_config><d/></_config>
		<new public="1" set="method" line="40">
			<f a="config">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 
	 * Config Paramers:
	 * 	imageScale - [Float] The initial scale value for the sprite.
	 * 	sprite  - [BitmapData] The image to use as a sprite for this entity</haxe_doc>
		</new>
		<haxe_doc>* Base class for all entities in Firmament
  * 
  *</haxe_doc>
	</class>
	<class path="firmament.core.FEntityFactory" params="" file="../../lib/firmament/core/FEntityFactory.hx">
		<createEntity public="1" set="method" line="10" static="1"><f a="config">
	<d/>
	<c path="firmament.core.FEntity"/>
</f></createEntity>
		<applyComponents public="1" set="method" line="40" static="1"><f a="entity:config">
	<c path="firmament.core.FEntity"/>
	<d/>
	<e path="Void"/>
</f></applyComponents>
		<initComponents public="1" set="method" line="53" static="1"><f a="entity:config">
	<c path="firmament.core.FEntity"/>
	<d/>
	<e path="Void"/>
</f></initComponents>
	</class>
	<class path="firmament.core.FEntityPool" params="" file="../../lib/firmament/core/FEntityPool.hx">
		<getEntity public="1" set="method" line="40"><f a=""><c path="firmament.core.FEntity"/></f></getEntity>
		<addEntity public="1" set="method" line="36"><f a="entity">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></addEntity>
		<preAllocate set="method" line="27"><f a="number">
	<c path="Int"/>
	<e path="Void"/>
</f></preAllocate>
		<getEntityTypeId public="1" set="method" line="23"><f a=""><c path="String"/></f></getEntityTypeId>
		<_entities><c path="Array"><c path="firmament.core.FEntity"/></c></_entities>
		<_entityConfig><d/></_entityConfig>
		<new public="1" set="method" line="14"><f a="config:?preAllocate">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.core.FEntityPoolManager" params="" file="../../lib/firmament/core/FEntityPoolManager.hx">
		<addPool public="1" set="method" line="20"><f a="pool">
	<c path="firmament.core.FEntityPool"/>
	<e path="Void"/>
</f></addPool>
		<getPool public="1" set="method" line="16"><f a="entityTypeId">
	<c path="String"/>
	<t path="Null"><c path="firmament.core.FEntityPool"/></t>
</f></getPool>
		<pools><c path="Hash"><c path="firmament.core.FEntityPool"/></c></pools>
		<new public="1" set="method" line="12"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.core.FGame" params="" file="../../lib/firmament/core/FGame.hx">
		<extends path="flash.events.EventDispatcher"/>
		<COLLISION_PRE_SOLVE_EVENT public="1" get="inline" set="null" line="51" static="1"><c path="String"/></COLLISION_PRE_SOLVE_EVENT>
		<COLLISION_POST_SOLVE_EVENT public="1" get="inline" set="null" line="54" static="1"><c path="String"/></COLLISION_POST_SOLVE_EVENT>
		<COLLISION_BEGIN_CONTACT_EVENT public="1" get="inline" set="null" line="57" static="1"><c path="String"/></COLLISION_BEGIN_CONTACT_EVENT>
		<COLLISION_END_CONTACT_EVENT public="1" get="inline" set="null" line="60" static="1"><c path="String"/></COLLISION_END_CONTACT_EVENT>
		<BEFORE_STEP public="1" get="inline" set="null" line="67" static="1"><c path="String"/></BEFORE_STEP>
		<AFTER_STEP public="1" get="inline" set="null" line="70" static="1"><c path="String"/></AFTER_STEP>
		<BEFORE_RENDER public="1" get="inline" set="null" line="73" static="1"><c path="String"/></BEFORE_RENDER>
		<AFTER_RENDER public="1" get="inline" set="null" line="76" static="1"><c path="String"/></AFTER_RENDER>
		<DELETE_ENTITY public="1" get="inline" set="null" line="79" static="1"><c path="String"/></DELETE_ENTITY>
		<_instance static="1"><c path="firmament.core.FGame"/></_instance>
		<getInstance public="1" set="method" line="124" static="1"><f a=""><c path="firmament.core.FGame"/></f></getInstance>
		<clearAll public="1" set="method" line="328"><f a=""><e path="Void"/></f></clearAll>
		<clearWorlds public="1" set="method" line="317"><f a=""><e path="Void"/></f></clearWorlds>
		<getPoolManager public="1" set="method" line="308"><f a=""><c path="firmament.core.FEntityPoolManager"/></f></getPoolManager>
		<this_onEnterFrame set="method" line="299"><f a="event">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></this_onEnterFrame>
		<doStep set="method" line="290"><f a=""><e path="Void"/></f></doStep>
		<getMainInput public="1" set="method" line="285"><f a=""><c path="firmament.core.FInput"/></f></getMainInput>
		<getCamera public="1" set="method" line="275">
			<f a="name">
				<c path="String"/>
				<c path="firmament.core.FCamera"/>
			</f>
			<haxe_doc><![CDATA[*	Function: getCamera
	 *	Parameters:
	 *		name - String the name of the camera to retrieve
	 *	Returns: <FCamera>]]></haxe_doc>
		</getCamera>
		<addCamera public="1" set="method" line="263">
			<f a="name:c">
				<c path="String"/>
				<c path="firmament.core.FCamera"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Function: addCamera
	 * 
	 * Adds a new <FCamera> object to the game. Cameras must be added to the game in order for them to work.
	 * 
	 * Parameters:
	 *	name - String the name to call the camera. Used for getting the right camera.
	 *	c - <FCamera> The camera to add]]></haxe_doc>
		</addCamera>
		<addProcess public="1" set="method" line="250">
			<f a="?type:p">
				<c path="String"/>
				<c path="firmament.process.base.FProcess"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: addProcess
	 *
	 * Parameters: 
	 *  name - String identifier for object, for retrieval
	 *  p - Process object</haxe_doc>
		</addProcess>
		<getRenderProcessManager public="1" set="method" line="238">
			<f a=""><c path="firmament.process.base.FProcessManager"/></f>
			<haxe_doc>* Function: getRenderProcessManager</haxe_doc>
		</getRenderProcessManager>
		<getProcessManager public="1" set="method" line="231">
			<f a=""><c path="firmament.process.base.FProcessManager"/></f>
			<haxe_doc>* Function: getProcessManager</haxe_doc>
		</getProcessManager>
		<queryEntities public="1" set="method" line="196"><f a="query">
	<d/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></queryEntities>
		<getEntitiesInBox public="1" set="method" line="170"><f a="topLeftX:topLeftY:bottomRightX:bottomRightY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesInBox>
		<getEntitiesAtPoint public="1" set="method" line="162"><f a="p">
	<c path="firmament.core.FVector"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesAtPoint>
		<getAllEntities public="1" set="method" line="154"><f a=""><c path="Array"><c path="firmament.core.FEntity"/></c></f></getAllEntities>
		<getWorlds public="1" set="method" line="150"><f a=""><c path="Hash"><c path="firmament.world.FWorld"/></c></f></getWorlds>
		<getWorld public="1" set="method" line="136">
			<f a="type">
				<c path="String"/>
				<c path="firmament.world.FWorld"/>
			</f>
			<haxe_doc>* Function: getWorld
	 *
	 * Returns: an FWorld object of the type provided</haxe_doc>
		</getWorld>
		<loadGameConfig public="1" set="method" line="108"><f a="fileName">
	<c path="String"/>
	<e path="Void"/>
</f></loadGameConfig>
		<_poolManager><c path="firmament.core.FEntityPoolManager"/></_poolManager>
		<_mainInput><c path="firmament.core.FInput"/></_mainInput>
		<_renderProcessManager><c path="firmament.process.base.FProcessManager"/></_renderProcessManager>
		<processManager><c path="firmament.process.base.FProcessManager"/></processManager>
		<enableSimulation public="1"><e path="Bool"/></enableSimulation>
		<worldHash><c path="Hash"><c path="firmament.world.FWorld"/></c></worldHash>
		<cameras><c path="Hash"><c path="firmament.core.FCamera"/></c></cameras>
		<new set="method" line="86">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Constructor: new</haxe_doc>
		</new>
		<haxe_doc>* Class: FGame</haxe_doc>
	</class>
	<class path="firmament.core.FInput" params="" file="../../lib/firmament/core/FInput.hx">
		<defineKeyMap set="method" line="138"><f a=""><e path="Void"/></f></defineKeyMap>
		<getKeyCode public="1" set="method" line="131"><f a="keyName">
	<c path="String"/>
	<c path="Int"/>
</f></getKeyCode>
		<isKeyNamePressed public="1" set="method" line="127"><f a="keyName">
	<c path="String"/>
	<e path="Bool"/>
</f></isKeyNamePressed>
		<isKeyPressed public="1" set="method" line="121"><f a="keyCode">
	<c path="Int"/>
	<e path="Bool"/>
</f></isKeyPressed>
		<getStageY public="1" set="method" line="116"><f a=""><c path="Float"/></f></getStageY>
		<getStageX public="1" set="method" line="112"><f a=""><c path="Float"/></f></getStageX>
		<getLocalY public="1" set="method" line="108"><f a=""><c path="Float"/></f></getLocalY>
		<getLocalX public="1" set="method" line="104"><f a=""><c path="Float"/></f></getLocalX>
		<isTouching public="1" set="method" line="100"><f a=""><e path="Bool"/></f></isTouching>
		<touchEnd public="1" set="method" line="90"><f a="e">
	<t path="nme.events.TouchEvent"/>
	<e path="Void"/>
</f></touchEnd>
		<touchBegin public="1" set="method" line="83"><f a="e">
	<t path="nme.events.TouchEvent"/>
	<e path="Void"/>
</f></touchBegin>
		<keyboardEventUp public="1" set="method" line="79"><f a="e">
	<t path="nme.events.KeyboardEvent"/>
	<e path="Void"/>
</f></keyboardEventUp>
		<keyboardEventDown public="1" set="method" line="75"><f a="e">
	<t path="nme.events.KeyboardEvent"/>
	<e path="Void"/>
</f></keyboardEventDown>
		<mouseUp public="1" set="method" line="66"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseUp>
		<mouseDown public="1" set="method" line="59"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseDown>
		<mouseEvent public="1" set="method" line="53"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseEvent>
		<_touching><e path="Bool"/></_touching>
		<_keyMap><d/></_keyMap>
		<keyStatus><c path="Array"><e path="Bool"/></c></keyStatus>
		<stageY><c path="Float"/></stageY>
		<stageX><c path="Float"/></stageX>
		<localY><c path="Float"/></localY>
		<localX><c path="Float"/></localX>
		<mainButtonPressed><e path="Bool"/></mainButtonPressed>
		<pressedKeys><c path="Array"><c path="Int"/></c></pressedKeys>
		<observable><t path="nme.events.EventDispatcher"/></observable>
		<new public="1" set="method" line="26"><f a="o">
	<t path="nme.events.EventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.core.FNoPhysicsWorld" params="" file="../../lib/firmament/core/FNoPhysicsWorld.hx">
		<extends path="firmament.world.FWorld"/>
		<destruct public="1" set="method" line="126" override="1"><f a=""><e path="Void"/></f></destruct>
		<deleteEntity public="1" set="method" line="119" override="1"><f a="ent">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></deleteEntity>
		<getEntitiesInBox public="1" set="method" line="109" override="1"><f a="topLeftX:topLeftY:bottomRightX:bottomRightY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesInBox>
		<addEntity public="1" set="method" line="101" override="1"><f a="ent">
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></addEntity>
		<getEntitiesAtPoint public="1" set="method" line="93" override="1"><f a="p">
	<c path="firmament.core.FVector"/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></getEntitiesAtPoint>
		<getAllEntities public="1" set="method" line="89" override="1"><f a=""><c path="Array"><c path="firmament.core.FEntity"/></c></f></getAllEntities>
		<insideStep public="1" set="method" line="85" override="1"><f a=""><e path="Bool"/></f></insideStep>
		<getType public="1" set="method" line="80" override="1"><f a=""><c path="String"/></f></getType>
		<updatePositionState public="1" set="method" line="76"><f a="component:oldTopX:oldTopY">
	<c path="firmament.component.physics.FNoPhysicsComponent"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></updatePositionState>
		<updateSleepState public="1" set="method" line="67"><f a="component">
	<c path="firmament.component.physics.FNoPhysicsComponent"/>
	<e path="Void"/>
</f></updateSleepState>
		<step public="1" set="method" line="42" override="1"><f a=""><e path="Void"/></f></step>
		<_rtree><c path="firmament.util.rtree.RTree"><c path="firmament.core.FEntity"/></c></_rtree>
		<_activeAwakeEntities><c path="Array"><c path="firmament.core.FEntity"/></c></_activeAwakeEntities>
		<_inStep><e path="Bool"/></_inStep>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.core.FPolygonShape" params="" file="../../lib/firmament/core/FPolygonShape.hx">
		<extends path="firmament.core.FShape"/>
		<getVectors public="1" set="method" line="13"><f a=""><c path="Array"><c path="firmament.core.FVector"/></c></f></getVectors>
		<_vectors><c path="Array"><c path="firmament.core.FVector"/></c></_vectors>
		<new public="1" set="method" line="7"><f a="v">
	<c path="Array"><c path="firmament.core.FVector"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="nme.display.Tilesheet" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="59" static="1"><c path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="60" static="1"><c path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="61" static="1"><c path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="62" static="1"><c path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="66" static="1"><c path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="69" static="1"><c path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="70" static="1"><c path="Int"/></TILE_BLEND_ADD>
		<defaultRatio line="77" static="1"><t path="nme.geom.Point"/></defaultRatio>
		<drawTiles public="1" set="method" line="193">
			<f a="graphics:tileData:?smooth:?flags">
				<t path="nme.display.Graphics"/>
				<c path="Array"><c path="Float"/></c>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fast method to draw a batch of tiles using a Tilesheet
	 * 
	 * The input array accepts the x, y and tile ID for each tile you wish to draw.
	 * For example, an array of [ 0, 0, 0, 10, 10, 1 ] would draw tile 0 to (0, 0) and
	 * tile 1 to (10, 10)
	 * 
	 * You can also set flags for TILE_SCALE, TILE_ROTATION, TILE_RGB and
	 * TILE_ALPHA.
	 * 
	 * Depending on which flags are active, this is the full order of the array:
	 * 
	 * [ x, y, tile ID, scale, rotation, red, green, blue, alpha, x, y ... ]
	 * 
	 * @param	graphics		The native.display.Graphics object to use for drawing
	 * @param	tileData		An array of all position, ID and optional values for use in drawing
	 * @param	smooth		(Optional) Whether drawn tiles should be smoothed (Default: false)
	 * @param	flags		(Optional) Flags to enable scale, rotation, RGB and/or alpha when drawing (Default: 0)</haxe_doc>
		</drawTiles>
		<adjustLen set="method" line="162"><f a="vec:len">
	<t path="nme.Vector"><c path="Float"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Float"/></t>
</f></adjustLen>
		<adjustIndices set="method" line="131"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIndices>
		<adjustIDs set="method" line="116"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIDs>
		<addTileRect public="1" set="method" line="107"><f a="rectangle:?centerPoint">
	<t path="nme.geom.Rectangle"/>
	<t path="nme.geom.Point"/>
	<e path="Void"/>
</f></addTileRect>
		<_uvs><t path="nme.Vector"><c path="Float"/></t></_uvs>
		<_indices><t path="nme.Vector"><c path="Int"/></t></_indices>
		<_vertices><t path="nme.Vector"><c path="Float"/></t></_vertices>
		<_ids><t path="nme.Vector"><c path="Int"/></t></_ids>
		<tileUVs><c path="Array"><t path="nme.geom.Rectangle"/></c></tileUVs>
		<tiles><c path="Array"><t path="nme.geom.Rectangle"/></c></tiles>
		<tilePoints><c path="Array"><t path="nme.geom.Point"/></c></tilePoints>
		<bitmapWidth><c path="Int"/></bitmapWidth>
		<bitmapHeight><c path="Int"/></bitmapHeight>
		<nmeBitmap public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* @private</haxe_doc>
		</nmeBitmap>
		<new public="1" set="method" line="89"><f a="inImage">
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.core.FTilesheet" params="" file="../../lib/firmament/core/FTilesheet.hx">
		<extends path="nme.display.Tilesheet"/>
		<getTileNumber public="1" set="method" line="104"><f a="label">
	<c path="String"/>
	<c path="Int"/>
</f></getTileNumber>
		<setRenderPriority public="1" set="method" line="100"><f a="priority">
	<c path="Float"/>
	<e path="Void"/>
</f></setRenderPriority>
		<getRenderPriority public="1" set="method" line="96"><f a=""><c path="Float"/></f></getRenderPriority>
		<getRectangle public="1" set="method" line="92"><f a="i">
	<c path="Int"/>
	<t path="nme.geom.Rectangle"/>
</f></getRectangle>
		<addTileRectWithLabel public="1" set="method" line="83">
			<f a="rectangle:?centerPoint:?label">
				<t path="nme.geom.Rectangle"/>
				<t path="nme.geom.Point"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: addTileRect
	 *
	 * Adds a rectangle definition
	 *
	 * Parameters:
	 *	rectangle - Rectangle definition
	 *	centerPoint - the center point of the image
	 *</haxe_doc>
		</addTileRectWithLabel>
		<addTileRect public="1" set="method" line="67" override="1">
			<f a="rectangle:?centerPoint">
				<t path="nme.geom.Rectangle"/>
				<t path="nme.geom.Point"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: addTileRect
	 *
	 * Adds a rectangle definition
	 *
	 * Parameters:
	 *	rectangle - Rectangle definition
	 *	centerPoint - the center point of the image
	 *</haxe_doc>
		</addTileRect>
		<setDefinitionFileName public="1" set="method" line="52"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></setDefinitionFileName>
		<setImageFileName public="1" set="method" line="48"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></setImageFileName>
		<getImageFileName public="1" set="method" line="44"><f a=""><c path="String"/></f></getImageFileName>
		<getDefinitionFileName public="1" set="method" line="40"><f a=""><c path="String"/></f></getDefinitionFileName>
		<getId public="1" set="method" line="35"><f a=""><c path="Int"/></f></getId>
		<_rects><c path="Array"><t path="nme.geom.Rectangle"/></c></_rects>
		<_labelMap><c path="Hash"><c path="Int"/></c></_labelMap>
		<_renderPriority><c path="Float"/></_renderPriority>
		<imageFileName><c path="String"/></imageFileName>
		<definitionFileName><c path="String"/></definitionFileName>
		<id><c path="Int"/></id>
		<new public="1" set="method" line="24"><f a="inImage">
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* Class: FTilesheet
 * @author jordan</haxe_doc>
	</class>
	<class path="firmament.core.FTilesheetManager" params="" file="../../lib/firmament/core/FTilesheetManager.hx">
		<_instance static="1"><c path="firmament.core.FTilesheetManager"/></_instance>
		<getInstance public="1" set="method" line="31" static="1"><f a=""><c path="firmament.core.FTilesheetManager"/></f></getInstance>
		<createTilesheet public="1" set="method" line="83"><f a="config">
	<d/>
	<c path="firmament.core.FTilesheet"/>
</f></createTilesheet>
		<getOrderedTilesheets public="1" set="method" line="64"><f a=""><c path="Array"><c path="firmament.core.FTilesheet"/></c></f></getOrderedTilesheets>
		<addTileSheet public="1" set="method" line="60"><f a="tilesheet">
	<c path="firmament.core.FTilesheet"/>
	<e path="Void"/>
</f></addTileSheet>
		<getTilesheetFromDifinitionFile public="1" set="method" line="47"><f a="fileName">
	<c path="String"/>
	<c path="firmament.core.FTilesheet"/>
</f></getTilesheetFromDifinitionFile>
		<getTilesheetWithId public="1" set="method" line="43"><f a="id">
	<c path="Int"/>
	<t path="Null"><c path="firmament.core.FTilesheet"/></t>
</f></getTilesheetWithId>
		<genTilesheetId public="1" set="method" line="38"><f a=""><c path="Int"/></f></genTilesheetId>
		<_orderedTilesheets><c path="Array"><c path="firmament.core.FTilesheet"/></c></_orderedTilesheets>
		<tilesheets><c path="IntHash"><c path="firmament.core.FTilesheet"/></c></tilesheets>
		<idCounter><c path="Int"/></idCounter>
		<new set="method" line="24"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author jordan wambaugh</haxe_doc>
	</class>
	<class path="firmament.core.FTilesheetRenderHelper" params="" file="../../lib/firmament/core/FTilesheetRenderHelper.hx">
		<_instance static="1"><c path="firmament.core.FTilesheetRenderHelper"/></_instance>
		<getInstance public="1" set="method" line="21" static="1"><f a=""><c path="firmament.core.FTilesheetRenderHelper"/></f></getInstance>
		<isCameraInitialized set="method" line="69"><f a="camera">
	<c path="firmament.core.FCamera"/>
	<e path="Bool"/>
</f></isCameraInitialized>
		<postRender public="1" set="method" line="54"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></postRender>
		<preRender public="1" set="method" line="50"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></preRender>
		<initCamera public="1" set="method" line="41"><f a="camera">
	<c path="firmament.core.FCamera"/>
	<e path="Void"/>
</f></initCamera>
		<addToDrawList public="1" set="method" line="29"><f a="tilesheet:list">
	<c path="firmament.core.FTilesheet"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Void"/>
</f></addToDrawList>
		<initializedCameras><c path="Array"><c path="firmament.core.FCamera"/></c></initializedCameras>
		<drawList><c path="IntHash"><c path="Array"><c path="Float"/></c></c></drawList>
		<new set="method" line="16"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.core.FVector" params="" file="../../lib/firmament/core/FVector.hx">
		<extends path="box2D.common.math.B2Vec2"/>
		<copy public="1" set="method" line="38" override="1"><f a=""><c path="firmament.core.FVector"/></f></copy>
		<distanceTo public="1" set="method" line="32">
			<f a="v">
				<c path="firmament.core.FVector"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Returns the distance between this and another vector.
	 * Always returns a positive value.
	 * @param	v
	 * @return</haxe_doc>
		</distanceTo>
		<toString public="1" set="method" line="22"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="16">
			<f a="?x:?y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor: new
	 *</haxe_doc>
		</new>
		<haxe_doc>* Class: FVector
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.world.FWorldFactory" params="" file="../../lib/firmament/core/FWorldFactory.hx">
		<createWorld public="1" set="method" line="7" static="1"><f a="type">
	<c path="String"/>
	<c path="firmament.world.FWorld"/>
</f></createWorld>
		<getClassFromType public="1" set="method" line="16" static="1"><f a="type">
	<c path="String"/>
	<c path="String"/>
</f></getClassFromType>
	</class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.event.FPhysicsCollisionEvent" params="" file="../../lib/firmament/event/FPhysicsCollisionEvent.hx">
		<extends path="flash.events.Event"/>
		<getLocalPointOfContact public="1" set="method" line="76"><f a="entity">
	<c path="firmament.core.FEntity"/>
	<c path="firmament.core.FVector"/>
</f></getLocalPointOfContact>
		<allowCollision public="1" set="method" line="72"><f a="c">
	<e path="Bool"/>
	<e path="Void"/>
</f></allowCollision>
		<getCollisionType public="1" set="method" line="68"><f a=""><e path="firmament.event.FCollisionEventType"/></f></getCollisionType>
		<getOtherEntity public="1" set="method" line="62"><f a="ent">
	<c path="firmament.core.FEntity"/>
	<c path="firmament.core.FEntity"/>
</f></getOtherEntity>
		<getEntityB public="1" set="method" line="57"><f a=""><c path="firmament.core.FEntity"/></f></getEntityB>
		<getEntityA public="1" set="method" line="52"><f a=""><c path="firmament.core.FEntity"/></f></getEntityA>
		<getCollisionSpeed public="1" set="method" line="47"><f a=""><c path="Float"/></f></getCollisionSpeed>
		<_collisionType><e path="firmament.event.FCollisionEventType"/></_collisionType>
		<_world><c path="firmament.world.FWorld"/></_world>
		<new public="1" set="method" line="33"><f a="world:type">
	<c path="firmament.world.FWorld"/>
	<e path="firmament.event.FCollisionEventType"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.event.FBox2DCollisionEvent" params="" file="../../lib/firmament/event/FBox2DCollisionEvent.hx">
		<extends path="firmament.event.FPhysicsCollisionEvent"/>
		<allowCollision public="1" set="method" line="51" override="1"><f a="c">
	<e path="Bool"/>
	<e path="Void"/>
</f></allowCollision>
		<getEntityB public="1" set="method" line="47" override="1"><f a=""><c path="firmament.core.FEntity"/></f></getEntityB>
		<getEntityA public="1" set="method" line="43" override="1"><f a=""><c path="firmament.core.FEntity"/></f></getEntityA>
		<getCollisionSpeed public="1" set="method" line="28" override="1"><f a=""><c path="Float"/></f></getCollisionSpeed>
		<_contact><c path="box2D.dynamics.contacts.B2Contact"/></_contact>
		<new public="1" set="method" line="22"><f a="world:type:contact">
	<c path="firmament.world.FWorld"/>
	<e path="firmament.event.FCollisionEventType"/>
	<c path="box2D.dynamics.contacts.B2Contact"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.event.FEventRelayEvent" params="" file="../../lib/firmament/event/FEventRelayEvent.hx">
		<extends path="flash.events.Event"/>
		<getConfig public="1" set="method" line="21"><f a=""><d/></f></getConfig>
		<getOriginEntity public="1" set="method" line="17"><f a=""><c path="firmament.core.FEntity"/></f></getOriginEntity>
		<_entity><c path="firmament.core.FEntity"/></_entity>
		<_config><d/></_config>
		<new public="1" set="method" line="10"><f a="type:originEntity:config">
	<c path="String"/>
	<c path="firmament.core.FEntity"/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="firmament.event.FCollisionEventType" params="" file="../../lib/firmament/event/FPhysicsCollisionEvent.hx" module="firmament.event.FPhysicsCollisionEvent">
		<preSolve/>
		<postSolve/>
		<endContact/>
		<beginContact/>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</enum>
	<class path="firmament.filter.entity.FEntityFilterInterface" params="" file="../../lib/firmament/filter/entity/FEntityFilterInterface.hx" interface="1">
		<filterEntityArray public="1" set="method"><f a="arr:?options">
	<c path="Array"><c path="firmament.core.FEntity"/></c>
	<d/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></filterEntityArray>
		<filterEntity public="1" set="method"><f a="entity:?options">
	<c path="firmament.core.FEntity"/>
	<d/>
	<e path="Bool"/>
</f></filterEntity>
	</class>
	<class path="firmament.filter.entity.FEntityFilter" params="" file="../../lib/firmament/filter/entity/FEntityFilter.hx">
		<implements path="firmament.filter.entity.FEntityFilterInterface"/>
		<filterEntityArray public="1" set="method" line="21"><f a="arr:?options">
	<c path="Array"><c path="firmament.core.FEntity"/></c>
	<d/>
	<c path="Array"><c path="firmament.core.FEntity"/></c>
</f></filterEntityArray>
		<filterEntity public="1" set="method" line="14"><f a="entity:?options">
	<c path="firmament.core.FEntity"/>
	<d/>
	<e path="Bool"/>
</f></filterEntity>
		<new public="1" set="method" line="9"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.filter.entity.FEntityFilterFactory" params="" file="../../lib/firmament/filter/entity/FEntityFilterFactory.hx">
		<createfilter public="1" set="method" line="8" static="1"><f a="type">
	<c path="String"/>
	<c path="firmament.filter.entity.FEntityFilter"/>
</f></createfilter>
		<getClassFromType public="1" set="method" line="21" static="1"><f a="type">
	<c path="String"/>
	<c path="String"/>
</f></getClassFromType>
	</class>
	<class path="firmament.filter.entity.FEntityRadiusFilter" params="" file="../../lib/firmament/filter/entity/FEntityRadiusFilter.hx">
		<extends path="firmament.filter.entity.FEntityFilter"/>
		<filterEntity public="1" set="method" line="15" override="1"><f a="entity:?options">
	<c path="firmament.core.FEntity"/>
	<d/>
	<e path="Bool"/>
</f></filterEntity>
		<_type><c path="String"/></_type>
		<new public="1" set="method" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.filter.entity.FEntityTypeFilter" params="" file="../../lib/firmament/filter/entity/FEntityTypeFilter.hx">
		<extends path="firmament.filter.entity.FEntityFilter"/>
		<filterEntity public="1" set="method" line="13" override="1"><f a="entity:?options">
	<c path="firmament.core.FEntity"/>
	<d/>
	<e path="Bool"/>
</f></filterEntity>
		<_type><c path="String"/></_type>
		<new public="1" set="method" line="8"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="firmament.process.base.FProcessInterface" params="" file="../../lib/firmament/process/base/FProcessInterface.hx" interface="1">
		<beforeAbort public="1" set="method">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Celled if the process is aborted before it is completed.
	 * Should return true if can successfully be aborted. If return false, the abortion will fail.</haxe_doc>
		</beforeAbort>
		<afterFinish public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* called after the process has successfully finished, right before it is removed from the queue.</haxe_doc>
		</afterFinish>
		<isRunning public="1" set="method">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Should return true if the process is currently running.</haxe_doc>
		</isRunning>
		<isComplete public="1" set="method">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Should return true if the process is done and may be removed from the queue.
	 * @return</haxe_doc>
		</isComplete>
		<step public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called after each step. This method should do a bit of work and then finish. Each step should not be too long.</haxe_doc>
		</step>
		<beforeStart public="1" set="method">
			<f a="processManager">
				<c path="firmament.process.base.FProcessManager"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when the process is added to the manager queue, before the process is started.</haxe_doc>
		</beforeStart>
		<haxe_doc>* Interface for a process. A process performs a job over a length of time.
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.process.base.FProcess" params="" file="../../lib/firmament/process/base/FProcess.hx">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="firmament.process.base.FProcessInterface"/>
		<COMPLETE public="1" get="inline" set="null" line="12" static="1"><c path="String"/></COMPLETE>
		<afterFinish public="1" set="method" line="70">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* called after the process has successfully finished, right before it is removed from the queue.</haxe_doc>
		</afterFinish>
		<isRunning public="1" set="method" line="62">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Should return true if the process is currently running.</haxe_doc>
		</isRunning>
		<isComplete public="1" set="method" line="55">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Should return true if the process is done and may be removed from the queue.
	 * @return</haxe_doc>
		</isComplete>
		<beforeAbort public="1" set="method" line="47">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Celled if the process is aborted before it is completed.</haxe_doc>
		</beforeAbort>
		<step public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called after each step. This method should do a bit of work and then finish. Each step should not be too long.</haxe_doc>
		</step>
		<beforeStart public="1" set="method" line="29">
			<f a="processManager">
				<c path="firmament.process.base.FProcessManager"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when the process is added to the manager queue, before the process is started.</haxe_doc>
		</beforeStart>
		<_manager><c path="firmament.process.base.FProcessManager"/></_manager>
		<_isRunning><e path="Bool"/></_isRunning>
		<_isComplete><e path="Bool"/></_isComplete>
		<new public="1" set="method" line="18"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Basic process implementation that does nothing. Extend for easy process implementation.
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.process.base.FProcessManager" params="" file="../../lib/firmament/process/base/FProcessManager.hx">
		<extends path="flash.events.EventDispatcher"/>
		<PAUSED public="1" get="inline" set="null" line="19" static="1"><c path="String"/></PAUSED>
		<UNPAUSED public="1" get="inline" set="null" line="20" static="1"><c path="String"/></UNPAUSED>
		<destruct public="1" set="method" line="106"><f a=""><e path="Void"/></f></destruct>
		<unPause public="1" set="method" line="99"><f a=""><e path="Void"/></f></unPause>
		<pause public="1" set="method" line="92"><f a=""><e path="Void"/></f></pause>
		<abortProcess public="1" set="method" line="81">
			<f a="p">
				<c path="firmament.process.base.FProcessInterface"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* attempts to abort a process
	 * @param	p</haxe_doc>
		</abortProcess>
		<cleanupProcesses set="method" line="68"><f a=""><e path="Void"/></f></cleanupProcesses>
		<step public="1" set="method" line="47">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Runs a step for each registered process.</haxe_doc>
		</step>
		<addProcess public="1" set="method" line="39"><f a="p">
	<c path="firmament.process.base.FProcessInterface"/>
	<e path="Void"/>
</f></addProcess>
		<getIteration public="1" set="method" line="35"><f a=""><c path="Int"/></f></getIteration>
		<getFrameDelta public="1" set="method" line="31"><f a=""><c path="Float"/></f></getFrameDelta>
		<_paused><e path="Bool"/></_paused>
		<_lastTime><c path="Float"/></_lastTime>
		<_frameDelta><c path="Float"/></_frameDelta>
		<_iteration><c path="Int"/></_iteration>
		<_processQueue><c path="Array"><c path="firmament.process.base.FProcessInterface"/></c></_processQueue>
		<new public="1" set="method" line="21"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.process.engine.FCameraRenderProcess" params="" file="../../lib/firmament/process/engine/FCameraRenderProcess.hx">
		<extends path="firmament.process.base.FProcess"/>
		<step public="1" set="method" line="14" override="1"><f a=""><e path="Void"/></f></step>
		<camera><c path="firmament.core.FCamera"/></camera>
		<new public="1" set="method" line="9"><f a="camera">
	<c path="firmament.core.FCamera"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.process.engine.FWorldStepProcess" params="" file="../../lib/firmament/process/engine/FWorldStepProcess.hx">
		<extends path="firmament.process.base.FProcess"/>
		<step public="1" set="method" line="14" override="1"><f a=""><e path="Void"/></f></step>
		<world><c path="firmament.world.FWorld"/></world>
		<new public="1" set="method" line="9"><f a="world">
	<c path="firmament.world.FWorld"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.process.helper.FCallbackProcess" params="" file="../../lib/firmament/process/helper/FCallbackProcess.hx">
		<extends path="firmament.process.base.FProcess"/>
		<afterFinish public="1" set="method" line="38" override="1"><f a=""><e path="Void"/></f></afterFinish>
		<step public="1" set="method" line="29" override="1"><f a=""><e path="Void"/></f></step>
		<beforeStart public="1" set="method" line="23" override="1"><f a="pm">
	<c path="firmament.process.base.FProcessManager"/>
	<e path="Void"/>
</f></beforeStart>
		<config><d/></config>
		<new public="1" set="method" line="18"><f a="config">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.sound.FSoundManager" params="" file="../../lib/firmament/sound/FSoundManager.hx">
		<soundHash static="1"><c path="Hash"><t path="nme.media.Sound"/></c></soundHash>
		<init set="method" line="9" static="1"><f a=""><e path="Void"/></f></init>
		<getSound public="1" set="method" line="15" static="1"><f a="name">
	<c path="String"/>
	<t path="Null"><t path="nme.media.Sound"/></t>
</f></getSound>
		<loadSounds public="1" set="method" line="28" static="1">
			<f a="soundNames">
				<c path="Array"><c path="String"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Pre-loads the list of sound files.</haxe_doc>
		</loadSounds>
	</class>
	<class path="firmament.sound.FSoundtrackManager" params="" file="../../lib/firmament/sound/FSoundtrackManager.hx">
		<_soundChannel static="1"><t path="nme.media.SoundChannel"/></_soundChannel>
		<_volume line="10" static="1"><c path="Float"/></_volume>
		<play public="1" set="method" line="12" static="1"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></play>
		<setVolume public="1" set="method" line="30" static="1"><f a="volume">
	<c path="Float"/>
	<e path="Void"/>
</f></setVolume>
		<stop public="1" set="method" line="21"><f a=""><e path="Void"/></f></stop>
	</class>
	<class path="firmament.ui.FAutoVirtualJoystick" params="" file="../../lib/firmament/ui/FAutoVirtualJoystick.hx">
		<extends path="flash.display.Sprite"/>
		<getValue public="1" set="method" line="37"><f a=""><c path="firmament.core.FVector"/></f></getValue>
		<mouseUp set="method" line="32"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseUp>
		<mouseDown set="method" line="25"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseDown>
		<_stick><c path="firmament.ui.FVirtualJoystick"/></_stick>
		<_mouseDown><e path="Bool"/></_mouseDown>
		<new public="1" set="method" line="14"><f a="width:height:?classes">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.ui.FWidget" params="" file="../../lib/firmament/ui/FWidget.hx">
		<extends path="flash.display.Sprite"/>
		<new public="1" set="method" line="12"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.ui.FButton" params="" file="../../lib/firmament/ui/FButton.hx">
		<extends path="firmament.ui.FWidget"/>
		<setText public="1" set="method" line="78"><f a="t">
	<c path="String"/>
	<e path="Void"/>
</f></setText>
		<onUp set="method" line="73"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onUp>
		<onDown set="method" line="68"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onDown>
		<onOut set="method" line="63"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onOut>
		<onOver set="method" line="58"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onOver>
		<draw public="1" set="method" line="49"><f a="?e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></draw>
		<clickColor><c path="Int"/></clickColor>
		<hoverColor><c path="Int"/></hoverColor>
		<regularColor><c path="Int"/></regularColor>
		<currentColor><c path="Int"/></currentColor>
		<text><c path="firmament.ui.FTextLabel"/></text>
		<new public="1" set="method" line="26">
			<f a="?text:?x:?y:?onClick">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<f a="">
					<t path="nme.events.MouseEvent"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>* Constructor: new
	 * creates a new button. Can optionally take x and y coordinates, and a function to fire when clicked.
	 * the onclick parameter must be a function that accepts a MouseEvent object and return Void.</haxe_doc>
		</new>
		<haxe_doc>* Class: FButton
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.ui.FDialog" params="" file="../../lib/firmament/ui/FDialog.hx">
		<alert public="1" set="method" line="13" static="1"><f a="body:?title">
	<c path="String"/>
	<c path="String"/>
	<c path="firmament.ui.FWindow"/>
</f></alert>
		<prompt public="1" set="method" line="37" static="1"><f a="body:onEnter:?title:?text">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<e path="Void"/>
	</f>
	<c path="String"/>
	<c path="String"/>
	<c path="firmament.ui.FWindow"/>
</f></prompt>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.ui.FTextField" params="" file="../../lib/firmament/ui/FTextField.hx">
		<extends path="firmament.ui.FWidget"/>
		<setMultiline set="method" line="44"><f a="m">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setMultiline>
		<getMultiline set="method" line="43"><f a=""><e path="Bool"/></f></getMultiline>
		<getTextWidth set="method" line="42"><f a=""><c path="Float"/></f></getTextWidth>
		<getTextHeight set="method" line="41"><f a=""><c path="Float"/></f></getTextHeight>
		<setText set="method" line="40"><f a="t">
	<c path="String"/>
	<c path="String"/>
</f></setText>
		<getText set="method" line="39"><f a=""><c path="String"/></f></getText>
		<multiline public="1" get="getMultiline" set="setMultiline"><e path="Bool"/></multiline>
		<textWidth public="1" get="getTextWidth" set="null"><c path="Float"/></textWidth>
		<textHeight public="1" get="getTextHeight" set="null"><c path="Float"/></textHeight>
		<text public="1" get="getText" set="setText"><c path="String"/></text>
		<textField public="1"><t path="nme.text.TextField"/></textField>
		<new public="1" set="method" line="21"><f a="?text:?x:?y:?width:?classes">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.ui.FLineEdit" params="" file="../../lib/firmament/ui/FLineEdit.hx">
		<extends path="firmament.ui.FTextField"/>
		<new public="1" set="method" line="11"><f a="?text:?x:?y:?width">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.ui.FSmallButton" params="" file="../../lib/firmament/ui/FSmallButton.hx">
		<extends path="firmament.ui.FButton"/>
		<draw public="1" set="method" line="22" override="1"><f a="?e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></draw>
		<new public="1" set="method" line="12"><f a="?text:?x:?y:?onClick">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<f a="">
		<t path="nme.events.MouseEvent"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.ui.FStyle" params="" file="../../lib/firmament/ui/FStyle.hx">
		<global static="1"><d/></global>
		<classes static="1"><d/></classes>
		<init set="method" line="22" static="1"><f a=""><e path="Void"/></f></init>
		<getClass set="method" line="33" static="1"><f a="className">
	<c path="String"/>
	<unknown/>
</f></getClass>
		<getStyleObj public="1" set="method" line="43" static="1"><f a="?classes">
	<c path="Array"><c path="String"/></c>
	<d/>
</f></getStyleObj>
		<setStyleObj public="1" set="method" line="54" static="1"><f a="cls:obj">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyleObj>
		<getStyleKey public="1" set="method" line="64" static="1"><f a="key:?classes">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></getStyleKey>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.ui.FStyleHelper" params="" file="../../lib/firmament/ui/FStyleHelper.hx">
		<get public="1" set="method" line="8" static="1"><f a="o:key:?def">
	<d/>
	<c path="String"/>
	<d/>
	<d/>
</f></get>
		<haxe_doc>* use as a mixin for extra tools with config values</haxe_doc>
	</class>
	<class path="firmament.ui.FTextLabel" params="" file="../../lib/firmament/ui/FTextLabel.hx">
		<extends path="firmament.ui.FTextField"/>
		<new public="1" set="method" line="11"><f a="?text:?x:?y">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.ui.FVirtualJoystick" params="" file="../../lib/firmament/ui/FVirtualJoystick.hx">
		<extends path="flash.display.Sprite"/>
		<getValue public="1" set="method" line="73"><f a=""><c path="firmament.core.FVector"/></f></getValue>
		<mouseMove set="method" line="58"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseMove>
		<mouseUp set="method" line="52"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseUp>
		<mouseDown public="1" set="method" line="48"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></mouseDown>
		<_radius><c path="Float"/></_radius>
		<_mouseDown><e path="Bool"/></_mouseDown>
		<_stick><t path="nme.display.Sprite"/></_stick>
		<new public="1" set="method" line="19"><f a="?classes">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.ui.FWindow" params="" file="../../lib/firmament/ui/FWindow.hx">
		<extends path="firmament.ui.FWidget"/>
		<close public="1" set="method" line="163"><f a="?e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></close>
		<onMouseUp set="method" line="157"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<onMouseDown set="method" line="153"><f a="e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseDown>
		<draw set="method" line="147"><f a="?e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></draw>
		<drawWindow set="method" line="135"><f a=""><e path="Void"/></f></drawWindow>
		<drawTitleBar set="method" line="123"><f a=""><e path="Void"/></f></drawTitleBar>
		<expand public="1" set="method" line="113"><f a="?e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></expand>
		<collapse public="1" set="method" line="105"><f a="?e">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></collapse>
		<setCanvas public="1" set="method" line="92"><f a="c">
	<t path="nme.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></setCanvas>
		<setTitle public="1" set="method" line="86"><f a="t">
	<c path="String"/>
	<e path="Void"/>
</f></setTitle>
		<expanded><e path="Bool"/></expanded>
		<expandButton><c path="firmament.ui.FSmallButton"/></expandButton>
		<closeButton><c path="firmament.ui.FSmallButton"/></closeButton>
		<minimizeButton><c path="firmament.ui.FSmallButton"/></minimizeButton>
		<titleColor><c path="Int"/></titleColor>
		<backgroundColor><c path="Int"/></backgroundColor>
		<mouseOffsetY><c path="Float"/></mouseOffsetY>
		<mouseOffsetX><c path="Float"/></mouseOffsetX>
		<titleBar><t path="nme.display.Sprite"/></titleBar>
		<titleLabel><c path="firmament.ui.FTextLabel"/></titleLabel>
		<canvasOffsetX><c path="Int"/></canvasOffsetX>
		<canvasOffsetY><c path="Int"/></canvasOffsetY>
		<title><c path="String"/></title>
		<canvas><t path="nme.display.DisplayObjectContainer"/></canvas>
		<new public="1" set="method" line="33"><f a="?hasCloseButton:?hasCollapseButton">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.util.FAutoCrop" params="" file="../../lib/firmament/util/FAutoCrop.hx">
		<isContent public="1" set="method" line="15" static="1"><f a="color">
	<c path="Int"/>
	<e path="Bool"/>
</f></isContent>
		<crop public="1" set="method" line="22" static="1"><f a="bitmap">
	<t path="nme.display.BitmapData"/>
	<t path="nme.display.BitmapData"/>
</f></crop>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.util.FConfigHelper" params="" file="../../lib/firmament/util/FConfigHelper.hx">
		<getNotNull public="1" set="method" line="57"><f a="field:?type:?def">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
</f></getNotNull>
		<vectorFromDynamic set="method" line="47"><f a="d">
	<d/>
	<c path="firmament.core.FVector"/>
</f></vectorFromDynamic>
		<getVector public="1" set="method" line="41"><f a="field:def">
	<c path="String"/>
	<d/>
	<c path="firmament.core.FVector"/>
</f></getVector>
		<get public="1" set="method" line="13"><f a="field:?type:?def">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
</f></get>
		<_config><d/></_config>
		<new public="1" set="method" line="8"><f a="config">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.util.FEntityUtils" params="" file="../../lib/firmament/util/FEntityUtils.hx">
		<emitEntity public="1" set="method" line="21" static="1">
			<f a="sourceEntity:entity:?speed:?angleOffset:?distanceOffset">
				<c path="firmament.core.FEntity"/>
				<c path="firmament.core.FEntity"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: emitEntity
	 * Shoots an entity entity from the sourceEntity in the direction the entity is currently pointing
	 * 
	 * Params: 
	 * 		sourceEntity 	{FEntity} The entity to shoot the bullet from
	 * 		entity 			{FEntity} The entity to emit
	 *		speed 			Float the speed at which the entity should travel
	 *		angleOffset 	Float the angle that should be added to sourceEntity's angle
	 *		positionOffset  Float the distance from sourceEntity that the entity should start from.</haxe_doc>
		</emitEntity>
		<emitEntityFromPoint public="1" set="method" line="45" static="1">
			<f a="entity:position:angle:?speed:?distanceOffset">
				<c path="firmament.core.FEntity"/>
				<c path="firmament.core.FVector"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: emitEntity
	 * Shoots an entity entity from the sourceEntity in the direction the entity is currently pointing
	 * 
	 * Params: 
	 * 		sourceEntity 	{FEntity} The entity to shoot the bullet from
	 * 		entity 			{FEntity} The entity to emit
	 *		speed 			Float the speed at which the entity should travel
	 *		angleOffset 	Float the angle that should be added to sourceEntity's angle
	 *		positionOffset  Float the distance from sourceEntity that the entity should start from.</haxe_doc>
		</emitEntityFromPoint>
	</class>
	<class path="firmament.util.FMisc" params="" file="../../lib/firmament/util/FMisc.hx">
		<cloneInto public="1" set="method" line="18" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: cloneInto
	 * clones the properties of a into b. Does a shallow clone.</haxe_doc>
		</cloneInto>
		<mergeInto public="1" set="method" line="36" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: mergeInto
	 * merges one object (a) into another (b). does not remove fields from b that aren't in a.
	 * does a deep merge.</haxe_doc>
		</mergeInto>
		<deepClone public="1" params="T" set="method" line="61" static="1">
			<f a="v">
				<c path="deepClone.T"/>
				<c path="deepClone.T"/>
			</f>
			<haxe_doc>*deep copy of anything</haxe_doc>
		</deepClone>
		<doLater public="1" set="method" line="94" static="1"><f a="cb">
	<f a=""><d/></f>
	<e path="Void"/>
</f></doLater>
		<haxe_doc>* Class: FMisc
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.util.FRepository" params="" file="../../lib/firmament/util/FRepository.hx">
		<_instance static="1"><c path="firmament.util.FRepository"/></_instance>
		<getInstance public="1" set="method" line="15" static="1"><f a=""><c path="firmament.util.FRepository"/></f></getInstance>
		<get public="1" set="method" line="29"><f a="key">
	<c path="String"/>
	<d/>
</f></get>
		<set public="1" set="method" line="23"><f a="key:val">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></set>
		<_hash><c path="Hash"><d/></c></_hash>
		<new set="method" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="firmament.util.loader.FDataLoader" params="" file="../../lib/firmament/util/loader/FDataLoader.hx">
		<_cache line="17" static="1"><c path="Hash"><d/></c></_cache>
		<_recursionCount static="1"><c path="Int"/></_recursionCount>
		<loadData public="1" set="method" line="19" static="1"><f a="fileName:?allowEmpty">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
</f></loadData>
	</class>
	<class path="firmament.util.loader.FEntityLoadEvent" params="" file="../../lib/firmament/util/loader/FEntityLoader.hx" module="firmament.util.loader.FEntityLoader">
		<extends path="flash.events.Event"/>
		<entity public="1"><c path="firmament.core.FEntity"/></entity>
		<new public="1" set="method" line="24"><f a="name:entity">
	<c path="String"/>
	<c path="firmament.core.FEntity"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.util.loader.FEntityLoader" params="" file="../../lib/firmament/util/loader/FEntityLoader.hx">
		<extends path="flash.events.EventDispatcher"/>
		<_instance static="1"><c path="firmament.util.loader.FEntityLoader"/></_instance>
		<ENTITY_LOADED public="1" get="inline" set="null" line="37" static="1"><c path="String"/></ENTITY_LOADED>
		<getInstance public="1" set="method" line="42" static="1"><f a=""><c path="firmament.util.loader.FEntityLoader"/></f></getInstance>
		<loadPool public="1" set="method" line="103"><f a="fileName:?preAllocate">
	<c path="String"/>
	<c path="Int"/>
	<c path="firmament.core.FEntityPool"/>
</f></loadPool>
		<loadMap public="1" set="method" line="79">
			<f a="fileName:?overrideClass">
				<c path="String"/>
				<unknown/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Function: loadMap
	 * Loads a map into the provided world. if overrideClass is provided, all entities will be of that class no matter what.
	 * 
	 *</haxe_doc>
		</loadMap>
		<loadEntity public="1" set="method" line="52">
			<f a="fileName:config:?overrideClass">
				<c path="String"/>
				<d/>
				<unknown/>
				<c path="firmament.core.FEntity"/>
			</f>
			<haxe_doc>* Function: loadEntity</haxe_doc>
		</loadEntity>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Class: FEntityLoader</haxe_doc>
	</class>
	<class path="firmament.util.loader.FSceneLoader" params="" file="../../lib/firmament/util/loader/FSceneLoader.hx"><loadScene public="1" set="method" line="12" static="1"><f a="scene">
	<d/>
	<e path="Void"/>
</f></loadScene></class>
	<class path="firmament.util.loader.serializer.FSerializerInterface" params="" file="../../lib/firmament/util/loader/serializer/FSerializerInterface.hx" interface="1">
		<canProccessFileName public="1" set="method"><f a="fileName">
	<c path="String"/>
	<e path="Bool"/>
</f></canProccessFileName>
		<serialize public="1" set="method"><f a="object">
	<d/>
	<c path="String"/>
</f></serialize>
		<unserialize public="1" set="method"><f a="data">
	<c path="String"/>
	<d/>
</f></unserialize>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.util.loader.serializer.FJsonSerializer" params="" file="../../lib/firmament/util/loader/serializer/FJsonSerializer.hx">
		<implements path="firmament.util.loader.serializer.FSerializerInterface"/>
		<canProccessFileName public="1" set="method" line="27"><f a="fileName">
	<c path="String"/>
	<e path="Bool"/>
</f></canProccessFileName>
		<serialize public="1" set="method" line="23"><f a="object">
	<d/>
	<c path="String"/>
</f></serialize>
		<unserialize public="1" set="method" line="17"><f a="data">
	<c path="String"/>
	<d/>
</f></unserialize>
		<new public="1" set="method" line="14"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.util.loader.serializer.FSerializerFactory" params="" file="../../lib/firmament/util/loader/serializer/FSerializerFactory.hx">
		<serializers static="1"><c path="Array"><c path="firmament.util.loader.serializer.FSerializerInterface"/></c></serializers>
		<getSerializerForFile public="1" set="method" line="15" static="1"><f a="fileName">
	<c path="String"/>
	<c path="firmament.util.loader.serializer.FSerializerInterface"/>
</f></getSerializerForFile>
		<haxe_doc>* ...
 * @author Jordan Wambaugh</haxe_doc>
	</class>
	<class path="firmament.util.rtree.RTLeaf" params="T" file="../../lib/firmament/util/rtree/RTLeaf.hx">
		<getObj public="1" set="method" line="23"><f a=""><c path="firmament.util.rtree.RTLeaf.T"/></f></getObj>
		<botY public="1"><c path="Float"/></botY>
		<botX public="1"><c path="Float"/></botX>
		<topY public="1"><c path="Float"/></topY>
		<topX public="1"><c path="Float"/></topX>
		<parentNode public="1"><c path="firmament.util.rtree.RTNode"><c path="firmament.util.rtree.RTLeaf.T"/></c></parentNode>
		<obj><c path="firmament.util.rtree.RTLeaf.T"/></obj>
		<new public="1" set="method" line="12"><f a="obj:parentNode:topX:topY:botX:botY">
	<c path="firmament.util.rtree.RTLeaf.T"/>
	<c path="firmament.util.rtree.RTNode"><c path="firmament.util.rtree.RTLeaf.T"/></c>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.util.rtree.RTNode" params="T" file="../../lib/firmament/util/rtree/RTNode.hx">
		<addCustomNode public="1" set="method" line="303"><f a="topX:topY:botX:botY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addCustomNode>
		<updateLeaf public="1" set="method" line="279"><f a="leaf:?topX:?topY:?botX:?botY">
	<c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTNode.T"/></c>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></updateLeaf>
		<deleteLeaf public="1" set="method" line="274"><f a="leaf">
	<c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTNode.T"/></c>
	<e path="Void"/>
</f></deleteLeaf>
		<deleteObject public="1" set="method" line="269"><f a="obj:objTopX:objTopY">
	<c path="firmament.util.rtree.RTNode.T"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></deleteObject>
		<updateObject public="1" set="method" line="263"><f a="obj:objTopX:objTopY:?newTopX:?newTopY:?newBotX:?newBotY">
	<c path="firmament.util.rtree.RTNode.T"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></updateObject>
		<getObjLeaf set="method" line="250"><f a="obj:objTopX:objTopY">
	<c path="firmament.util.rtree.RTNode.T"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTNode.T"/></c>
</f></getObjLeaf>
		<getLeafsFromRange public="1" set="method" line="223"><f a="topX:topY:botX:botY:?overlapX:?overlapY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTNode.T"/></c></c>
</f></getLeafsFromRange>
		<getLeafsFromPosition public="1" set="method" line="195"><f a="topX:topY:?overlapX:?overlapY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTNode.T"/></c></c>
</f></getLeafsFromPosition>
		<getObjectsFromRange public="1" set="method" line="168"><f a="topX:topY:botX:botY:?overlapX:?overlapY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.util.rtree.RTNode.T"/></c>
</f></getObjectsFromRange>
		<getObjectsFromPosition public="1" set="method" line="140"><f a="topX:topY:?overlapX:?overlapY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.util.rtree.RTNode.T"/></c>
</f></getObjectsFromPosition>
		<expandAroundThisNode get="inline" set="null" line="114"><f a=""><e path="Void"/></f></expandAroundThisNode>
		<insertObj public="1" set="method" line="35"><f a="obj:topX:topY:botX:botY">
	<c path="firmament.util.rtree.RTNode.T"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></insertObj>
		<botYBoundary public="1"><c path="Float"/></botYBoundary>
		<botXBoundary public="1"><c path="Float"/></botXBoundary>
		<topYBoundary public="1"><c path="Float"/></topYBoundary>
		<topXBoundary public="1"><c path="Float"/></topXBoundary>
		<leafs public="1"><c path="Array"><c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTNode.T"/></c></c></leafs>
		<nodes public="1"><c path="Array"><c path="firmament.util.rtree.RTNode"><c path="firmament.util.rtree.RTNode.T"/></c></c></nodes>
		<mainNode><c path="firmament.util.rtree.RTNode"><c path="firmament.util.rtree.RTNode.T"/></c></mainNode>
		<toleranceEpsilon><c path="Float"/></toleranceEpsilon>
		<maxChildsPerNode><c path="Int"/></maxChildsPerNode>
		<new public="1" set="method" line="20"><f a="topXBoundary:topYBoundary:botXBoundary:botYBoundary:maxChildsPerNode:toleranceEpsilon:?mainNode">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="firmament.util.rtree.RTNode"><c path="firmament.util.rtree.RTNode.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="firmament.util.rtree.RTree" params="T" file="../../lib/firmament/util/rtree/RTree.hx">
		<deleteObject public="1" set="method" line="70"><f a="obj:objTopX:objTopY">
	<c path="firmament.util.rtree.RTree.T"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></deleteObject>
		<updateLeaf public="1" set="method" line="64"><f a="leaf:?topX:?topY:?botX:?botY">
	<c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTree.T"/></c>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></updateLeaf>
		<updateObject public="1" set="method" line="58"><f a="obj:objTopX:objTopY:?newTopX:?newTopY:?newBotX:?newBotY">
	<c path="firmament.util.rtree.RTree.T"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></updateObject>
		<getLeafsFromRange public="1" set="method" line="52"><f a="topX:topY:botX:botY:?overlapX:?overlapY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTree.T"/></c></c>
</f></getLeafsFromRange>
		<getLeafsFromPosition public="1" set="method" line="46"><f a="topX:topY:?overlapX:?overlapY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.util.rtree.RTLeaf"><c path="firmament.util.rtree.RTree.T"/></c></c>
</f></getLeafsFromPosition>
		<getObjectsFromRange public="1" set="method" line="40"><f a="topX:topY:botX:botY:?overlapX:?overlapY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.util.rtree.RTree.T"/></c>
</f></getObjectsFromRange>
		<getObjectsFromPosition public="1" set="method" line="34"><f a="topX:topY:?overlapX:?overlapY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Array"><c path="firmament.util.rtree.RTree.T"/></c>
</f></getObjectsFromPosition>
		<insertObj public="1" set="method" line="28"><f a="obj:topX:topY:botX:botY">
	<c path="firmament.util.rtree.RTree.T"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></insertObj>
		<mainNode><c path="firmament.util.rtree.RTNode"><c path="firmament.util.rtree.RTree.T"/></c></mainNode>
		<toleranceEpsilon><c path="Float"/></toleranceEpsilon>
		<maxChildsPerNode><c path="Int"/></maxChildsPerNode>
		<new public="1" set="method" line="12"><f a="mainTopX:mainTopY:mainBotX:mainBotY:?maxChildsPerNode:?toleranceEpsilon:?workNodeTopX:?workNodeTopY:?workNodeBotX:?workNodeBotY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<isPlaying public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="54" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="86" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="95" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="105" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="113" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="119" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="147" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="162" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="206" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="82"><f a=""><e path="Void"/></f></init>
		<doInitDelay set="method" line="77"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<start set="method" line="56"><f a=""><e path="Void"/></f></start>
		<new public="1" set="method" line="48"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.Vector" params="T" file="/usr/lib/haxe/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><e path="Bool"/></fixed>
		<length public="1"><t path="UInt"/></length>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><e path="Bool"/></stub>
		<errno public="1"><t path="UInt"/></errno>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><e path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.Bitmap" params="" file="/usr/lib/haxe/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<encode public="1">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<d/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<drawWithQuality public="1">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</drawWithQuality>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><c path="Int"/></width>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><c path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/lib/nme/3,5,1/flash/display/Graphics.hx" extern="1">
		<drawTiles public="1" get="inline" set="null" line="30"><f a="sheet:tileData:?smooth:?flags">
	<c path="nme.display.Tilesheet"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTiles>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><c path="Float"/></c>
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<cubicCurveTo public="1">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><c path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<uncaughtErrorEvents public="1" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<swfVersion public="1" set="null"><t path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<isURLInaccessible public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<height public="1" set="null"><c path="Int"/></height>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="/usr/lib/haxe/std/flash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Shape" params="" file="/usr/lib/haxe/std/flash/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<wmodeGPU public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<stageVideos public="1">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stage3Ds public="1">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<softKeyboardRect public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<mouseLock public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<frameRate public="1"><c path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<displayContextInfo public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<color public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<allowsFullScreenInteractive public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<allowsFullScreen public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</allowsFullScreen>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode">
	<c path="String"/>
	<e path="Void"/>
</f></requestContext3D>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<visible public="1"><e path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/lib/haxe/std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<e path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<c path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><e path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromByteArray public="1">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<e path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<e path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><e path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<c path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED/>
		<BGRA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><t path="UInt"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.KeyboardEvent" params="" file="/usr/lib/haxe/std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<charCode public="1"><t path="UInt"/></charCode>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/usr/lib/haxe/std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</CONTEXT_MENU>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</RELEASE_OUTSIDE>
		<RIGHT_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<movementY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementY>
		<movementX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementX>
		<localY public="1"><c path="Float"/></localY>
		<localX public="1"><c path="Float"/></localX>
		<isRelatedObjectInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<delta public="1"><c path="Int"/></delta>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TimerEvent" params="" file="/usr/lib/haxe/std/flash/events/TimerEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<TIMER public="1" static="1"><c path="String"/></TIMER>
		<TIMER_COMPLETE public="1" static="1"><c path="String"/></TIMER_COMPLETE>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TouchEvent" params="" file="/usr/lib/haxe/std/flash/events/TouchEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROXIMITY_BEGIN public="1" static="1"><c path="String"/></PROXIMITY_BEGIN>
		<PROXIMITY_END public="1" static="1"><c path="String"/></PROXIMITY_END>
		<PROXIMITY_MOVE public="1" static="1"><c path="String"/></PROXIMITY_MOVE>
		<PROXIMITY_OUT public="1" static="1"><c path="String"/></PROXIMITY_OUT>
		<PROXIMITY_OVER public="1" static="1"><c path="String"/></PROXIMITY_OVER>
		<PROXIMITY_ROLL_OUT public="1" static="1"><c path="String"/></PROXIMITY_ROLL_OUT>
		<PROXIMITY_ROLL_OVER public="1" static="1"><c path="String"/></PROXIMITY_ROLL_OVER>
		<TOUCH_BEGIN public="1" static="1"><c path="String"/></TOUCH_BEGIN>
		<TOUCH_END public="1" static="1"><c path="String"/></TOUCH_END>
		<TOUCH_MOVE public="1" static="1"><c path="String"/></TOUCH_MOVE>
		<TOUCH_OUT public="1" static="1"><c path="String"/></TOUCH_OUT>
		<TOUCH_OVER public="1" static="1"><c path="String"/></TOUCH_OVER>
		<TOUCH_ROLL_OUT public="1" static="1"><c path="String"/></TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER public="1" static="1"><c path="String"/></TOUCH_ROLL_OVER>
		<TOUCH_TAP public="1" static="1"><c path="String"/></TOUCH_TAP>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<touchPointID public="1"><c path="Int"/></touchPointID>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<sizeY public="1"><c path="Float"/></sizeY>
		<sizeX public="1"><c path="Float"/></sizeX>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<pressure public="1"><c path="Float"/></pressure>
		<localY public="1"><c path="Float"/></localY>
		<localX public="1"><c path="Float"/></localX>
		<isRelatedObjectInaccessible public="1"><e path="Bool"/></isRelatedObjectInaccessible>
		<isPrimaryTouchPoint public="1"><e path="Bool"/></isPrimaryTouchPoint>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?touchPointID:?isPrimaryTouchPoint:?localX:?localY:?sizeX:?sizeY:?pressure:?relatedObject:?ctrlKey:?altKey:?shiftKey">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<redOffset public="1"><c path="Float"/></redOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<color public="1"><t path="UInt"/></color>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="aa:ba:ca:da:txa:tya">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyFrom public="1">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><c path="Float"/></ty>
		<tx public="1"><c path="Float"/></tx>
		<d public="1"><c path="Float"/></d>
		<c public="1"><c path="Float"/></c>
		<b public="1"><c path="Float"/></b>
		<a public="1"><c path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<copyToMatrix3D public="1">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRawDataTo public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataTo>
		<copyRawDataFrom public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataFrom>
		<copyFrom public="1">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/lib/haxe/std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><c path="Float"/></focalLength>
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="xa:ya:widtha:heighta">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><c path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><c path="Float"/></right>
		<left public="1"><c path="Float"/></left>
		<height public="1"><c path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><c path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya:za">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><c path="Float"/></z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<w public="1"><c path="Float"/></w>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" set="method" static="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<position public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<index public="1" set="null"><c path="Int"/></index>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.ID3Info" params="" file="/usr/lib/haxe/std/flash/media/ID3Info.hx" extern="1">
		<year public="1"><c path="String"/></year>
		<track public="1"><c path="String"/></track>
		<songName public="1"><c path="String"/></songName>
		<genre public="1"><c path="String"/></genre>
		<comment public="1"><c path="String"/></comment>
		<artist public="1"><c path="String"/></artist>
		<album public="1"><c path="String"/></album>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" static="1">
			<f a="?index">
				<c path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<rate public="1"><c path="Int"/></rate>
		<noiseSuppressionLevel public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<index public="1" set="null"><c path="Int"/></index>
		<gain public="1"><c path="Float"/></gain>
		<framesPerPacket public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<encodeQuality public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enableVAD public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><c path="Int"/></isVoiceDetected>
		<echoPath public="1"><c path="Int"/></echoPath>
		<autoGain public="1"><e path="Bool"/></autoGain>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.media.Sound" params="" file="/usr/lib/haxe/std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<play public="1" set="method"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<loadPCMFromByteArray public="1">
			<f a="bytes:samples:?format:?stereo:?sampleRate">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<c path="String"/>
				<e path="Bool"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadPCMFromByteArray>
		<loadCompressedDataFromByteArray public="1">
			<f a="bytes:bytesLength">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadCompressedDataFromByteArray>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></load>
		<extract public="1" set="method">
			<f a="target:length:?startPosition">
				<c path="flash.utils.ByteArray"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</extract>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<url public="1" set="null"><c path="String"/></url>
		<length public="1" set="null"><c path="Float"/></length>
		<isURLInaccessible public="1" set="null">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<isBuffering public="1" set="null"><e path="Bool"/></isBuffering>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundChannel" params="" file="/usr/lib/haxe/std/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<rightPeak public="1" set="null"><c path="Float"/></rightPeak>
		<position public="1" set="null"><c path="Float"/></position>
		<leftPeak public="1" set="null"><c path="Float"/></leftPeak>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/lib/haxe/std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="/usr/lib/haxe/std/flash/media/SoundLoaderContext.hx" extern="1">
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<new public="1" set="method"><f a="?bufferTime:?checkPolicyFile">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><c path="Float"/></volume>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<pan public="1"><c path="Float"/></pan>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><c path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<proxyType public="1"><c path="String"/></proxyType>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<maxPeerConnections public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<step public="1" set="method">
			<f a="frames">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<dispose public="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attach public="1" set="method">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<appendBytesAction public="1" set="method">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<appendBytes public="1" set="method">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<videoSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<useJitterBuffer public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<useHardwareDecoder public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<time public="1" set="null"><c path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<multicastWindowDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<multicastRelayMarginDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastPushNeighborLimit public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastInfo public="1" set="null">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastFetchPeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastAvailabilityUpdatePeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastAvailabilitySendToAll public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<maxPauseBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<inBufferSeek public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<dataReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bufferTimeMax public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<backBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<backBufferLength public="1" set="null">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<audioSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<audioReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoLossRate public="1" set="null">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><e path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<new public="1" set="method"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><c path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<offset public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<len public="1"><c path="Float"/></len>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<getQualifiedDefinitionNames public="1">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<allowLoadBytesCodeExecution public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<allowCodeImport public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.Font" params="" file="/usr/lib/haxe/std/flash/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1"><f a="?enumerateDeviceFonts">
	<e path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<registerFont public="1" set="method" static="1"><f a="font">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></registerFont>
		<hasGlyphs public="1" set="method"><f a="str">
	<c path="String"/>
	<e path="Bool"/>
</f></hasGlyphs>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.FontStyle" params="" file="/usr/lib/haxe/std/flash/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.FontType" params="" file="/usr/lib/haxe/std/flash/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><c path="Float"/></thickness>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<textInteractionMode public="1">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textColor public="1"><t path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><c path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><e path="Bool"/></selectable>
		<scrollV public="1"><c path="Int"/></scrollV>
		<scrollH public="1"><c path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<multiline public="1"><e path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxChars public="1"><c path="Int"/></maxChars>
		<length public="1" set="null"><c path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<border public="1"><e path="Bool"/></border>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<background public="1"><e path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<leading public="1"><c path="Float"/></leading>
		<height public="1"><c path="Float"/></height>
		<descent public="1"><c path="Float"/></descent>
		<ascent public="1"><c path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" set="null" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clipboardMenu public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><e path="Bool"/></zoom>
		<save public="1"><e path="Bool"/></save>
		<rewind public="1"><e path="Bool"/></rewind>
		<quality public="1"><e path="Bool"/></quality>
		<print public="1"><e path="Bool"/></print>
		<play public="1"><e path="Bool"/></play>
		<loop public="1"><e path="Bool"/></loop>
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<paste public="1"><e path="Bool"/></paste>
		<cut public="1"><e path="Bool"/></cut>
		<copy public="1"><e path="Bool"/></copy>
		<clear public="1"><e path="Bool"/></clear>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="/usr/lib/haxe/std/flash/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
		<D_PAD/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
	</class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<inflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<deflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<clear public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<position public="1"><t path="UInt"/></position>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<length public="1"><t path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.utils.Namespace" params="" file="/usr/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.RegExp" params="" file="/usr/lib/haxe/std/flash/utils/RegExp.hx" extern="1">
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</test>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>http://adobe.com/AS3/2006/builtin</e></m></meta>
		</exec>
		<source public="1" set="null"><c path="String"/></source>
		<multiline public="1" set="null"><e path="Bool"/></multiline>
		<lastIndex public="1"><c path="Int"/></lastIndex>
		<ignoreCase public="1" set="null"><e path="Bool"/></ignoreCase>
		<global public="1" set="null"><e path="Bool"/></global>
		<extended public="1" set="null"><e path="Bool"/></extended>
		<dotall public="1" set="null"><e path="Bool"/></dotall>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":native"><e>RegExp</e></m></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.utils.Timer" params="" file="/usr/lib/haxe/std/flash/utils/Timer.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<start public="1" set="method"><f a=""><e path="Void"/></f></start>
		<reset public="1" set="method"><f a=""><e path="Void"/></f></reset>
		<running public="1" set="null"><e path="Bool"/></running>
		<repeatCount public="1"><c path="Int"/></repeatCount>
		<delay public="1"><c path="Float"/></delay>
		<currentCount public="1" set="null"><c path="Int"/></currentCount>
		<new public="1" set="method"><f a="delay:?repeatCount">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="format.display.FrameLabel" params="" file="/usr/lib/haxe/lib/nme/3,5,1/format/display/FrameLabel.hx">
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method" line="11"><f a="frame:name">
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="format.display.MovieClip" params="" file="/usr/lib/haxe/lib/nme/3,5,1/format/display/MovieClip.hx">
		<extends path="flash.display.Sprite"/>
		<unflatten public="1" set="method" line="97"><f a=""><e path="Void"/></f></unflatten>
		<stop public="1" set="method" line="90"><f a=""><e path="Void"/></f></stop>
		<prevFrame public="1" set="method" line="83"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method" line="76"><f a=""><e path="Void"/></f></play>
		<nextFrame public="1" set="method" line="62"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method" line="55"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method" line="48"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<flatten public="1" set="method" line="41"><f a=""><e path="Void"/></f></flatten>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentLabels public="1" set="null"><c path="Array"><c path="format.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null"><c path="String"/></currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new set="method" line="34"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Base class for MovieClip-related format libraries
 * 
 * Cannot use flash.display.MovieClip, because it does
 * not allow the addition for frames or frame labels at
 * runtime, asynchronously</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="63" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.Timer" params="" file="/usr/lib/haxe/lib/nme/3,5,1/haxe/Timer.hx">
		<delay public="1" set="method" line="54" static="1">
			<f a="f:time_ms">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>This will delay the call to [f] for the given time. [f] will only be called once.</haxe_doc>
		</delay>
		<measure public="1" params="T" set="method" line="68" static="1">
			<f a="f:?pos">
				<f a=""><c path="measure.T"/></f>
				<t path="haxe.PosInfos"/>
				<c path="measure.T"/>
			</f>
			<haxe_doc>Measure the time it takes to execute the function [f] and trace it. Returns the value returned by [f].</haxe_doc>
		</measure>
		<stamp public="1" set="method" line="78" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the most precise timestamp, in seconds. The value itself might differ depending on platforms, only differences between two values make sense.</haxe_doc>
		</stamp>
		<run public="1" set="dynamic" line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc>This is the [run()] method that is called when the Timer executes. It can be either overriden in subclasses or directly rebinded with another function-value.</haxe_doc>
		</run>
		<stop public="1" set="method" line="32">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Stop the timer definitely.</haxe_doc>
		</stop>
		<id><t path="Null"><c path="Int"/></t></id>
		<new public="1" set="method" line="16">
			<f a="time_ms">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Create a new timer that will run every [time_ms] (in milliseconds).</haxe_doc>
		</new>
	</class>
	<enum path="nice_json._Render.RenderType" params="" file="/usr/lib/haxe/lib/hx_nice_json/1,0/nice_json/Render.hx" private="1" module="nice_json.Render">
		<Simple/>
		<Linear a="storage"><t path="Iterator"><d/></t></Linear>
		<KeyValue a="storage"><t path="Iterator"><a>
	<value><d/></value>
	<key><c path="String"/></key>
</a></t></KeyValue>
	</enum>
	<class path="nice_json.Render" params="" file="/usr/lib/haxe/lib/hx_nice_json/1,0/nice_json/Render.hx">
		<as_json public="1" set="method" line="69" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Given object, returns well formatted JSON.</haxe_doc>
		</as_json>
		<escape set="method" line="176" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></escape>
		<chooseRender set="method" line="183"><f a="s">
	<d/>
	<e path="nice_json._Render.RenderType"/>
</f></chooseRender>
		<render_simple set="method" line="166"><f a="s">
	<d/>
	<c path="String"/>
</f></render_simple>
		<render_linear_storage set="method" line="148"><f a="storage">
	<t path="Iterator"><d/></t>
	<c path="String"/>
</f></render_linear_storage>
		<render_key_value_storage set="method" line="118"><f a="storage">
	<t path="Iterator"><a>
	<value><d/></value>
	<key><c path="String"/></key>
</a></t>
	<c path="String"/>
</f></render_key_value_storage>
		<has_complicated_rendering get="inline" set="null" line="114"><f a="s">
	<d/>
	<e path="Bool"/>
</f></has_complicated_rendering>
		<get_key_value_storage_iterator set="method" line="104"><f a="s">
	<d/>
	<t path="Iterator"><a>
	<value><d/></value>
	<key><c path="String"/></key>
</a></t>
</f></get_key_value_storage_iterator>
		<is_key_value_storage set="method" line="97"><f a="s">
	<d/>
	<e path="Bool"/>
</f></is_key_value_storage>
		<indent_in get="inline" set="null" line="93"><f a=""><e path="Void"/></f></indent_in>
		<indent_out get="inline" set="null" line="89"><f a=""><e path="Void"/></f></indent_out>
		<key_value_storages><c path="Array"><a>
	<storage_to_iterator><f a="">
	<d/>
	<t path="Iterator"><a>
	<value><d/></value>
	<key><c path="String"/></key>
</a></t>
</f></storage_to_iterator>
	<name><c path="String"/></name>
</a></c></key_value_storages>
		<sort_keys><e path="Bool"/></sort_keys>
		<indent><c path="String"/></indent>
		<json public="1" set="method" line="76">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Given object, returns well formatted JSON.</haxe_doc>
		</json>
		<new public="1" set="method" line="39">
			<f a="?params">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Constructor of [Render] object. Accept the following (optional) parameters:

	   [indent: String] - initial level of indentation. Can be any string, it will be copied in front of every line of output. Default is "".

	   [sort_keys: Bool] - if set, keys for key-value storages (such as Hash and object) will be sorted. It makes output more consistent and might be useful if you're trying to [diff] it.

	   [key_value_storages: Array<{name: String, storage_to_iterator: Dynamic -> Iterator<{key: String, value: Dynamic}>] - allows you to register your own key-value storages. [name] should be [Type.className(Type.getClass(object))], [storage_to_iterator] should be function, that given the object of your storage returns iterator to {key, value} pairs.]]></haxe_doc>
		</new>
		<haxe_doc>The [Render] class provide nice formatted JSON rendering from every possible storage container haXe have, including your own classes.
   There is two ways of using it. In simple cases, you just call [Render.as_json(your_data_object)].
   You can also instantiate it and pass additional parameters, [new Render({sort_keys: true}).json(your_data_object)].

   It renders:

   [Hash], [IntHash] as [{key : value}]

   [Array], [List] and everything that have [iterator()] as [[value1, value2]]

   Class with [toString()] method as string

   Plain objects as [{key, value}]

   Literals as themselves</haxe_doc>
	</class>
	<class path="nice_json.internal_utils.AssortedUtils" params="" file="/usr/lib/haxe/lib/hx_nice_json/1,0/nice_json/internal_utils/AssortedUtils.hx">
		<hash_to_key_value_iterable public="1" set="method" line="10" static="1">
			<f a="s">
				<c path="Hash"><d/></c>
				<a>
					<next><f a=""><a>
	<value><t path="Null"><d/></t></value>
	<key><c path="String"/></key>
</a></f></next>
					<hasNext><f a=""><e path="Bool"/></f></hasNext>
				</a>
			</f>
			<haxe_doc>Given [Hash], returns iterator to {key, value} pairs. Used in [Render] to iterate through [Hash].</haxe_doc>
		</hash_to_key_value_iterable>
		<int_hash_to_key_value_iterable public="1" set="method" line="21" static="1">
			<f a="s">
				<c path="IntHash"><d/></c>
				<a>
					<next><f a=""><a>
	<value><t path="Null"><d/></t></value>
	<key><c path="String"/></key>
</a></f></next>
					<hasNext><f a=""><e path="Bool"/></f></hasNext>
				</a>
			</f>
			<haxe_doc>Given [IntHash], returns iterator to {key, value} pairs. Used in [Render] to iterate through [IntHash].</haxe_doc>
		</int_hash_to_key_value_iterable>
		<object_to_key_value_iterable public="1" set="method" line="32" static="1">
			<f a="s">
				<d/>
				<a>
					<next><f a=""><a>
	<value><d/></value>
	<key><c path="String"/></key>
</a></f></next>
					<hasNext><f a=""><e path="Bool"/></f></hasNext>
				</a>
			</f>
			<haxe_doc>Given object, returns iterator to {key, value} pairs. Used in [Render] to iterate through simple objects.</haxe_doc>
		</object_to_key_value_iterable>
		<array_from_iterator public="1" params="T" set="method" line="43" static="1">
			<f a="it">
				<t path="Iterator"><c path="array_from_iterator.T"/></t>
				<c path="Array"><c path="array_from_iterator.T"/></c>
			</f>
			<haxe_doc>Return [Array] from [Iterator]</haxe_doc>
		</array_from_iterator>
		<sort_by_keys public="1" set="method" line="50" static="1">
			<f a="kv">
				<t path="Iterator"><a>
	<value><d/></value>
	<key><c path="String"/></key>
</a></t>
				<c path="Array"><a>
	<value><d/></value>
	<key><c path="String"/></key>
</a></c>
			</f>
			<haxe_doc>Given iterator to {key, value}, returns array with those {key, value} pairs, sorted by key.</haxe_doc>
		</sort_by_keys>
		<compare_string public="1" set="method" line="61" static="1">
			<f a="a:b">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[Returns -1 if a < b, 0 if a = b, 1 if a > b. Used in [Array.sort].]]></haxe_doc>
		</compare_string>
		<haxe_doc>Few utilities to make my life simpler.</haxe_doc>
	</class>
	<class path="nice_json.internal_utils.TypeUtils" params="" file="/usr/lib/haxe/lib/hx_nice_json/1,0/nice_json/internal_utils/TypeUtils.hx">
		<class_name public="1" get="inline" set="null" line="10" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns class name of an object.</haxe_doc>
		</class_name>
		<has_iterator public="1" get="inline" set="null" line="17" static="1">
			<f a="s">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Checks if object has [iterator] field</haxe_doc>
		</has_iterator>
		<has_to_string public="1" get="inline" set="null" line="24" static="1">
			<f a="s">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Checks if object has [toString] field</haxe_doc>
		</has_to_string>
		<has_field public="1" get="inline" set="null" line="31" static="1">
			<f a="s:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Checks if object has given field</haxe_doc>
		</has_field>
		<is_object public="1" get="inline" set="null" line="39" static="1">
			<f a="s">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Checks if it is an object or primitive</haxe_doc>
		</is_object>
		<haxe_doc>Few utilities to operate on types</haxe_doc>
	</class>
	<class path="nme.Assets" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/Assets.hx">
		<cachedBitmapData public="1" line="31" static="1"><c path="Hash"><t path="nme.display.BitmapData"/></c></cachedBitmapData>
		<getBitmapData public="1" set="method" line="41" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<e path="Bool"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap (Assets.getBitmapData ("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache (Default: true)
	 * @return		A new BItmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="54" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes ("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="67" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont ("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getMovieClip public="1" set="method" line="80" static="1">
			<f a="id">
				<c path="String"/>
				<c path="format.display.MovieClip"/>
			</f>
			<haxe_doc>* Gets an instance of a library MovieClip
	 * @usage		var movieClip = Assets.getMovieClip ("library:BouncingBall");
	 * @param	id		The library and ID for the MovieClip
	 * @return		A new Sound object</haxe_doc>
		</getMovieClip>
		<getSound public="1" set="method" line="93" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound ("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="106" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText ("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the NME command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>]]></haxe_doc>
	</class>
	<class path="nme.Lib" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/Lib.hx">
		<FULLSCREEN public="1" line="13" static="1"><c path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="14" static="1"><c path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="15" static="1"><c path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="16" static="1"><c path="Int"/></HARDWARE>
		<VSYNC public="1" line="17" static="1"><c path="Int"/></VSYNC>
		<HW_AA public="1" line="18" static="1"><c path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="19" static="1"><c path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="20" static="1"><c path="Int"/></ALLOW_SHADERS>
		<REQUIRE_SHADERS public="1" line="21" static="1"><c path="Int"/></REQUIRE_SHADERS>
		<DEPTH_BUFFER public="1" line="22" static="1"><c path="Int"/></DEPTH_BUFFER>
		<STENCIL_BUFFER public="1" line="23" static="1"><c path="Int"/></STENCIL_BUFFER>
		<MIN_FLOAT_VALUE public="1" line="26" static="1"><c path="Float"/></MIN_FLOAT_VALUE>
		<MAX_FLOAT_VALUE public="1" line="27" static="1"><c path="Float"/></MAX_FLOAT_VALUE>
		<company public="1" get="get_company" set="null" static="1"><c path="String"/></company>
		<current public="1" get="get_current" set="null" static="1"><t path="nme.display.MovieClip"/></current>
		<file public="1" get="get_file" set="null" static="1"><c path="String"/></file>
		<initHeight public="1" get="get_initHeight" set="null" static="1"><c path="Int"/></initHeight>
		<initWidth public="1" get="get_initWidth" set="null" static="1"><c path="Int"/></initWidth>
		<packageName public="1" get="get_packageName" set="null" static="1"><c path="String"/></packageName>
		<stage public="1" get="get_stage" set="null" static="1"><t path="nme.display.Stage"/></stage>
		<version public="1" get="get_version" set="null" static="1"><c path="String"/></version>
		<close public="1" set="method" line="50" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Closes the application.
	 * This is method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</close>
		<create public="1" set="method" line="73" static="1">
			<f a="onLoaded:width:height:?frameRate:?color:?flags:?title:?icon">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<t path="nme.display.BitmapData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Creates a new application window. If you are using the NME
	 * command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This is method is ignored in the Flash and HTML5 targets.
	 * @param	onLoaded		A method callback that is called once the window is created.
	 * @param	width		The requested width of the window. Use a width and height of 0 to request the full screen size.
	 * @param	height		The requested height of the window. Use a width and height of 0 to request the full screen size.
	 * @param	frameRate		The requested frame rate for the application.
	 * @param	color		An RGB color to use for the application background.
	 * @param	flags		A series of bit flags which can specify windowing options, like FULLSCREEN or HARDWARE
	 * @param	title		The title to use when creating the application window.
	 * @param	icon		An icon to use for the created application window.</haxe_doc>
		</create>
		<createManagedStage public="1" set="method" line="89" static="1">
			<f a="width:height">
				<c path="Int"/>
				<c path="Int"/>
				<unknown/>
			</f>
			<haxe_doc>* Creates a managed stage, for greater control customization and control
	 * of application events.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	width		The requested width of the managed stage.
	 * @param	height		The requested width of the managed stage.</haxe_doc>
		</createManagedStage>
		<exit public="1" set="method" line="105" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Similar to the <code>close()</code> method, but the current 
	 * <code>Stage</code> object is given an opportunity to handle 
	 * the quit event before the application process is ended.
	 * This method is ignored in the Flash and HTML5 targets.]]></haxe_doc>
		</exit>
		<forceClose public="1" set="method" line="119" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Terminates the application process immediately without
	 * performing a clean shutdown.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</forceClose>
		<getTimer public="1" get="inline" set="null" line="137" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Returns the time in milliseconds, relative to the start of
	 * the application. This is a high performance call in order to 
	 * help regulate time-based operations. Depending upon the
	 * target platform, this value may or may not be an absolute
	 * timestamp. If you need an exact time, you should use the
	 * <code>Date</code> object.
	 * @return		A relative time value in milliseconds.]]></haxe_doc>
		</getTimer>
		<getURL public="1" set="method" line="156" static="1">
			<f a="url:?target">
				<t path="nme.net.URLRequest"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Opens a browser window with the specified URL. 
	 * @param	url		The URL to open.
	 * @param	target		An optional window target value.</haxe_doc>
		</getURL>
		<pause public="1" set="method" line="175" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* For supported platforms, the NME application will be
	 * paused. This can help improve response times if fullscreen
	 * native UI element is being used temporarily.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</pause>
		<postUICallback public="1" set="method" line="193" static="1">
			<f a="handler">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>* For some target platforms, NME operates on a separate thread
	 * than the native application UI. In these cases, you can use this
	 * method to make thread-safe calls to the native UI.
	 * 
	 * If the platform does not require thread-safe callbacks, the 
	 * handler method will be called immediately.
	 * @param	handler		The method handler you wish to call when the UI is available.</haxe_doc>
		</postUICallback>
		<resume public="1" set="method" line="210" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resumes the NME application. For certain platforms,
	 * pausing the application can improve response times when
	 * a fullscreen native UI element is being displayed.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</resume>
		<setPackage public="1" set="method" line="229" static="1">
			<f a="company:file:packageName:version">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Specifies meta-data for the running application. If you are using 
	 * the NME command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	company		The company name for the application.
	 * @param	file		The file name for the application.
	 * @param	packageName		The package name of the application.
	 * @param	version		The version string of the application.</haxe_doc>
		</setPackage>
		<trace public="1" set="method" line="242" static="1">
			<f a="arg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sends a <code>trace</code> call for the current platform.
	 * @param	arg]]></haxe_doc>
		</trace>
		<get_company set="method" line="261" static="1"><f a=""><c path="String"/></f></get_company>
		<get_current set="method" line="271" static="1"><f a=""><t path="nme.display.MovieClip"/></f></get_current>
		<get_file set="method" line="285" static="1"><f a=""><c path="String"/></f></get_file>
		<get_initHeight set="method" line="295" static="1"><f a=""><c path="Int"/></f></get_initHeight>
		<get_initWidth set="method" line="305" static="1"><f a=""><c path="Int"/></f></get_initWidth>
		<get_packageName set="method" line="315" static="1"><f a=""><c path="String"/></f></get_packageName>
		<get_stage set="method" line="325" static="1"><f a=""><t path="nme.display.Stage"/></f></get_stage>
		<get_version set="method" line="337" static="1"><f a=""><c path="String"/></f></get_version>
	</class>
	<typedef path="nme.Vector" params="T" file="/usr/lib/haxe/lib/nme/3,5,1/nme/Vector.hx"><c path="flash.Vector"><c path="nme.Vector.T"/></c></typedef>
	<typedef path="nme.display.Bitmap" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/Bitmap.hx"><c path="flash.display.Bitmap"/></typedef>
	<typedef path="nme.display.BitmapData" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/BitmapData.hx"><c path="flash.display.BitmapData"/></typedef>
	<typedef path="nme.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/DisplayObjectContainer.hx"><c path="flash.display.DisplayObjectContainer"/></typedef>
	<typedef path="nme.display.Graphics" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/Graphics.hx"><c path="flash.display.Graphics"/></typedef>
	<typedef path="nme.display.IBitmapDrawable" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/IBitmapDrawable.hx"><c path="flash.display.IBitmapDrawable"/></typedef>
	<typedef path="nme.display.MovieClip" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/MovieClip.hx"><c path="flash.display.MovieClip"/></typedef>
	<typedef path="nme.display.Shape" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/Shape.hx"><c path="flash.display.Shape"/></typedef>
	<typedef path="nme.display.Sprite" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/Sprite.hx"><c path="flash.display.Sprite"/></typedef>
	<typedef path="nme.display.Stage" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/display/Stage.hx"><c path="flash.display.Stage"/></typedef>
	<typedef path="nme.events.Event" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/events/Event.hx"><c path="flash.events.Event"/></typedef>
	<typedef path="nme.events.EventDispatcher" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/events/EventDispatcher.hx"><c path="flash.events.EventDispatcher"/></typedef>
	<typedef path="nme.events.KeyboardEvent" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/events/KeyboardEvent.hx"><c path="flash.events.KeyboardEvent"/></typedef>
	<typedef path="nme.events.MouseEvent" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/events/MouseEvent.hx"><c path="flash.events.MouseEvent"/></typedef>
	<typedef path="nme.events.TimerEvent" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/events/TimerEvent.hx"><c path="flash.events.TimerEvent"/></typedef>
	<typedef path="nme.events.TouchEvent" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/events/TouchEvent.hx"><c path="flash.events.TouchEvent"/></typedef>
	<typedef path="nme.geom.Matrix" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/geom/Matrix.hx"><c path="flash.geom.Matrix"/></typedef>
	<typedef path="nme.geom.Point" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/geom/Point.hx"><c path="flash.geom.Point"/></typedef>
	<typedef path="nme.geom.Rectangle" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/geom/Rectangle.hx"><c path="flash.geom.Rectangle"/></typedef>
	<typedef path="nme.media.Sound" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/media/Sound.hx"><c path="flash.media.Sound"/></typedef>
	<typedef path="nme.media.SoundChannel" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/media/SoundChannel.hx"><c path="flash.media.SoundChannel"/></typedef>
	<typedef path="nme.media.SoundTransform" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/media/SoundTransform.hx"><c path="flash.media.SoundTransform"/></typedef>
	<typedef path="nme.net.URLRequest" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/net/URLRequest.hx"><c path="flash.net.URLRequest"/></typedef>
	<typedef path="nme.text.Font" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/text/Font.hx"><c path="flash.text.Font"/></typedef>
	<typedef path="nme.text.TextField" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/text/TextField.hx"><c path="flash.text.TextField"/></typedef>
	<typedef path="nme.text.TextFieldType" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/text/TextFieldType.hx"><e path="flash.text.TextFieldType"/></typedef>
	<typedef path="nme.text.TextFormat" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/text/TextFormat.hx"><c path="flash.text.TextFormat"/></typedef>
	<typedef path="nme.utils.ByteArray" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/utils/ByteArray.hx"><c path="flash.utils.ByteArray"/></typedef>
	<typedef path="nme.utils.Timer" params="" file="/usr/lib/haxe/lib/nme/3,5,1/nme/utils/Timer.hx"><c path="flash.utils.Timer"/></typedef>
	<class path="tjson.TJSON" params="" file="/usr/lib/haxe/lib/tjson/1,0,2/tjson/TJSON.hx">
		<pos static="1"><c path="Int"/></pos>
		<json static="1"><c path="String"/></json>
		<lastSymbolQuoted static="1"><e path="Bool"/></lastSymbolQuoted>
		<floatRegex get="inline" set="null" line="9" static="1"><c path="EReg"/></floatRegex>
		<intRegex get="inline" set="null" line="10" static="1"><c path="EReg"/></intRegex>
		<parse public="1" set="method" line="12" static="1"><f a="json">
	<c path="String"/>
	<d/>
</f></parse>
		<doParse set="method" line="20" static="1"><f a=""><d/></f></doParse>
		<doObject set="method" line="33" static="1"><f a=""><d/></f></doObject>
		<doArray set="method" line="62" static="1"><f a=""><d/></f></doArray>
		<convertSymbolToProperType set="method" line="84" static="1"><f a="symbol">
	<c path="String"/>
	<d/>
</f></convertSymbolToProperType>
		<looksLikeFloat set="method" line="102" static="1"><f a="s">
	<c path="String"/>
	<e path="Bool"/>
</f></looksLikeFloat>
		<looksLikeInt set="method" line="109" static="1"><f a="s">
	<c path="String"/>
	<e path="Bool"/>
</f></looksLikeInt>
		<getNextSymbol set="method" line="117" static="1"><f a=""><c path="String"/></f></getNextSymbol>
	</class>
</haxe>